"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-client_node_modules_editorjs_editorjs_dist_editorjs_mjs"],{

/***/ "(app-client)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@editorjs/editorjs/dist/editorjs.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ fi; }\n/* harmony export */ });\nvar Lt = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction xe(s) {\n  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, \"default\") ? s.default : s;\n}\nfunction Be() {\n}\nObject.assign(Be, {\n  default: Be,\n  register: Be,\n  revert: function() {\n  },\n  __esModule: !0\n});\nElement.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {\n  const e = (this.document || this.ownerDocument).querySelectorAll(s);\n  let t = e.length;\n  for (; --t >= 0 && e.item(t) !== this; )\n    ;\n  return t > -1;\n});\nElement.prototype.closest || (Element.prototype.closest = function(s) {\n  let e = this;\n  if (!document.documentElement.contains(e))\n    return null;\n  do {\n    if (e.matches(s))\n      return e;\n    e = e.parentElement || e.parentNode;\n  } while (e !== null);\n  return null;\n});\nElement.prototype.prepend || (Element.prototype.prepend = function(e) {\n  const t = document.createDocumentFragment();\n  Array.isArray(e) || (e = [e]), e.forEach((o) => {\n    const i = o instanceof Node;\n    t.appendChild(i ? o : document.createTextNode(o));\n  }), this.insertBefore(t, this.firstChild);\n});\nElement.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(s) {\n  s = arguments.length === 0 ? !0 : !!s;\n  const e = this.parentNode, t = window.getComputedStyle(e, null), o = parseInt(t.getPropertyValue(\"border-top-width\")), i = parseInt(t.getPropertyValue(\"border-left-width\")), n = this.offsetTop - e.offsetTop < e.scrollTop, r = this.offsetTop - e.offsetTop + this.clientHeight - o > e.scrollTop + e.clientHeight, a = this.offsetLeft - e.offsetLeft < e.scrollLeft, l = this.offsetLeft - e.offsetLeft + this.clientWidth - i > e.scrollLeft + e.clientWidth, c = n && !r;\n  (n || r) && s && (e.scrollTop = this.offsetTop - e.offsetTop - e.clientHeight / 2 - o + this.clientHeight / 2), (a || l) && s && (e.scrollLeft = this.offsetLeft - e.offsetLeft - e.clientWidth / 2 - i + this.clientWidth / 2), (n || r || a || l) && !s && this.scrollIntoView(c);\n});\nlet Ot = (s = 21) => crypto.getRandomValues(new Uint8Array(s)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += \"-\" : e += \"_\", e), \"\");\nvar et = /* @__PURE__ */ ((s) => (s.VERBOSE = \"VERBOSE\", s.INFO = \"INFO\", s.WARN = \"WARN\", s.ERROR = \"ERROR\", s))(et || {});\nconst B = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91\n}, _t = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nfunction ge(s, e, t = \"log\", o, i = \"color: inherit\") {\n  if (!(\"console\" in window) || !window.console[t])\n    return;\n  const n = [\"info\", \"log\", \"warn\", \"error\"].includes(t), r = [];\n  switch (ge.logLevel) {\n    case \"ERROR\":\n      if (t !== \"error\")\n        return;\n      break;\n    case \"WARN\":\n      if (![\"error\", \"warn\"].includes(t))\n        return;\n      break;\n    case \"INFO\":\n      if (!n || s)\n        return;\n      break;\n  }\n  o && r.push(o);\n  const a = \"Editor.js 2.27.2\", l = `line-height: 1em;\n            color: #006FEA;\n            display: inline-block;\n            font-size: 11px;\n            line-height: 1em;\n            background-color: #fff;\n            padding: 4px 9px;\n            border-radius: 30px;\n            border: 1px solid rgba(56, 138, 229, 0.16);\n            margin: 4px 5px 4px 0;`;\n  s && (n ? (r.unshift(l, i), e = `%c${a}%c ${e}`) : e = `( ${a} )${e}`);\n  try {\n    n ? o ? console[t](`${e} %o`, ...r) : console[t](e, ...r) : console[t](e);\n  } catch {\n  }\n}\nge.logLevel = \"VERBOSE\";\nfunction At(s) {\n  ge.logLevel = s;\n}\nconst T = ge.bind(window, !1), K = ge.bind(window, !0);\nfunction te(s) {\n  return Object.prototype.toString.call(s).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction D(s) {\n  return te(s) === \"function\" || te(s) === \"asyncfunction\";\n}\nfunction j(s) {\n  return te(s) === \"object\";\n}\nfunction J(s) {\n  return te(s) === \"string\";\n}\nfunction Nt(s) {\n  return te(s) === \"boolean\";\n}\nfunction Ve(s) {\n  return te(s) === \"number\";\n}\nfunction Ze(s) {\n  return te(s) === \"undefined\";\n}\nfunction V(s) {\n  return s ? Object.keys(s).length === 0 && s.constructor === Object : !0;\n}\nfunction tt(s) {\n  return s > 47 && s < 58 || // number keys\n  s === 32 || s === 13 || // Space bar & return key(s)\n  s === 229 || // processing key input for certain languages — Chinese, Japanese, etc.\n  s > 64 && s < 91 || // letter keys\n  s > 95 && s < 112 || // Numpad keys\n  s > 185 && s < 193 || // ;=,-./` (in order)\n  s > 218 && s < 223;\n}\nasync function ot(s, e = () => {\n}, t = () => {\n}) {\n  async function o(i, n, r) {\n    try {\n      await i.function(i.data), await n(Ze(i.data) ? {} : i.data);\n    } catch {\n      r(Ze(i.data) ? {} : i.data);\n    }\n  }\n  return s.reduce(async (i, n) => (await i, o(n, e, t)), Promise.resolve());\n}\nfunction it(s) {\n  return Array.prototype.slice.call(s);\n}\nfunction oe(s, e) {\n  return function() {\n    const t = this, o = arguments;\n    window.setTimeout(() => s.apply(t, o), e);\n  };\n}\nfunction Rt(s) {\n  return s.name.split(\".\").pop();\n}\nfunction Dt(s) {\n  return /^[-\\w]+\\/([-+\\w]+|\\*)$/.test(s);\n}\nfunction Pt(s, e, t) {\n  let o;\n  return (...i) => {\n    const n = this, r = () => {\n      o = null, t || s.apply(n, i);\n    }, a = t && !o;\n    window.clearTimeout(o), o = window.setTimeout(r, e), a && s.apply(n, i);\n  };\n}\nfunction Te(s, e, t = void 0) {\n  let o, i, n, r = null, a = 0;\n  t || (t = {});\n  const l = function() {\n    a = t.leading === !1 ? 0 : Date.now(), r = null, n = s.apply(o, i), r || (o = i = null);\n  };\n  return function() {\n    const c = Date.now();\n    !a && t.leading === !1 && (a = c);\n    const u = e - (c - a);\n    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, n = s.apply(o, i), r || (o = i = null)) : !r && t.trailing !== !1 && (r = setTimeout(l, u)), n;\n  };\n}\nfunction Ft() {\n  const s = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, e = Object.keys(s).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);\n  return e && (s[e] = !0), s;\n}\nfunction ke(s) {\n  return s[0].toUpperCase() + s.slice(1);\n}\nfunction Se(s, ...e) {\n  if (!e.length)\n    return s;\n  const t = e.shift();\n  if (j(s) && j(t))\n    for (const o in t)\n      j(t[o]) ? (s[o] || Object.assign(s, { [o]: {} }), Se(s[o], t[o])) : Object.assign(s, { [o]: t[o] });\n  return Se(s, ...e);\n}\nfunction nt(s) {\n  const e = Ft();\n  return s = s.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \" + \"), e.mac ? s = s.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : s = s.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), s;\n}\nfunction Ht(s) {\n  try {\n    return new URL(s).href;\n  } catch {\n  }\n  return s.substring(0, 2) === \"//\" ? window.location.protocol + s : window.location.origin + s;\n}\nfunction zt() {\n  return Ot(10);\n}\nfunction jt(s) {\n  window.open(s, \"_blank\");\n}\nfunction Ut(s = \"\") {\n  return `${s}${Math.floor(Math.random() * 1e8).toString(16)}`;\n}\nfunction Ie(s, e, t) {\n  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;\n  s && K(o, \"warn\");\n}\nfunction ae(s, e, t) {\n  const o = t.value ? \"value\" : \"get\", i = t[o], n = `#${e}Cache`;\n  if (t[o] = function(...r) {\n    return this[n] === void 0 && (this[n] = i.apply(this, ...r)), this[n];\n  }, o === \"get\" && t.set) {\n    const r = t.set;\n    t.set = function(a) {\n      delete s[n], r.apply(this, a);\n    };\n  }\n  return t;\n}\nconst st = 650;\nfunction ee() {\n  return window.matchMedia(`(max-width: ${st}px)`).matches;\n}\nconst Ge = typeof window < \"u\" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction $t(s, e) {\n  const t = Array.isArray(s) || j(s), o = Array.isArray(e) || j(e);\n  return t || o ? JSON.stringify(s) === JSON.stringify(e) : s === e;\n}\nclass d {\n  /**\n   * Check if passed tag has no closed tag\n   *\n   * @param {HTMLElement} tag - element to check\n   * @returns {boolean}\n   */\n  static isSingleTag(e) {\n    return e.tagName && [\n      \"AREA\",\n      \"BASE\",\n      \"BR\",\n      \"COL\",\n      \"COMMAND\",\n      \"EMBED\",\n      \"HR\",\n      \"IMG\",\n      \"INPUT\",\n      \"KEYGEN\",\n      \"LINK\",\n      \"META\",\n      \"PARAM\",\n      \"SOURCE\",\n      \"TRACK\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Check if element is BR or WBR\n   *\n   * @param {HTMLElement} element - element to check\n   * @returns {boolean}\n   */\n  static isLineBreakTag(e) {\n    return e && e.tagName && [\n      \"BR\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Helper for making Elements with class name and attributes\n   *\n   * @param  {string} tagName - new Element tag name\n   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)\n   * @param  {object} [attributes] - any attributes\n   * @returns {HTMLElement}\n   */\n  static make(e, t = null, o = {}) {\n    const i = document.createElement(e);\n    Array.isArray(t) ? i.classList.add(...t) : t && i.classList.add(t);\n    for (const n in o)\n      Object.prototype.hasOwnProperty.call(o, n) && (i[n] = o[n]);\n    return i;\n  }\n  /**\n   * Creates Text Node with the passed content\n   *\n   * @param {string} content - text content\n   * @returns {Text}\n   */\n  static text(e) {\n    return document.createTextNode(e);\n  }\n  /**\n   * Append one or several elements to the parent\n   *\n   * @param  {Element|DocumentFragment} parent - where to append\n   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list\n   */\n  static append(e, t) {\n    Array.isArray(t) ? t.forEach((o) => e.appendChild(o)) : e.appendChild(t);\n  }\n  /**\n   * Append element or a couple to the beginning of the parent elements\n   *\n   * @param {Element} parent - where to append\n   * @param {Element|Element[]} elements - element or elements list\n   */\n  static prepend(e, t) {\n    Array.isArray(t) ? (t = t.reverse(), t.forEach((o) => e.prepend(o))) : e.prepend(t);\n  }\n  /**\n   * Swap two elements in parent\n   *\n   * @param {HTMLElement} el1 - from\n   * @param {HTMLElement} el2 - to\n   * @deprecated\n   */\n  static swap(e, t) {\n    const o = document.createElement(\"div\"), i = e.parentNode;\n    i.insertBefore(o, e), i.insertBefore(e, t), i.insertBefore(t, o), i.removeChild(o);\n  }\n  /**\n   * Selector Decorator\n   *\n   * Returns first match\n   *\n   * @param {Element} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {Element}\n   */\n  static find(e = document, t) {\n    return e.querySelector(t);\n  }\n  /**\n   * Get Element by Id\n   *\n   * @param {string} id - id to find\n   * @returns {HTMLElement | null}\n   */\n  static get(e) {\n    return document.getElementById(e);\n  }\n  /**\n   * Selector Decorator.\n   *\n   * Returns all matches\n   *\n   * @param {Element|Document} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {NodeList}\n   */\n  static findAll(e = document, t) {\n    return e.querySelectorAll(t);\n  }\n  /**\n   * Returns CSS selector for all text inputs\n   */\n  static get allInputsSelector() {\n    return \"[contenteditable=true], textarea, input:not([type]), \" + [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"].map((t) => `input[type=\"${t}\"]`).join(\", \");\n  }\n  /**\n   * Find all contenteditable, textarea and editable input elements passed holder contains\n   *\n   * @param holder - element where to find inputs\n   */\n  static findAllInputs(e) {\n    return it(e.querySelectorAll(d.allInputsSelector)).reduce((t, o) => d.isNativeInput(o) || d.containsOnlyInlineElements(o) ? [...t, o] : [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Search for deepest node which is Leaf.\n   * Leaf is the vertex that doesn't have any child nodes\n   *\n   * @description Method recursively goes throw the all Node until it finds the Leaf\n   * @param {Node} node - root Node. From this vertex we start Deep-first search\n   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}\n   * @param {boolean} [atLast] - find last text node\n   * @returns {Node} - it can be text Node or Element Node, so that caret will able to work with it\n   */\n  static getDeepestNode(e, t = !1) {\n    const o = t ? \"lastChild\" : \"firstChild\", i = t ? \"previousSibling\" : \"nextSibling\";\n    if (e && e.nodeType === Node.ELEMENT_NODE && e[o]) {\n      let n = e[o];\n      if (d.isSingleTag(n) && !d.isNativeInput(n) && !d.isLineBreakTag(n))\n        if (n[i])\n          n = n[i];\n        else if (n.parentNode[i])\n          n = n.parentNode[i];\n        else\n          return n.parentNode;\n      return this.getDeepestNode(n, t);\n    }\n    return e;\n  }\n  /**\n   * Check if object is DOM node\n   *\n   * @param {*} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isElement(e) {\n    return Ve(e) ? !1 : e && e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * Check if object is DocumentFragment node\n   *\n   * @param {object} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isFragment(e) {\n    return Ve(e) ? !1 : e && e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Check if passed element is contenteditable\n   *\n   * @param {HTMLElement} element - html element to check\n   * @returns {boolean}\n   */\n  static isContentEditable(e) {\n    return e.contentEditable === \"true\";\n  }\n  /**\n   * Checks target if it is native input\n   *\n   * @param {*} target - HTML element or string\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isNativeInput(e) {\n    const t = [\n      \"INPUT\",\n      \"TEXTAREA\"\n    ];\n    return e && e.tagName ? t.includes(e.tagName) : !1;\n  }\n  /**\n   * Checks if we can set caret\n   *\n   * @param {HTMLElement} target - target to check\n   * @returns {boolean}\n   */\n  static canSetCaret(e) {\n    let t = !0;\n    if (d.isNativeInput(e))\n      switch (e.type) {\n        case \"file\":\n        case \"checkbox\":\n        case \"radio\":\n        case \"hidden\":\n        case \"submit\":\n        case \"button\":\n        case \"image\":\n        case \"reset\":\n          t = !1;\n          break;\n      }\n    else\n      t = d.isContentEditable(e);\n    return t;\n  }\n  /**\n   * Checks node if it is empty\n   *\n   * @description Method checks simple Node without any childs for emptiness\n   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method\n   * @param {Node} node - node to check\n   * @returns {boolean} true if it is empty\n   */\n  static isNodeEmpty(e) {\n    let t;\n    return this.isSingleTag(e) && !this.isLineBreakTag(e) ? !1 : (this.isElement(e) && this.isNativeInput(e) ? t = e.value : t = e.textContent.replace(\"​\", \"\"), t.trim().length === 0);\n  }\n  /**\n   * checks node if it is doesn't have any child nodes\n   *\n   * @param {Node} node - node to check\n   * @returns {boolean}\n   */\n  static isLeaf(e) {\n    return e ? e.childNodes.length === 0 : !1;\n  }\n  /**\n   * breadth-first search (BFS)\n   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}\n   *\n   * @description Pushes to stack all DOM leafs and checks for emptiness\n   * @param {Node} node - node to check\n   * @returns {boolean}\n   */\n  static isEmpty(e) {\n    e.normalize();\n    const t = [e];\n    for (; t.length > 0; )\n      if (e = t.shift(), !!e) {\n        if (this.isLeaf(e) && !this.isNodeEmpty(e))\n          return !1;\n        e.childNodes && t.push(...Array.from(e.childNodes));\n      }\n    return !0;\n  }\n  /**\n   * Check if string contains html elements\n   *\n   * @param {string} str - string to check\n   * @returns {boolean}\n   */\n  static isHTMLString(e) {\n    const t = d.make(\"div\");\n    return t.innerHTML = e, t.childElementCount > 0;\n  }\n  /**\n   * Return length of node`s text content\n   *\n   * @param {Node} node - node with content\n   * @returns {number}\n   */\n  static getContentLength(e) {\n    return d.isNativeInput(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : e.textContent.length;\n  }\n  /**\n   * Return array of names of block html elements\n   *\n   * @returns {string[]}\n   */\n  static get blockElements() {\n    return [\n      \"address\",\n      \"article\",\n      \"aside\",\n      \"blockquote\",\n      \"canvas\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"header\",\n      \"hgroup\",\n      \"hr\",\n      \"li\",\n      \"main\",\n      \"nav\",\n      \"noscript\",\n      \"ol\",\n      \"output\",\n      \"p\",\n      \"pre\",\n      \"ruby\",\n      \"section\",\n      \"table\",\n      \"tbody\",\n      \"thead\",\n      \"tr\",\n      \"tfoot\",\n      \"ul\",\n      \"video\"\n    ];\n  }\n  /**\n   * Check if passed content includes only inline elements\n   *\n   * @param {string|HTMLElement} data - element or html string\n   * @returns {boolean}\n   */\n  static containsOnlyInlineElements(e) {\n    let t;\n    J(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n    const o = (i) => !d.blockElements.includes(i.tagName.toLowerCase()) && Array.from(i.children).every(o);\n    return Array.from(t.children).every(o);\n  }\n  /**\n   * Find and return all block elements in the passed parent (including subtree)\n   *\n   * @param {HTMLElement} parent - root element\n   * @returns {HTMLElement[]}\n   */\n  static getDeepestBlockElements(e) {\n    return d.containsOnlyInlineElements(e) ? [e] : Array.from(e.children).reduce((t, o) => [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Helper for get holder from {string} or return HTMLElement\n   *\n   * @param {string | HTMLElement} element - holder's id or holder's HTML Element\n   * @returns {HTMLElement}\n   */\n  static getHolder(e) {\n    return J(e) ? document.getElementById(e) : e;\n  }\n  /**\n   * Returns true if element is anchor (is A tag)\n   *\n   * @param {Element} element - element to check\n   * @returns {boolean}\n   */\n  static isAnchor(e) {\n    return e.tagName.toLowerCase() === \"a\";\n  }\n  /**\n   * Return element's offset related to the document\n   *\n   * @todo handle case when editor initialized in scrollable popup\n   * @param el - element to compute offset\n   */\n  static offset(e) {\n    const t = e.getBoundingClientRect(), o = window.pageXOffset || document.documentElement.scrollLeft, i = window.pageYOffset || document.documentElement.scrollTop, n = t.top + i, r = t.left + o;\n    return {\n      top: n,\n      left: r,\n      bottom: n + t.height,\n      right: r + t.width\n    };\n  }\n}\nconst Wt = {\n  blockTunes: {\n    toggler: {\n      \"Click to tune\": \"\",\n      \"or drag to move\": \"\"\n    }\n  },\n  inlineToolbar: {\n    converter: {\n      \"Convert to\": \"\"\n    }\n  },\n  toolbar: {\n    toolbox: {\n      Add: \"\"\n    }\n  },\n  popover: {\n    Filter: \"\",\n    \"Nothing found\": \"\"\n  }\n}, Yt = {\n  Text: \"\",\n  Link: \"\",\n  Bold: \"\",\n  Italic: \"\"\n}, Kt = {\n  link: {\n    \"Add a link\": \"\"\n  },\n  stub: {\n    \"The block can not be displayed correctly.\": \"\"\n  }\n}, Xt = {\n  delete: {\n    Delete: \"\",\n    \"Click to delete\": \"\"\n  },\n  moveUp: {\n    \"Move up\": \"\"\n  },\n  moveDown: {\n    \"Move down\": \"\"\n  }\n}, rt = {\n  ui: Wt,\n  toolNames: Yt,\n  tools: Kt,\n  blockTunes: Xt\n}, ie = class {\n  /**\n   * Type-safe translation for internal UI texts:\n   * Perform translation of the string by namespace and a key\n   *\n   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')\n   * @param internalNamespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static ui(s, e) {\n    return ie._t(s, e);\n  }\n  /**\n   * Translate for external strings that is not presented in default dictionary.\n   * For example, for user-specified tool names\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static t(s, e) {\n    return ie._t(s, e);\n  }\n  /**\n   * Adjust module for using external dictionary\n   *\n   * @param dictionary - new messages list to override default\n   */\n  static setDictionary(s) {\n    ie.currentDictionary = s;\n  }\n  /**\n   * Perform translation both for internal and external namespaces\n   * If there is no translation found, returns passed key as a translated message\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static _t(s, e) {\n    const t = ie.getNamespace(s);\n    return !t || !t[e] ? e : t[e];\n  }\n  /**\n   * Find messages section by namespace path\n   *\n   * @param namespace - path to section\n   */\n  static getNamespace(s) {\n    return s.split(\".\").reduce((t, o) => !t || !Object.keys(t).length ? {} : t[o], ie.currentDictionary);\n  }\n};\nlet $ = ie;\n$.currentDictionary = rt;\nclass at extends Error {\n}\nclass we {\n  constructor() {\n    this.subscribers = {};\n  }\n  /**\n   * Subscribe any event on callback\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  on(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []), this.subscribers[e].push(t);\n  }\n  /**\n   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  once(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []);\n    const o = (i) => {\n      const n = t(i), r = this.subscribers[e].indexOf(o);\n      return r !== -1 && this.subscribers[e].splice(r, 1), n;\n    };\n    this.subscribers[e].push(o);\n  }\n  /**\n   * Emit callbacks with passed data\n   *\n   * @param eventName - event name\n   * @param data - subscribers get this data when they were fired\n   */\n  emit(e, t) {\n    V(this.subscribers) || !this.subscribers[e] || this.subscribers[e].reduce((o, i) => {\n      const n = i(o);\n      return n !== void 0 ? n : o;\n    }, t);\n  }\n  /**\n   * Unsubscribe callback from event\n   *\n   * @param eventName - event name\n   * @param callback - event handler\n   */\n  off(e, t) {\n    for (let o = 0; o < this.subscribers[e].length; o++)\n      if (this.subscribers[e][o] === t) {\n        delete this.subscribers[e][o];\n        break;\n      }\n  }\n  /**\n   * Destroyer\n   * clears subscribers list\n   */\n  destroy() {\n    this.subscribers = null;\n  }\n}\nfunction he(s) {\n  Object.setPrototypeOf(this, {\n    /**\n     * Block id\n     *\n     * @returns {string}\n     */\n    get id() {\n      return s.id;\n    },\n    /**\n     * Tool name\n     *\n     * @returns {string}\n     */\n    get name() {\n      return s.name;\n    },\n    /**\n     * Tool config passed on Editor's initialization\n     *\n     * @returns {ToolConfig}\n     */\n    get config() {\n      return s.config;\n    },\n    /**\n     * .ce-block element, that wraps plugin contents\n     *\n     * @returns {HTMLElement}\n     */\n    get holder() {\n      return s.holder;\n    },\n    /**\n     * True if Block content is empty\n     *\n     * @returns {boolean}\n     */\n    get isEmpty() {\n      return s.isEmpty;\n    },\n    /**\n     * True if Block is selected with Cross-Block selection\n     *\n     * @returns {boolean}\n     */\n    get selected() {\n      return s.selected;\n    },\n    /**\n     * Set Block's stretch state\n     *\n     * @param {boolean} state — state to set\n     */\n    set stretched(t) {\n      s.stretched = t;\n    },\n    /**\n     * True if Block is stretched\n     *\n     * @returns {boolean}\n     */\n    get stretched() {\n      return s.stretched;\n    },\n    /**\n     * Call Tool method with errors handler under-the-hood\n     *\n     * @param {string} methodName - method to call\n     * @param {object} param - object with parameters\n     * @returns {unknown}\n     */\n    call(t, o) {\n      return s.call(t, o);\n    },\n    /**\n     * Save Block content\n     *\n     * @returns {Promise<void|SavedData>}\n     */\n    save() {\n      return s.save();\n    },\n    /**\n     * Validate Block data\n     *\n     * @param {BlockToolData} data - data to validate\n     * @returns {Promise<boolean>}\n     */\n    validate(t) {\n      return s.validate(t);\n    },\n    /**\n     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n     * Can be useful for block changes invisible for editor core.\n     */\n    dispatchChange() {\n      s.dispatchChange();\n    }\n  });\n}\nclass Re {\n  constructor() {\n    this.allListeners = [];\n  }\n  /**\n   * Assigns event listener on element and returns unique identifier\n   *\n   * @param {EventTarget} element - DOM element that needs to be listened\n   * @param {string} eventType - event type\n   * @param {Function} handler - method that will be fired on event\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  on(e, t, o, i = !1) {\n    const n = Ut(\"l\"), r = {\n      id: n,\n      element: e,\n      eventType: t,\n      handler: o,\n      options: i\n    };\n    if (!this.findOne(e, t, o))\n      return this.allListeners.push(r), e.addEventListener(t, o, i), n;\n  }\n  /**\n   * Removes event listener from element\n   *\n   * @param {EventTarget} element - DOM element that we removing listener\n   * @param {string} eventType - event type\n   * @param {Function} handler - remove handler, if element listens several handlers on the same event type\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  off(e, t, o, i) {\n    const n = this.findAll(e, t, o);\n    n.forEach((r, a) => {\n      const l = this.allListeners.indexOf(n[a]);\n      l > -1 && (this.allListeners.splice(l, 1), r.element.removeEventListener(r.eventType, r.handler, r.options));\n    });\n  }\n  /**\n   * Removes listener by id\n   *\n   * @param {string} id - listener identifier\n   */\n  offById(e) {\n    const t = this.findById(e);\n    t && t.element.removeEventListener(t.eventType, t.handler, t.options);\n  }\n  /**\n   * Finds and returns first listener by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} [eventType] - event type\n   * @param {Function} [handler] - event handler\n   * @returns {ListenerData|null}\n   */\n  findOne(e, t, o) {\n    const i = this.findAll(e, t, o);\n    return i.length > 0 ? i[0] : null;\n  }\n  /**\n   * Return all stored listeners by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} eventType - event type\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]}\n   */\n  findAll(e, t, o) {\n    let i;\n    const n = e ? this.findByEventTarget(e) : [];\n    return e && t && o ? i = n.filter((r) => r.eventType === t && r.handler === o) : e && t ? i = n.filter((r) => r.eventType === t) : i = n, i;\n  }\n  /**\n   * Removes all listeners\n   */\n  removeAll() {\n    this.allListeners.map((e) => {\n      e.element.removeEventListener(e.eventType, e.handler, e.options);\n    }), this.allListeners = [];\n  }\n  /**\n   * Module cleanup on destruction\n   */\n  destroy() {\n    this.removeAll();\n  }\n  /**\n   * Search method: looks for listener by passed element\n   *\n   * @param {EventTarget} element - searching element\n   * @returns {Array} listeners that found on element\n   */\n  findByEventTarget(e) {\n    return this.allListeners.filter((t) => {\n      if (t.element === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed event type\n   *\n   * @param {string} eventType - event type\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByType(e) {\n    return this.allListeners.filter((t) => {\n      if (t.eventType === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed handler\n   *\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByHandler(e) {\n    return this.allListeners.filter((t) => {\n      if (t.handler === e)\n        return t;\n    });\n  }\n  /**\n   * Returns listener data found by id\n   *\n   * @param {string} id - listener identifier\n   * @returns {ListenerData}\n   */\n  findById(e) {\n    return this.allListeners.find((t) => t.id === e);\n  }\n}\nclass S {\n  /**\n   * @class\n   * @param options - Module options\n   * @param options.config - Module config\n   * @param options.eventsDispatcher - Common event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    if (this.nodes = {}, this.listeners = new Re(), this.readOnlyMutableListeners = {\n      /**\n       * Assigns event listener on DOM element and pushes into special array that might be removed\n       *\n       * @param {EventTarget} element - DOM Element\n       * @param {string} eventType - Event name\n       * @param {Function} handler - Event handler\n       * @param {boolean|AddEventListenerOptions} options - Listening options\n       */\n      on: (o, i, n, r = !1) => {\n        this.mutableListenerIds.push(\n          this.listeners.on(o, i, n, r)\n        );\n      },\n      /**\n       * Clears all mutable listeners\n       */\n      clearAll: () => {\n        for (const o of this.mutableListenerIds)\n          this.listeners.offById(o);\n        this.mutableListenerIds = [];\n      }\n    }, this.mutableListenerIds = [], new.target === S)\n      throw new TypeError(\"Constructors for abstract class Module are not allowed.\");\n    this.config = e, this.eventsDispatcher = t;\n  }\n  /**\n   * Editor modules setter\n   *\n   * @param {EditorModules} Editor - Editor's Modules\n   */\n  set state(e) {\n    this.Editor = e;\n  }\n  /**\n   * Remove memorized nodes\n   */\n  removeAllNodes() {\n    for (const e in this.nodes) {\n      const t = this.nodes[e];\n      t instanceof HTMLElement && t.remove();\n    }\n  }\n  /**\n   * Returns true if current direction is RTL (Right-To-Left)\n   */\n  get isRtl() {\n    return this.config.i18n.direction === \"rtl\";\n  }\n}\nclass m {\n  constructor() {\n    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = !1, this.commandBackground = \"backColor\", this.commandRemoveFormat = \"removeFormat\";\n  }\n  /**\n   * Editor styles\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  static get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorZone: \"codex-editor__redactor\"\n    };\n  }\n  /**\n   * Returns selected anchor\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}\n   *\n   * @returns {Node|null}\n   */\n  static get anchorNode() {\n    const e = window.getSelection();\n    return e ? e.anchorNode : null;\n  }\n  /**\n   * Returns selected anchor element\n   *\n   * @returns {Element|null}\n   */\n  static get anchorElement() {\n    const e = window.getSelection();\n    if (!e)\n      return null;\n    const t = e.anchorNode;\n    return t ? d.isElement(t) ? t : t.parentElement : null;\n  }\n  /**\n   * Returns selection offset according to the anchor node\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}\n   *\n   * @returns {number|null}\n   */\n  static get anchorOffset() {\n    const e = window.getSelection();\n    return e ? e.anchorOffset : null;\n  }\n  /**\n   * Is current selection range collapsed\n   *\n   * @returns {boolean|null}\n   */\n  static get isCollapsed() {\n    const e = window.getSelection();\n    return e ? e.isCollapsed : null;\n  }\n  /**\n   * Check current selection if it is at Editor's zone\n   *\n   * @returns {boolean}\n   */\n  static get isAtEditor() {\n    return this.isSelectionAtEditor(m.get());\n  }\n  /**\n   * Check if passed selection is at Editor's zone\n   *\n   * @param selection - Selection object to check\n   */\n  static isSelectionAtEditor(e) {\n    if (!e)\n      return !1;\n    let t = e.anchorNode || e.focusNode;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${m.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Check if passed range at Editor zone\n   *\n   * @param range - range to check\n   */\n  static isRangeAtEditor(e) {\n    if (!e)\n      return;\n    let t = e.startContainer;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${m.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Methods return boolean that true if selection exists on the page\n   */\n  static get isSelectionExists() {\n    return !!m.get().anchorNode;\n  }\n  /**\n   * Return first range\n   *\n   * @returns {Range|null}\n   */\n  static get range() {\n    return this.getRangeFromSelection(this.get());\n  }\n  /**\n   * Returns range from passed Selection object\n   *\n   * @param selection - Selection object to get Range from\n   */\n  static getRangeFromSelection(e) {\n    return e && e.rangeCount ? e.getRangeAt(0) : null;\n  }\n  /**\n   * Calculates position and size of selected text\n   *\n   * @returns {DOMRect | ClientRect}\n   */\n  static get rect() {\n    let e = document.selection, t, o = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    if (e && e.type !== \"Control\")\n      return e = e, t = e.createRange(), o.x = t.boundingLeft, o.y = t.boundingTop, o.width = t.boundingWidth, o.height = t.boundingHeight, o;\n    if (!window.getSelection)\n      return T(\"Method window.getSelection is not supported\", \"warn\"), o;\n    if (e = window.getSelection(), e.rangeCount === null || isNaN(e.rangeCount))\n      return T(\"Method SelectionUtils.rangeCount is not supported\", \"warn\"), o;\n    if (e.rangeCount === 0)\n      return o;\n    if (t = e.getRangeAt(0).cloneRange(), t.getBoundingClientRect && (o = t.getBoundingClientRect()), o.x === 0 && o.y === 0) {\n      const i = document.createElement(\"span\");\n      if (i.getBoundingClientRect) {\n        i.appendChild(document.createTextNode(\"​\")), t.insertNode(i), o = i.getBoundingClientRect();\n        const n = i.parentNode;\n        n.removeChild(i), n.normalize();\n      }\n    }\n    return o;\n  }\n  /**\n   * Returns selected text as String\n   *\n   * @returns {string}\n   */\n  static get text() {\n    return window.getSelection ? window.getSelection().toString() : \"\";\n  }\n  /**\n   * Returns window SelectionUtils\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}\n   *\n   * @returns {Selection}\n   */\n  static get() {\n    return window.getSelection();\n  }\n  /**\n   * Set focus to contenteditable or native input element\n   *\n   * @param element - element where to set focus\n   * @param offset - offset of cursor\n   */\n  static setCursor(e, t = 0) {\n    const o = document.createRange(), i = window.getSelection();\n    return d.isNativeInput(e) ? d.canSetCaret(e) ? (e.focus(), e.selectionStart = e.selectionEnd = t, e.getBoundingClientRect()) : void 0 : (o.setStart(e, t), o.setEnd(e, t), i.removeAllRanges(), i.addRange(o), o.getBoundingClientRect());\n  }\n  /**\n   * Check if current range exists and belongs to container\n   *\n   * @param container - where range should be\n   */\n  static isRangeInsideContainer(e) {\n    const t = m.range;\n    return t === null ? !1 : e.contains(t.startContainer);\n  }\n  /**\n   * Adds fake cursor to the current range\n   */\n  static addFakeCursor() {\n    const e = m.range;\n    if (e === null)\n      return;\n    const t = d.make(\"span\", \"codex-editor__fake-cursor\");\n    t.dataset.mutationFree = \"true\", e.collapse(), e.insertNode(t);\n  }\n  /**\n   * Check if passed element contains a fake cursor\n   *\n   * @param el - where to check\n   */\n  static isFakeCursorInsideContainer(e) {\n    return d.find(e, \".codex-editor__fake-cursor\") !== null;\n  }\n  /**\n   * Removes fake cursor from a container\n   *\n   * @param container - container to look for\n   */\n  static removeFakeCursor(e = document.body) {\n    const t = d.find(e, \".codex-editor__fake-cursor\");\n    t && t.remove();\n  }\n  /**\n   * Removes fake background\n   */\n  removeFakeBackground() {\n    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = !1, document.execCommand(this.commandRemoveFormat));\n  }\n  /**\n   * Sets fake background\n   */\n  setFakeBackground() {\n    document.execCommand(this.commandBackground, !1, \"#a8d6ff\"), this.isFakeBackgroundEnabled = !0;\n  }\n  /**\n   * Save SelectionUtils's range\n   */\n  save() {\n    this.savedSelectionRange = m.range;\n  }\n  /**\n   * Restore saved SelectionUtils's range\n   */\n  restore() {\n    if (!this.savedSelectionRange)\n      return;\n    const e = window.getSelection();\n    e.removeAllRanges(), e.addRange(this.savedSelectionRange);\n  }\n  /**\n   * Clears saved selection\n   */\n  clearSaved() {\n    this.savedSelectionRange = null;\n  }\n  /**\n   * Collapse current selection\n   */\n  collapseToEnd() {\n    const e = window.getSelection(), t = document.createRange();\n    t.selectNodeContents(e.focusNode), t.collapse(!1), e.removeAllRanges(), e.addRange(t);\n  }\n  /**\n   * Looks ahead to find passed tag from current selection\n   *\n   * @param  {string} tagName       - tag to found\n   * @param  {string} [className]   - tag's class name\n   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t, o = 10) {\n    const i = window.getSelection();\n    let n = null;\n    return !i || !i.anchorNode || !i.focusNode ? null : ([\n      /** the Node in which the selection begins */\n      i.anchorNode,\n      /** the Node in which the selection ends */\n      i.focusNode\n    ].forEach((a) => {\n      let l = o;\n      for (; l > 0 && a.parentNode && !(a.tagName === e && (n = a, t && a.classList && !a.classList.contains(t) && (n = null), n)); )\n        a = a.parentNode, l--;\n    }), n);\n  }\n  /**\n   * Expands selection range to the passed parent node\n   *\n   * @param {HTMLElement} element - element which contents should be selected\n   */\n  expandToTag(e) {\n    const t = window.getSelection();\n    t.removeAllRanges();\n    const o = document.createRange();\n    o.selectNodeContents(e), t.addRange(o);\n  }\n}\nfunction Vt(s, e) {\n  const { type: t, target: o, addedNodes: i, removedNodes: n } = s;\n  if (o === e)\n    return !0;\n  if ([\"characterData\", \"attributes\"].includes(t)) {\n    const l = o.nodeType === Node.TEXT_NODE ? o.parentNode : o;\n    return e.contains(l);\n  }\n  const r = Array.from(i).some((l) => e.contains(l)), a = Array.from(n).some((l) => e.contains(l));\n  return r || a;\n}\nconst Me = \"redactor dom changed\", lt = \"block changed\", ct = \"fake cursor is about to be toggled\", dt = \"fake cursor have been set\";\nvar q = /* @__PURE__ */ ((s) => (s.APPEND_CALLBACK = \"appendCallback\", s.RENDERED = \"rendered\", s.MOVED = \"moved\", s.UPDATED = \"updated\", s.REMOVED = \"removed\", s.ON_PASTE = \"onPaste\", s))(q || {});\nclass F extends we {\n  /**\n   * @param options - block constructor options\n   * @param [options.id] - block's id. Will be generated if omitted.\n   * @param options.data - Tool's initial data\n   * @param options.tool — block's tool\n   * @param options.api - Editor API module for pass it to the Block Tunes\n   * @param options.readOnly - Read-Only flag\n   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when \"virtual\" Block is created. See BlocksAPI@composeBlockData.\n   */\n  constructor({\n    id: e = zt(),\n    data: t,\n    tool: o,\n    api: i,\n    readOnly: n,\n    tunesData: r\n  }, a) {\n    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {\n      this.dropInputsCache(), this.updateCurrentInput();\n    }, this.didMutated = (l = void 0) => {\n      const c = l === void 0, u = l instanceof InputEvent;\n      !c && !u && this.detectToolRootChange(l);\n      let h;\n      c || u ? h = !0 : h = !(l.length > 0 && l.every((v) => {\n        const { addedNodes: p, removedNodes: k, target: _ } = v;\n        return [\n          ...Array.from(p),\n          ...Array.from(k),\n          _\n        ].some((A) => d.isElement(A) ? A.dataset.mutationFree === \"true\" : !1);\n      })), h && (this.dropInputsCache(), this.updateCurrentInput(), this.call(\n        \"updated\"\n        /* UPDATED */\n      ), this.emit(\"didMutated\", this));\n    }, this.name = o.name, this.id = e, this.settings = o.settings, this.config = o.settings.config || {}, this.api = i, this.editorEventBus = a || null, this.blockAPI = new he(this), this.tool = o, this.toolInstance = o.create(t, this.blockAPI, n), this.tunes = o.tunes, this.composeTunes(r), this.holder = this.compose(), this.watchBlockMutations(), this.addInputEvents();\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      wrapper: \"ce-block\",\n      wrapperStretched: \"ce-block--stretched\",\n      content: \"ce-block__content\",\n      focused: \"ce-block--focused\",\n      selected: \"ce-block--selected\",\n      dropTarget: \"ce-block--drop-target\"\n    };\n  }\n  /**\n   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML\n   *\n   * @returns {HTMLElement[]}\n   */\n  get inputs() {\n    if (this.cachedInputs.length !== 0)\n      return this.cachedInputs;\n    const e = d.findAllInputs(this.holder);\n    return this.inputIndex > e.length - 1 && (this.inputIndex = e.length - 1), this.cachedInputs = e, e;\n  }\n  /**\n   * Return current Tool`s input\n   *\n   * @returns {HTMLElement}\n   */\n  get currentInput() {\n    return this.inputs[this.inputIndex];\n  }\n  /**\n   * Set input index to the passed element\n   *\n   * @param {HTMLElement | Node} element - HTML Element to set as current input\n   */\n  set currentInput(e) {\n    const t = this.inputs.findIndex((o) => o === e || o.contains(e));\n    t !== -1 && (this.inputIndex = t);\n  }\n  /**\n   * Return first Tool`s input\n   *\n   * @returns {HTMLElement}\n   */\n  get firstInput() {\n    return this.inputs[0];\n  }\n  /**\n   * Return first Tool`s input\n   *\n   * @returns {HTMLElement}\n   */\n  get lastInput() {\n    const e = this.inputs;\n    return e[e.length - 1];\n  }\n  /**\n   * Return next Tool`s input or undefined if it doesn't exist\n   *\n   * @returns {HTMLElement}\n   */\n  get nextInput() {\n    return this.inputs[this.inputIndex + 1];\n  }\n  /**\n   * Return previous Tool`s input or undefined if it doesn't exist\n   *\n   * @returns {HTMLElement}\n   */\n  get previousInput() {\n    return this.inputs[this.inputIndex - 1];\n  }\n  /**\n   * Get Block's JSON data\n   *\n   * @returns {object}\n   */\n  get data() {\n    return this.save().then((e) => e && !V(e.data) ? e.data : {});\n  }\n  /**\n   * Returns tool's sanitizer config\n   *\n   * @returns {object}\n   */\n  get sanitize() {\n    return this.tool.sanitizeConfig;\n  }\n  /**\n   * is block mergeable\n   * We plugin have merge function then we call it mergeable\n   *\n   * @returns {boolean}\n   */\n  get mergeable() {\n    return D(this.toolInstance.merge);\n  }\n  /**\n   * Check block for emptiness\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    const e = d.isEmpty(this.pluginsContent), t = !this.hasMedia;\n    return e && t;\n  }\n  /**\n   * Check if block has a media content such as images, iframe and other\n   *\n   * @returns {boolean}\n   */\n  get hasMedia() {\n    const e = [\n      \"img\",\n      \"iframe\",\n      \"video\",\n      \"audio\",\n      \"source\",\n      \"input\",\n      \"textarea\",\n      \"twitterwidget\"\n    ];\n    return !!this.holder.querySelector(e.join(\",\"));\n  }\n  /**\n   * Set focused state\n   *\n   * @param {boolean} state - 'true' to select, 'false' to remove selection\n   */\n  set focused(e) {\n    this.holder.classList.toggle(F.CSS.focused, e);\n  }\n  /**\n   * Get Block's focused state\n   */\n  get focused() {\n    return this.holder.classList.contains(F.CSS.focused);\n  }\n  /**\n   * Set selected state\n   * We don't need to mark Block as Selected when it is empty\n   *\n   * @param {boolean} state - 'true' to select, 'false' to remove selection\n   */\n  set selected(e) {\n    var i, n;\n    this.holder.classList.toggle(F.CSS.selected, e);\n    const t = e === !0 && m.isRangeInsideContainer(this.holder), o = e === !1 && m.isFakeCursorInsideContainer(this.holder);\n    (t || o) && ((i = this.editorEventBus) == null || i.emit(ct, { state: e }), t ? m.addFakeCursor() : m.removeFakeCursor(this.holder), (n = this.editorEventBus) == null || n.emit(dt, { state: e }));\n  }\n  /**\n   * Returns True if it is Selected\n   *\n   * @returns {boolean}\n   */\n  get selected() {\n    return this.holder.classList.contains(F.CSS.selected);\n  }\n  /**\n   * Set stretched state\n   *\n   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state\n   */\n  set stretched(e) {\n    this.holder.classList.toggle(F.CSS.wrapperStretched, e);\n  }\n  /**\n   * Return Block's stretched state\n   *\n   * @returns {boolean}\n   */\n  get stretched() {\n    return this.holder.classList.contains(F.CSS.wrapperStretched);\n  }\n  /**\n   * Toggle drop target state\n   *\n   * @param {boolean} state - 'true' if block is drop target, false otherwise\n   */\n  set dropTarget(e) {\n    this.holder.classList.toggle(F.CSS.dropTarget, e);\n  }\n  /**\n   * Returns Plugins content\n   *\n   * @returns {HTMLElement}\n   */\n  get pluginsContent() {\n    return this.toolRenderedElement;\n  }\n  /**\n   * Calls Tool's method\n   *\n   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function\n   *\n   * @param {string} methodName - method to call\n   * @param {object} params - method argument\n   */\n  call(e, t) {\n    if (D(this.toolInstance[e])) {\n      e === \"appendCallback\" && T(\n        \"`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead\",\n        \"warn\"\n      );\n      try {\n        this.toolInstance[e].call(this.toolInstance, t);\n      } catch (o) {\n        T(`Error during '${e}' call: ${o.message}`, \"error\");\n      }\n    }\n  }\n  /**\n   * Call plugins merge method\n   *\n   * @param {BlockToolData} data - data to merge\n   */\n  async mergeWith(e) {\n    await this.toolInstance.merge(e);\n  }\n  /**\n   * Extracts data from Block\n   * Groups Tool's save processing time\n   *\n   * @returns {object}\n   */\n  async save() {\n    const e = await this.toolInstance.save(this.pluginsContent), t = this.unavailableTunesData;\n    [\n      ...this.tunesInstances.entries(),\n      ...this.defaultTunesInstances.entries()\n    ].forEach(([n, r]) => {\n      if (D(r.save))\n        try {\n          t[n] = r.save();\n        } catch (a) {\n          T(`Tune ${r.constructor.name} save method throws an Error %o`, \"warn\", a);\n        }\n    });\n    const o = window.performance.now();\n    let i;\n    return Promise.resolve(e).then((n) => (i = window.performance.now(), {\n      id: this.id,\n      tool: this.name,\n      data: n,\n      tunes: t,\n      time: i - o\n    })).catch((n) => {\n      T(`Saving process for ${this.name} tool failed due to the ${n}`, \"log\", \"red\");\n    });\n  }\n  /**\n   * Uses Tool's validation method to check the correctness of output data\n   * Tool's validation method is optional\n   *\n   * @description Method returns true|false whether data passed the validation or not\n   * @param {BlockToolData} data - data to validate\n   * @returns {Promise<boolean>} valid\n   */\n  async validate(e) {\n    let t = !0;\n    return this.toolInstance.validate instanceof Function && (t = await this.toolInstance.validate(e)), t;\n  }\n  /**\n   * Returns data to render in tunes menu.\n   * Splits block tunes settings into 2 groups: popover items and custom html.\n   */\n  getTunes() {\n    const e = document.createElement(\"div\"), t = [], o = typeof this.toolInstance.renderSettings == \"function\" ? this.toolInstance.renderSettings() : [], i = [\n      ...this.tunesInstances.values(),\n      ...this.defaultTunesInstances.values()\n    ].map((n) => n.render());\n    return [o, i].flat().forEach((n) => {\n      d.isElement(n) ? e.appendChild(n) : Array.isArray(n) ? t.push(...n) : t.push(n);\n    }), [t, e];\n  }\n  /**\n   * Update current input index with selection anchor node\n   */\n  updateCurrentInput() {\n    this.currentInput = d.isNativeInput(document.activeElement) || !m.anchorNode ? document.activeElement : m.anchorNode;\n  }\n  /**\n   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n   * Can be useful for block changes invisible for editor core.\n   */\n  dispatchChange() {\n    this.didMutated();\n  }\n  /**\n   * Call Tool instance destroy method\n   */\n  destroy() {\n    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), D(this.toolInstance.destroy) && this.toolInstance.destroy();\n  }\n  /**\n   * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n   * This method returns the entry that is related to the Block (depended on the Block data)\n   */\n  async getActiveToolboxEntry() {\n    const e = this.tool.toolbox;\n    if (e.length === 1)\n      return Promise.resolve(this.tool.toolbox[0]);\n    const t = await this.data;\n    return e.find((i) => Object.entries(i.data).some(([n, r]) => t[n] && $t(t[n], r)));\n  }\n  /**\n   * Make default Block wrappers and put Tool`s content there\n   *\n   * @returns {HTMLDivElement}\n   */\n  compose() {\n    const e = d.make(\"div\", F.CSS.wrapper), t = d.make(\"div\", F.CSS.content), o = this.toolInstance.render();\n    this.toolRenderedElement = o, t.appendChild(this.toolRenderedElement);\n    let i = t;\n    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((n) => {\n      if (D(n.wrap))\n        try {\n          i = n.wrap(i);\n        } catch (r) {\n          T(`Tune ${n.constructor.name} wrap method throws an Error %o`, \"warn\", r);\n        }\n    }), e.appendChild(i), e;\n  }\n  /**\n   * Instantiate Block Tunes\n   *\n   * @param tunesData - current Block tunes data\n   * @private\n   */\n  composeTunes(e) {\n    Array.from(this.tunes.values()).forEach((t) => {\n      (t.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t.name, t.create(e[t.name], this.blockAPI));\n    }), Object.entries(e).forEach(([t, o]) => {\n      this.tunesInstances.has(t) || (this.unavailableTunesData[t] = o);\n    });\n  }\n  /**\n   * Adds focus event listeners to all inputs and contenteditable\n   */\n  addInputEvents() {\n    this.inputs.forEach((e) => {\n      e.addEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.addEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * removes focus event listeners from all inputs and contenteditable\n   */\n  removeInputEvents() {\n    this.inputs.forEach((e) => {\n      e.removeEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.removeEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * Listen common editor Dom Changed event and detect mutations related to the  Block\n   */\n  watchBlockMutations() {\n    var e;\n    this.redactorDomChangedCallback = (t) => {\n      const { mutations: o } = t;\n      o.some((n) => Vt(n, this.toolRenderedElement)) && this.didMutated(o);\n    }, (e = this.editorEventBus) == null || e.on(Me, this.redactorDomChangedCallback);\n  }\n  /**\n   * Remove redactor dom change event listener\n   */\n  unwatchBlockMutations() {\n    var e;\n    (e = this.editorEventBus) == null || e.off(Me, this.redactorDomChangedCallback);\n  }\n  /**\n   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL\n   * We need to detect such changes and update a link to tools main element with the new one\n   *\n   * @param mutations - records of block content mutations\n   */\n  detectToolRootChange(e) {\n    e.forEach((t) => {\n      if (Array.from(t.removedNodes).includes(this.toolRenderedElement)) {\n        const i = t.addedNodes[t.addedNodes.length - 1];\n        this.toolRenderedElement = i;\n      }\n    });\n  }\n  /**\n   * Clears inputs cached value\n   */\n  dropInputsCache() {\n    this.cachedInputs = [];\n  }\n}\nclass Zt extends S {\n  constructor() {\n    super(...arguments), this.insert = (e = this.config.defaultBlock, t = {}, o = {}, i, n, r, a) => {\n      const l = this.Editor.BlockManager.insert({\n        id: a,\n        tool: e,\n        data: t,\n        index: i,\n        needToFocus: n,\n        replace: r\n      });\n      return new he(l);\n    }, this.composeBlockData = async (e) => {\n      const t = this.Editor.Tools.blockTools.get(e);\n      return new F({\n        tool: t,\n        api: this.Editor.API,\n        readOnly: !0,\n        data: {},\n        tunesData: {}\n      }).data;\n    }, this.update = (e, t) => {\n      const { BlockManager: o } = this.Editor, i = o.getBlockById(e);\n      if (!i) {\n        T(\"blocks.update(): Block with passed id was not found\", \"warn\");\n        return;\n      }\n      const n = o.getBlockIndex(i);\n      o.insert({\n        id: i.id,\n        tool: i.name,\n        data: t,\n        index: n,\n        replace: !0,\n        tunes: i.tunes\n      });\n    };\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Blocks}\n   */\n  get methods() {\n    return {\n      clear: () => this.clear(),\n      render: (e) => this.render(e),\n      renderFromHTML: (e) => this.renderFromHTML(e),\n      delete: (e) => this.delete(e),\n      swap: (e, t) => this.swap(e, t),\n      move: (e, t) => this.move(e, t),\n      getBlockByIndex: (e) => this.getBlockByIndex(e),\n      getById: (e) => this.getById(e),\n      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),\n      getBlockIndex: (e) => this.getBlockIndex(e),\n      getBlocksCount: () => this.getBlocksCount(),\n      stretchBlock: (e, t = !0) => this.stretchBlock(e, t),\n      insertNewBlock: () => this.insertNewBlock(),\n      insert: this.insert,\n      update: this.update,\n      composeBlockData: this.composeBlockData\n    };\n  }\n  /**\n   * Returns Blocks count\n   *\n   * @returns {number}\n   */\n  getBlocksCount() {\n    return this.Editor.BlockManager.blocks.length;\n  }\n  /**\n   * Returns current block index\n   *\n   * @returns {number}\n   */\n  getCurrentBlockIndex() {\n    return this.Editor.BlockManager.currentBlockIndex;\n  }\n  /**\n   * Returns the index of Block by id;\n   *\n   * @param id - block id\n   */\n  getBlockIndex(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    if (!t) {\n      K(\"There is no block with id `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return this.Editor.BlockManager.getBlockIndex(t);\n  }\n  /**\n   * Returns BlockAPI object by Block index\n   *\n   * @param {number} index - index to get\n   */\n  getBlockByIndex(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(e);\n    if (t === void 0) {\n      K(\"There is no block at index `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new he(t);\n  }\n  /**\n   * Returns BlockAPI object by Block id\n   *\n   * @param id - id of block to get\n   */\n  getById(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    return t === void 0 ? (K(\"There is no block with id `\" + e + \"`\", \"warn\"), null) : new he(t);\n  }\n  /**\n   * Call Block Manager method that swap Blocks\n   *\n   * @param {number} fromIndex - position of first Block\n   * @param {number} toIndex - position of second Block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    T(\n      \"`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead\",\n      \"info\"\n    ), this.Editor.BlockManager.swap(e, t);\n  }\n  /**\n   * Move block from one index to another\n   *\n   * @param {number} toIndex - index to move to\n   * @param {number} fromIndex - index to move from\n   */\n  move(e, t) {\n    this.Editor.BlockManager.move(e, t);\n  }\n  /**\n   * Deletes Block\n   *\n   * @param {number} blockIndex - index of Block to delete\n   */\n  delete(e) {\n    try {\n      this.Editor.BlockManager.removeBlock(e);\n    } catch (t) {\n      K(t, \"warn\");\n      return;\n    }\n    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();\n  }\n  /**\n   * Clear Editor's area\n   */\n  clear() {\n    this.Editor.BlockManager.clear(!0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Fills Editor with Blocks data\n   *\n   * @param {OutputData} data — Saved Editor data\n   */\n  render(e) {\n    return this.Editor.BlockManager.clear(), this.Editor.Renderer.render(e.blocks);\n  }\n  /**\n   * Render passed HTML string\n   *\n   * @param {string} data - HTML string to render\n   * @returns {Promise<void>}\n   */\n  renderFromHTML(e) {\n    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e, !0);\n  }\n  /**\n   * Stretch Block's content\n   *\n   * @param {number} index - index of Block to stretch\n   * @param {boolean} status - true to enable, false to disable\n   * @deprecated Use BlockAPI interface to stretch Blocks\n   */\n  stretchBlock(e, t = !0) {\n    Ie(\n      !0,\n      \"blocks.stretchBlock()\",\n      \"BlockAPI\"\n    );\n    const o = this.Editor.BlockManager.getBlockByIndex(e);\n    o && (o.stretched = t);\n  }\n  /**\n   * Insert new Block\n   * After set caret to this Block\n   *\n   * @todo remove in 3.0.0\n   * @deprecated with insert() method\n   */\n  insertNewBlock() {\n    T(\"Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.\", \"warn\"), this.insert();\n  }\n}\nclass Gt extends S {\n  constructor() {\n    super(...arguments), this.setToFirstBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e, t), !0) : !1, this.setToLastBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e, t), !0) : !1, this.setToPreviousBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e, t), !0) : !1, this.setToNextBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e, t), !0) : !1, this.setToBlock = (e, t = this.Editor.Caret.positions.DEFAULT, o = 0) => this.Editor.BlockManager.blocks[e] ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.blocks[e], t, o), !0) : !1, this.focus = (e = !1) => e ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Caret}\n   */\n  get methods() {\n    return {\n      setToFirstBlock: this.setToFirstBlock,\n      setToLastBlock: this.setToLastBlock,\n      setToPreviousBlock: this.setToPreviousBlock,\n      setToNextBlock: this.setToNextBlock,\n      setToBlock: this.setToBlock,\n      focus: this.focus\n    };\n  }\n}\nclass qt extends S {\n  /**\n   * Available methods\n   *\n   * @returns {Events}\n   */\n  get methods() {\n    return {\n      emit: (e, t) => this.emit(e, t),\n      off: (e, t) => this.off(e, t),\n      on: (e, t) => this.on(e, t)\n    };\n  }\n  /**\n   * Subscribe on Events\n   *\n   * @param {string} eventName - event name to subscribe\n   * @param {Function} callback - event handler\n   */\n  on(e, t) {\n    this.eventsDispatcher.on(e, t);\n  }\n  /**\n   * Emit event with data\n   *\n   * @param {string} eventName - event to emit\n   * @param {object} data - event's data\n   */\n  emit(e, t) {\n    this.eventsDispatcher.emit(e, t);\n  }\n  /**\n   * Unsubscribe from Event\n   *\n   * @param {string} eventName - event to unsubscribe\n   * @param {Function} callback - event handler\n   */\n  off(e, t) {\n    this.eventsDispatcher.off(e, t);\n  }\n}\nclass De extends S {\n  /**\n   * Return namespace section for tool or block tune\n   *\n   * @param tool - tool object\n   */\n  static getNamespace(e) {\n    return e.isTune() ? `blockTunes.${e.name}` : `tools.${e.name}`;\n  }\n  /**\n   * Return I18n API methods with global dictionary access\n   */\n  get methods() {\n    return {\n      t: () => {\n        K(\"I18n.t() method can be accessed only from Tools\", \"warn\");\n      }\n    };\n  }\n  /**\n   * Return I18n API methods with tool namespaced dictionary\n   *\n   * @param tool - Tool object\n   */\n  getMethodsForTool(e) {\n    return Object.assign(\n      this.methods,\n      {\n        t: (t) => $.t(De.getNamespace(e), t)\n      }\n    );\n  }\n}\nclass Jt extends S {\n  /**\n   * Editor.js Core API modules\n   */\n  get methods() {\n    return {\n      blocks: this.Editor.BlocksAPI.methods,\n      caret: this.Editor.CaretAPI.methods,\n      events: this.Editor.EventsAPI.methods,\n      listeners: this.Editor.ListenersAPI.methods,\n      notifier: this.Editor.NotifierAPI.methods,\n      sanitizer: this.Editor.SanitizerAPI.methods,\n      saver: this.Editor.SaverAPI.methods,\n      selection: this.Editor.SelectionAPI.methods,\n      styles: this.Editor.StylesAPI.classes,\n      toolbar: this.Editor.ToolbarAPI.methods,\n      inlineToolbar: this.Editor.InlineToolbarAPI.methods,\n      tooltip: this.Editor.TooltipAPI.methods,\n      i18n: this.Editor.I18nAPI.methods,\n      readOnly: this.Editor.ReadOnlyAPI.methods,\n      ui: this.Editor.UiAPI.methods\n    };\n  }\n  /**\n   * Returns Editor.js Core API methods for passed tool\n   *\n   * @param tool - tool object\n   */\n  getMethodsForTool(e) {\n    return Object.assign(\n      this.methods,\n      {\n        i18n: this.Editor.I18nAPI.getMethodsForTool(e)\n      }\n    );\n  }\n}\nclass Qt extends S {\n  /**\n   * Available methods\n   *\n   * @returns {InlineToolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open()\n    };\n  }\n  /**\n   * Open Inline Toolbar\n   */\n  open() {\n    this.Editor.InlineToolbar.tryToShow();\n  }\n  /**\n   * Close Inline Toolbar\n   */\n  close() {\n    this.Editor.InlineToolbar.close();\n  }\n}\nclass eo extends S {\n  /**\n   * Available methods\n   *\n   * @returns {Listeners}\n   */\n  get methods() {\n    return {\n      on: (e, t, o, i) => this.on(e, t, o, i),\n      off: (e, t, o, i) => this.off(e, t, o, i),\n      offById: (e) => this.offById(e)\n    };\n  }\n  /**\n   * Ads a DOM event listener. Return it's id.\n   *\n   * @param {HTMLElement} element - Element to set handler to\n   * @param {string} eventType - event type\n   * @param {() => void} handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  on(e, t, o, i) {\n    return this.listeners.on(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener from element\n   *\n   * @param {Element} element - Element to remove handler from\n   * @param eventType - event type\n   * @param handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  off(e, t, o, i) {\n    this.listeners.off(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener by the listener id\n   *\n   * @param id - id of the listener to remove\n   */\n  offById(e) {\n    this.listeners.offById(e);\n  }\n}\nvar Le = {}, to = {\n  get exports() {\n    return Le;\n  },\n  set exports(s) {\n    Le = s;\n  }\n};\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(n) {\n        if (o[n])\n          return o[n].exports;\n        var r = o[n] = { i: n, l: !1, exports: {} };\n        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(n, r, a) {\n        i.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: a });\n      }, i.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, i.t = function(n, r) {\n        if (1 & r && (n = i(n)), 8 & r || 4 & r && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: n }), 2 & r && typeof n != \"string\")\n          for (var l in n)\n            i.d(a, l, function(c) {\n              return n[c];\n            }.bind(null, l));\n        return a;\n      }, i.n = function(n) {\n        var r = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(n, r) {\n        return Object.prototype.hasOwnProperty.call(n, r);\n      }, i.p = \"/\", i(i.s = 0);\n    }([function(t, o, i) {\n      i(1), /*!\n       * Codex JavaScript Notification module\n       * https://github.com/codex-team/js-notifier\n       */\n      t.exports = function() {\n        var n = i(6), r = \"cdx-notify--bounce-in\", a = null;\n        return { show: function(l) {\n          if (l.message) {\n            (function() {\n              if (a)\n                return !0;\n              a = n.getWrapper(), document.body.appendChild(a);\n            })();\n            var c = null, u = l.time || 8e3;\n            switch (l.type) {\n              case \"confirm\":\n                c = n.confirm(l);\n                break;\n              case \"prompt\":\n                c = n.prompt(l);\n                break;\n              default:\n                c = n.alert(l), window.setTimeout(function() {\n                  c.remove();\n                }, u);\n            }\n            a.appendChild(c), c.classList.add(r);\n          }\n        } };\n      }();\n    }, function(t, o, i) {\n      var n = i(2);\n      typeof n == \"string\" && (n = [[t.i, n, \"\"]]);\n      var r = { hmr: !0, transform: void 0, insertInto: void 0 };\n      i(4)(n, r), n.locals && (t.exports = n.locals);\n    }, function(t, o, i) {\n      (t.exports = i(3)(!1)).push([t.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Fira Sans\",\"Droid Sans\",\"Helvetica Neue\",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, \"\"]);\n    }, function(t, o) {\n      t.exports = function(i) {\n        var n = [];\n        return n.toString = function() {\n          return this.map(function(r) {\n            var a = function(l, c) {\n              var u = l[1] || \"\", h = l[3];\n              if (!h)\n                return u;\n              if (c && typeof btoa == \"function\") {\n                var f = (p = h, \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(p)))) + \" */\"), v = h.sources.map(function(k) {\n                  return \"/*# sourceURL=\" + h.sourceRoot + k + \" */\";\n                });\n                return [u].concat(v).concat([f]).join(`\n`);\n              }\n              var p;\n              return [u].join(`\n`);\n            }(r, i);\n            return r[2] ? \"@media \" + r[2] + \"{\" + a + \"}\" : a;\n          }).join(\"\");\n        }, n.i = function(r, a) {\n          typeof r == \"string\" && (r = [[null, r, \"\"]]);\n          for (var l = {}, c = 0; c < this.length; c++) {\n            var u = this[c][0];\n            typeof u == \"number\" && (l[u] = !0);\n          }\n          for (c = 0; c < r.length; c++) {\n            var h = r[c];\n            typeof h[0] == \"number\" && l[h[0]] || (a && !h[2] ? h[2] = a : a && (h[2] = \"(\" + h[2] + \") and (\" + a + \")\"), n.push(h));\n          }\n        }, n;\n      };\n    }, function(t, o, i) {\n      var n, r, a = {}, l = (n = function() {\n        return window && document && document.all && !window.atob;\n      }, function() {\n        return r === void 0 && (r = n.apply(this, arguments)), r;\n      }), c = function(b) {\n        var g = {};\n        return function(E) {\n          if (typeof E == \"function\")\n            return E();\n          if (g[E] === void 0) {\n            var C = function(O) {\n              return document.querySelector(O);\n            }.call(this, E);\n            if (window.HTMLIFrameElement && C instanceof window.HTMLIFrameElement)\n              try {\n                C = C.contentDocument.head;\n              } catch {\n                C = null;\n              }\n            g[E] = C;\n          }\n          return g[E];\n        };\n      }(), u = null, h = 0, f = [], v = i(5);\n      function p(b, g) {\n        for (var E = 0; E < b.length; E++) {\n          var C = b[E], O = a[C.id];\n          if (O) {\n            O.refs++;\n            for (var I = 0; I < O.parts.length; I++)\n              O.parts[I](C.parts[I]);\n            for (; I < C.parts.length; I++)\n              O.parts.push(x(C.parts[I], g));\n          } else {\n            var H = [];\n            for (I = 0; I < C.parts.length; I++)\n              H.push(x(C.parts[I], g));\n            a[C.id] = { id: C.id, refs: 1, parts: H };\n          }\n        }\n      }\n      function k(b, g) {\n        for (var E = [], C = {}, O = 0; O < b.length; O++) {\n          var I = b[O], H = g.base ? I[0] + g.base : I[0], L = { css: I[1], media: I[2], sourceMap: I[3] };\n          C[H] ? C[H].parts.push(L) : E.push(C[H] = { id: H, parts: [L] });\n        }\n        return E;\n      }\n      function _(b, g) {\n        var E = c(b.insertInto);\n        if (!E)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n        var C = f[f.length - 1];\n        if (b.insertAt === \"top\")\n          C ? C.nextSibling ? E.insertBefore(g, C.nextSibling) : E.appendChild(g) : E.insertBefore(g, E.firstChild), f.push(g);\n        else if (b.insertAt === \"bottom\")\n          E.appendChild(g);\n        else {\n          if (typeof b.insertAt != \"object\" || !b.insertAt.before)\n            throw new Error(`[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n`);\n          var O = c(b.insertInto + \" \" + b.insertAt.before);\n          E.insertBefore(g, O);\n        }\n      }\n      function N(b) {\n        if (b.parentNode === null)\n          return !1;\n        b.parentNode.removeChild(b);\n        var g = f.indexOf(b);\n        g >= 0 && f.splice(g, 1);\n      }\n      function A(b) {\n        var g = document.createElement(\"style\");\n        return b.attrs.type === void 0 && (b.attrs.type = \"text/css\"), y(g, b.attrs), _(b, g), g;\n      }\n      function y(b, g) {\n        Object.keys(g).forEach(function(E) {\n          b.setAttribute(E, g[E]);\n        });\n      }\n      function x(b, g) {\n        var E, C, O, I;\n        if (g.transform && b.css) {\n          if (!(I = g.transform(b.css)))\n            return function() {\n            };\n          b.css = I;\n        }\n        if (g.singleton) {\n          var H = h++;\n          E = u || (u = A(g)), C = R.bind(null, E, H, !1), O = R.bind(null, E, H, !0);\n        } else\n          b.sourceMap && typeof URL == \"function\" && typeof URL.createObjectURL == \"function\" && typeof URL.revokeObjectURL == \"function\" && typeof Blob == \"function\" && typeof btoa == \"function\" ? (E = function(L) {\n            var W = document.createElement(\"link\");\n            return L.attrs.type === void 0 && (L.attrs.type = \"text/css\"), L.attrs.rel = \"stylesheet\", y(W, L.attrs), _(L, W), W;\n          }(g), C = function(L, W, le) {\n            var Q = le.css, Ee = le.sourceMap, It = W.convertToAbsoluteUrls === void 0 && Ee;\n            (W.convertToAbsoluteUrls || It) && (Q = v(Q)), Ee && (Q += `\n/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(Ee)))) + \" */\");\n            var Mt = new Blob([Q], { type: \"text/css\" }), Xe = L.href;\n            L.href = URL.createObjectURL(Mt), Xe && URL.revokeObjectURL(Xe);\n          }.bind(null, E, g), O = function() {\n            N(E), E.href && URL.revokeObjectURL(E.href);\n          }) : (E = A(g), C = function(L, W) {\n            var le = W.css, Q = W.media;\n            if (Q && L.setAttribute(\"media\", Q), L.styleSheet)\n              L.styleSheet.cssText = le;\n            else {\n              for (; L.firstChild; )\n                L.removeChild(L.firstChild);\n              L.appendChild(document.createTextNode(le));\n            }\n          }.bind(null, E), O = function() {\n            N(E);\n          });\n        return C(b), function(L) {\n          if (L) {\n            if (L.css === b.css && L.media === b.media && L.sourceMap === b.sourceMap)\n              return;\n            C(b = L);\n          } else\n            O();\n        };\n      }\n      t.exports = function(b, g) {\n        if (typeof DEBUG < \"u\" && DEBUG && typeof document != \"object\")\n          throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n        (g = g || {}).attrs = typeof g.attrs == \"object\" ? g.attrs : {}, g.singleton || typeof g.singleton == \"boolean\" || (g.singleton = l()), g.insertInto || (g.insertInto = \"head\"), g.insertAt || (g.insertAt = \"bottom\");\n        var E = k(b, g);\n        return p(E, g), function(C) {\n          for (var O = [], I = 0; I < E.length; I++) {\n            var H = E[I];\n            (L = a[H.id]).refs--, O.push(L);\n          }\n          for (C && p(k(C, g), g), I = 0; I < O.length; I++) {\n            var L;\n            if ((L = O[I]).refs === 0) {\n              for (var W = 0; W < L.parts.length; W++)\n                L.parts[W]();\n              delete a[L.id];\n            }\n          }\n        };\n      };\n      var w, M = (w = [], function(b, g) {\n        return w[b] = g, w.filter(Boolean).join(`\n`);\n      });\n      function R(b, g, E, C) {\n        var O = E ? \"\" : C.css;\n        if (b.styleSheet)\n          b.styleSheet.cssText = M(g, O);\n        else {\n          var I = document.createTextNode(O), H = b.childNodes;\n          H[g] && b.removeChild(H[g]), H.length ? b.insertBefore(I, H[g]) : b.appendChild(I);\n        }\n      }\n    }, function(t, o) {\n      t.exports = function(i) {\n        var n = typeof window < \"u\" && window.location;\n        if (!n)\n          throw new Error(\"fixUrls requires window.location\");\n        if (!i || typeof i != \"string\")\n          return i;\n        var r = n.protocol + \"//\" + n.host, a = r + n.pathname.replace(/\\/[^\\/]*$/, \"/\");\n        return i.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(l, c) {\n          var u, h = c.trim().replace(/^\"(.*)\"$/, function(f, v) {\n            return v;\n          }).replace(/^'(.*)'$/, function(f, v) {\n            return v;\n          });\n          return /^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(h) ? l : (u = h.indexOf(\"//\") === 0 ? h : h.indexOf(\"/\") === 0 ? r + h : a + h.replace(/^\\.\\//, \"\"), \"url(\" + JSON.stringify(u) + \")\");\n        });\n      };\n    }, function(t, o, i) {\n      var n, r, a, l, c, u, h, f, v;\n      t.exports = (n = \"cdx-notifies\", r = \"cdx-notify\", a = \"cdx-notify__cross\", l = \"cdx-notify__button--confirm\", c = \"cdx-notify__button--cancel\", u = \"cdx-notify__input\", h = \"cdx-notify__button\", f = \"cdx-notify__btns-wrapper\", { alert: v = function(p) {\n        var k = document.createElement(\"DIV\"), _ = document.createElement(\"DIV\"), N = p.message, A = p.style;\n        return k.classList.add(r), A && k.classList.add(r + \"--\" + A), k.innerHTML = N, _.classList.add(a), _.addEventListener(\"click\", k.remove.bind(k)), k.appendChild(_), k;\n      }, confirm: function(p) {\n        var k = v(p), _ = document.createElement(\"div\"), N = document.createElement(\"button\"), A = document.createElement(\"button\"), y = k.querySelector(\".\" + a), x = p.cancelHandler, w = p.okHandler;\n        return _.classList.add(f), N.innerHTML = p.okText || \"Confirm\", A.innerHTML = p.cancelText || \"Cancel\", N.classList.add(h), A.classList.add(h), N.classList.add(l), A.classList.add(c), x && typeof x == \"function\" && (A.addEventListener(\"click\", x), y.addEventListener(\"click\", x)), w && typeof w == \"function\" && N.addEventListener(\"click\", w), N.addEventListener(\"click\", k.remove.bind(k)), A.addEventListener(\"click\", k.remove.bind(k)), _.appendChild(N), _.appendChild(A), k.appendChild(_), k;\n      }, prompt: function(p) {\n        var k = v(p), _ = document.createElement(\"div\"), N = document.createElement(\"button\"), A = document.createElement(\"input\"), y = k.querySelector(\".\" + a), x = p.cancelHandler, w = p.okHandler;\n        return _.classList.add(f), N.innerHTML = p.okText || \"Ok\", N.classList.add(h), N.classList.add(l), A.classList.add(u), p.placeholder && A.setAttribute(\"placeholder\", p.placeholder), p.default && (A.value = p.default), p.inputType && (A.type = p.inputType), x && typeof x == \"function\" && y.addEventListener(\"click\", x), w && typeof w == \"function\" && N.addEventListener(\"click\", function() {\n          w(A.value);\n        }), N.addEventListener(\"click\", k.remove.bind(k)), _.appendChild(A), _.appendChild(N), k.appendChild(_), k;\n      }, getWrapper: function() {\n        var p = document.createElement(\"DIV\");\n        return p.classList.add(n), p;\n      } });\n    }]);\n  });\n})(to);\nconst oo = /* @__PURE__ */ xe(Le);\nclass io {\n  /**\n   * Show web notification\n   *\n   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options\n   */\n  show(e) {\n    oo.show(e);\n  }\n}\nclass no extends S {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.notifier = new io();\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e) => this.show(e)\n    };\n  }\n  /**\n   * Show notification\n   *\n   * @param {NotifierOptions} options - message option\n   */\n  show(e) {\n    return this.notifier.show(e);\n  }\n}\nclass so extends S {\n  /**\n   * Available methods\n   */\n  get methods() {\n    const e = () => this.isEnabled;\n    return {\n      toggle: (t) => this.toggle(t),\n      get isEnabled() {\n        return e();\n      }\n    };\n  }\n  /**\n   * Set or toggle read-only state\n   *\n   * @param {boolean|undefined} state - set or toggle state\n   * @returns {boolean} current value\n   */\n  toggle(e) {\n    return this.Editor.ReadOnly.toggle(e);\n  }\n  /**\n   * Returns current read-only state\n   */\n  get isEnabled() {\n    return this.Editor.ReadOnly.isEnabled;\n  }\n}\nvar Oe = {}, ro = {\n  get exports() {\n    return Oe;\n  },\n  set exports(s) {\n    Oe = s;\n  }\n};\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(Lt, function() {\n    function t(h) {\n      var f = h.tags, v = Object.keys(f), p = v.map(function(k) {\n        return typeof f[k];\n      }).every(function(k) {\n        return k === \"object\" || k === \"boolean\" || k === \"function\";\n      });\n      if (!p)\n        throw new Error(\"The configuration was invalid\");\n      this.config = h;\n    }\n    var o = [\"P\", \"LI\", \"TD\", \"TH\", \"DIV\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"PRE\"];\n    function i(h) {\n      return o.indexOf(h.nodeName) !== -1;\n    }\n    var n = [\"A\", \"B\", \"STRONG\", \"I\", \"EM\", \"SUB\", \"SUP\", \"U\", \"STRIKE\"];\n    function r(h) {\n      return n.indexOf(h.nodeName) !== -1;\n    }\n    t.prototype.clean = function(h) {\n      const f = document.implementation.createHTMLDocument(), v = f.createElement(\"div\");\n      return v.innerHTML = h, this._sanitize(f, v), v.innerHTML;\n    }, t.prototype._sanitize = function(h, f) {\n      var v = a(h, f), p = v.firstChild();\n      if (p)\n        do {\n          if (p.nodeType === Node.TEXT_NODE)\n            if (p.data.trim() === \"\" && (p.previousElementSibling && i(p.previousElementSibling) || p.nextElementSibling && i(p.nextElementSibling))) {\n              f.removeChild(p), this._sanitize(h, f);\n              break;\n            } else\n              continue;\n          if (p.nodeType === Node.COMMENT_NODE) {\n            f.removeChild(p), this._sanitize(h, f);\n            break;\n          }\n          var k = r(p), _;\n          k && (_ = Array.prototype.some.call(p.childNodes, i));\n          var N = !!f.parentNode, A = i(f) && i(p) && N, y = p.nodeName.toLowerCase(), x = l(this.config, y, p), w = k && _;\n          if (w || c(p, x) || !this.config.keepNestedBlockElements && A) {\n            if (!(p.nodeName === \"SCRIPT\" || p.nodeName === \"STYLE\"))\n              for (; p.childNodes.length > 0; )\n                f.insertBefore(p.childNodes[0], p);\n            f.removeChild(p), this._sanitize(h, f);\n            break;\n          }\n          for (var M = 0; M < p.attributes.length; M += 1) {\n            var R = p.attributes[M];\n            u(R, x, p) && (p.removeAttribute(R.name), M = M - 1);\n          }\n          this._sanitize(h, p);\n        } while (p = v.nextSibling());\n    };\n    function a(h, f) {\n      return h.createTreeWalker(\n        f,\n        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n        null,\n        !1\n      );\n    }\n    function l(h, f, v) {\n      return typeof h.tags[f] == \"function\" ? h.tags[f](v) : h.tags[f];\n    }\n    function c(h, f) {\n      return typeof f > \"u\" ? !0 : typeof f == \"boolean\" ? !f : !1;\n    }\n    function u(h, f, v) {\n      var p = h.name.toLowerCase();\n      return f === !0 ? !1 : typeof f[p] == \"function\" ? !f[p](h.value, v) : typeof f[p] > \"u\" || f[p] === !1 ? !0 : typeof f[p] == \"string\" ? f[p] !== h.value : !1;\n    }\n    return t;\n  });\n})(ro);\nconst ao = Oe;\nfunction ht(s, e) {\n  return s.map((t) => {\n    const o = D(e) ? e(t.tool) : e;\n    return V(o) || (t.data = Pe(t.data, o)), t;\n  });\n}\nfunction Z(s, e = {}) {\n  const t = {\n    tags: e\n  };\n  return new ao(t).clean(s);\n}\nfunction Pe(s, e) {\n  return Array.isArray(s) ? lo(s, e) : j(s) ? co(s, e) : J(s) ? ho(s, e) : s;\n}\nfunction lo(s, e) {\n  return s.map((t) => Pe(t, e));\n}\nfunction co(s, e) {\n  const t = {};\n  for (const o in s) {\n    if (!Object.prototype.hasOwnProperty.call(s, o))\n      continue;\n    const i = s[o], n = uo(e[o]) ? e[o] : e;\n    t[o] = Pe(i, n);\n  }\n  return t;\n}\nfunction ho(s, e) {\n  return j(e) ? Z(s, e) : e === !1 ? Z(s, {}) : s;\n}\nfunction uo(s) {\n  return j(s) || Nt(s) || D(s);\n}\nclass po extends S {\n  /**\n   * Available methods\n   *\n   * @returns {SanitizerConfig}\n   */\n  get methods() {\n    return {\n      clean: (e, t) => this.clean(e, t)\n    };\n  }\n  /**\n   * Perform sanitizing of a string\n   *\n   * @param {string} taintString - what to sanitize\n   * @param {SanitizerConfig} config - sanitizer config\n   * @returns {string}\n   */\n  clean(e, t) {\n    return Z(e, t);\n  }\n}\nclass fo extends S {\n  /**\n   * Available methods\n   *\n   * @returns {Saver}\n   */\n  get methods() {\n    return {\n      save: () => this.save()\n    };\n  }\n  /**\n   * Return Editor's data\n   *\n   * @returns {OutputData}\n   */\n  save() {\n    const e = \"Editor's content can not be saved in read-only mode\";\n    return this.Editor.ReadOnly.isEnabled ? (K(e, \"warn\"), Promise.reject(new Error(e))) : this.Editor.Saver.save();\n  }\n}\nclass go extends S {\n  /**\n   * Available methods\n   *\n   * @returns {SelectionAPIInterface}\n   */\n  get methods() {\n    return {\n      findParentTag: (e, t) => this.findParentTag(e, t),\n      expandToTag: (e) => this.expandToTag(e)\n    };\n  }\n  /**\n   * Looks ahead from selection and find passed tag with class name\n   *\n   * @param {string} tagName - tag to find\n   * @param {string} className - tag's class name\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t) {\n    return new m().findParentTag(e, t);\n  }\n  /**\n   * Expand selection to passed tag\n   *\n   * @param {HTMLElement} node - tag that should contain selection\n   */\n  expandToTag(e) {\n    new m().expandToTag(e);\n  }\n}\nclass bo extends S {\n  /**\n   * Exported classes\n   */\n  get classes() {\n    return {\n      /**\n       * Base Block styles\n       */\n      block: \"cdx-block\",\n      /**\n       * Inline Tools styles\n       */\n      inlineToolButton: \"ce-inline-tool\",\n      inlineToolButtonActive: \"ce-inline-tool--active\",\n      /**\n       * UI elements\n       */\n      input: \"cdx-input\",\n      loader: \"cdx-loader\",\n      button: \"cdx-button\",\n      /**\n       * Settings styles\n       */\n      settingsButton: \"cdx-settings-button\",\n      settingsButtonActive: \"cdx-settings-button--active\"\n    };\n  }\n}\nclass mo extends S {\n  /**\n   * Available methods\n   *\n   * @returns {Toolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open(),\n      toggleBlockSettings: (e) => this.toggleBlockSettings(e),\n      toggleToolbox: (e) => this.toggleToolbox(e)\n    };\n  }\n  /**\n   * Open toolbar\n   */\n  open() {\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * Close toolbar and all included elements\n   */\n  close() {\n    this.Editor.Toolbar.close();\n  }\n  /**\n   * Toggles Block Setting of the current block\n   *\n   * @param {boolean} openingState —  opening state of Block Setting\n   */\n  toggleBlockSettings(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      K(\"Could't toggle the Toolbar because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();\n  }\n  /**\n   * Open toolbox\n   *\n   * @param {boolean} openingState - Opening state of toolbox\n   */\n  toggleToolbox(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      K(\"Could't toggle the Toolbox because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();\n  }\n}\nvar _e = {}, ko = {\n  get exports() {\n    return _e;\n  },\n  set exports(s) {\n    _e = s;\n  }\n};\n/*!\n * CodeX.Tooltips\n * \n * @version 1.0.5\n * \n * @licence MIT\n * @author CodeX <https://codex.so>\n * \n * \n */\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(n) {\n        if (o[n])\n          return o[n].exports;\n        var r = o[n] = { i: n, l: !1, exports: {} };\n        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(n, r, a) {\n        i.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: a });\n      }, i.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, i.t = function(n, r) {\n        if (1 & r && (n = i(n)), 8 & r || 4 & r && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: n }), 2 & r && typeof n != \"string\")\n          for (var l in n)\n            i.d(a, l, function(c) {\n              return n[c];\n            }.bind(null, l));\n        return a;\n      }, i.n = function(n) {\n        var r = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(n, r) {\n        return Object.prototype.hasOwnProperty.call(n, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      t.exports = i(1);\n    }, function(t, o, i) {\n      i.r(o), i.d(o, \"default\", function() {\n        return n;\n      });\n      class n {\n        constructor() {\n          this.nodes = { wrapper: null, content: null }, this.showed = !1, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {\n            this.showed && this.hide(!0);\n          }, this.loadStyles(), this.prepare(), window.addEventListener(\"scroll\", this.handleWindowScroll, { passive: !0 });\n        }\n        get CSS() {\n          return { tooltip: \"ct\", tooltipContent: \"ct__content\", tooltipShown: \"ct--shown\", placement: { left: \"ct--left\", bottom: \"ct--bottom\", right: \"ct--right\", top: \"ct--top\" } };\n        }\n        show(a, l, c) {\n          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);\n          const u = Object.assign({ placement: \"bottom\", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, c);\n          if (u.hidingDelay && (this.hidingDelay = u.hidingDelay), this.nodes.content.innerHTML = \"\", typeof l == \"string\")\n            this.nodes.content.appendChild(document.createTextNode(l));\n          else {\n            if (!(l instanceof Node))\n              throw Error(\"[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But \" + typeof l + \" given.\");\n            this.nodes.content.appendChild(l);\n          }\n          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u.placement) {\n            case \"top\":\n              this.placeTop(a, u);\n              break;\n            case \"left\":\n              this.placeLeft(a, u);\n              break;\n            case \"right\":\n              this.placeRight(a, u);\n              break;\n            case \"bottom\":\n            default:\n              this.placeBottom(a, u);\n          }\n          u && u.delay ? this.showingTimeout = setTimeout(() => {\n            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0;\n          }, u.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0);\n        }\n        hide(a = !1) {\n          if (this.hidingDelay && !a)\n            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {\n              this.hide(!0);\n            }, this.hidingDelay));\n          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = !1, this.showingTimeout && clearTimeout(this.showingTimeout);\n        }\n        onHover(a, l, c) {\n          a.addEventListener(\"mouseenter\", () => {\n            this.show(a, l, c);\n          }), a.addEventListener(\"mouseleave\", () => {\n            this.hide();\n          });\n        }\n        destroy() {\n          this.nodes.wrapper.remove(), window.removeEventListener(\"scroll\", this.handleWindowScroll);\n        }\n        prepare() {\n          this.nodes.wrapper = this.make(\"div\", this.CSS.tooltip), this.nodes.content = this.make(\"div\", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);\n        }\n        loadStyles() {\n          const a = \"codex-tooltips-style\";\n          if (document.getElementById(a))\n            return;\n          const l = i(2), c = this.make(\"style\", null, { textContent: l.toString(), id: a });\n          this.prepend(document.head, c);\n        }\n        placeBottom(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.bottom + window.pageYOffset + this.offsetTop + l.marginTop;\n          this.applyPlacement(\"bottom\", u, h);\n        }\n        placeTop(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;\n          this.applyPlacement(\"top\", u, h);\n        }\n        placeLeft(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l.marginLeft, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"left\", u, h);\n        }\n        placeRight(a, l) {\n          const c = a.getBoundingClientRect(), u = c.right + this.offsetRight + l.marginRight, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"right\", u, h);\n        }\n        applyPlacement(a, l, c) {\n          this.nodes.wrapper.classList.add(this.CSS.placement[a]), this.nodes.wrapper.style.left = l + \"px\", this.nodes.wrapper.style.top = c + \"px\";\n        }\n        make(a, l = null, c = {}) {\n          const u = document.createElement(a);\n          Array.isArray(l) ? u.classList.add(...l) : l && u.classList.add(l);\n          for (const h in c)\n            c.hasOwnProperty(h) && (u[h] = c[h]);\n          return u;\n        }\n        append(a, l) {\n          Array.isArray(l) ? l.forEach((c) => a.appendChild(c)) : a.appendChild(l);\n        }\n        prepend(a, l) {\n          Array.isArray(l) ? (l = l.reverse()).forEach((c) => a.prepend(c)) : a.prepend(l);\n        }\n      }\n    }, function(t, o) {\n      t.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:\"\";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url(\"\")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><path d=\"M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z\"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:\"\";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;\n    }]).default;\n  });\n})(ko);\nconst vo = /* @__PURE__ */ xe(_e);\nclass Fe {\n  constructor() {\n    this.lib = new vo();\n  }\n  /**\n   * Release the library\n   */\n  destroy() {\n    this.lib.destroy();\n  }\n  /**\n   * Shows tooltip on element with passed HTML content\n   *\n   * @param {HTMLElement} element - any HTML element in DOM\n   * @param content - tooltip's content\n   * @param options - showing settings\n   */\n  show(e, t, o) {\n    this.lib.show(e, t, o);\n  }\n  /**\n   * Hides tooltip\n   *\n   * @param skipHidingDelay — pass true to immediately hide the tooltip\n   */\n  hide(e = !1) {\n    this.lib.hide(e);\n  }\n  /**\n   * Binds 'mouseenter' and 'mouseleave' events that shows/hides the Tooltip\n   *\n   * @param {HTMLElement} element - any HTML element in DOM\n   * @param content - tooltip's content\n   * @param options - showing settings\n   */\n  onHover(e, t, o) {\n    this.lib.onHover(e, t, o);\n  }\n}\nclass xo extends S {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.tooltip = new Fe();\n  }\n  /**\n   * Destroy Module\n   */\n  destroy() {\n    this.tooltip.destroy();\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e, t, o) => this.show(e, t, o),\n      hide: () => this.hide(),\n      onHover: (e, t, o) => this.onHover(e, t, o)\n    };\n  }\n  /**\n   * Method show tooltip on element with passed HTML content\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  show(e, t, o) {\n    this.tooltip.show(e, t, o);\n  }\n  /**\n   * Method hides tooltip on HTML page\n   */\n  hide() {\n    this.tooltip.hide();\n  }\n  /**\n   * Decorator for showing Tooltip by mouseenter/mouseleave\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  onHover(e, t, o) {\n    this.tooltip.onHover(e, t, o);\n  }\n}\nclass wo extends S {\n  /**\n   * Available methods / getters\n   */\n  get methods() {\n    return {\n      nodes: this.editorNodes\n      /**\n       * There can be added some UI methods, like toggleThinMode() etc\n       */\n    };\n  }\n  /**\n   * Exported classes\n   */\n  get editorNodes() {\n    return {\n      /**\n       * Top-level editor instance wrapper\n       */\n      wrapper: this.Editor.UI.nodes.wrapper,\n      /**\n       * Element that holds all the Blocks\n       */\n      redactor: this.Editor.UI.nodes.redactor\n    };\n  }\n}\nfunction ut(s, e) {\n  const t = {};\n  return Object.entries(s).forEach(([o, i]) => {\n    if (j(i)) {\n      const n = e ? `${e}.${o}` : o;\n      Object.values(i).every((a) => J(a)) ? t[o] = n : t[o] = ut(i, n);\n      return;\n    }\n    t[o] = i;\n  }), t;\n}\nconst X = ut(rt);\nfunction yo(s, e) {\n  const t = {};\n  return Object.keys(s).forEach((o) => {\n    const i = e[o];\n    i !== void 0 ? t[i] = s[o] : t[o] = s[o];\n  }), t;\n}\nconst Eo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11\"/></svg>', pt = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10\"/></svg>', Bo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15\"/></svg>', Co = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16\"/></svg>', To = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"4\" stroke=\"currentColor\" stroke-width=\"2\"/></svg>', So = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13.34 10C12.4223 12.7337 11 17 11 17\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.21 7H14.2\"/></svg>', qe = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72\"/></svg>', Io = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 7.29999H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 7.29999H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.30999 12H9.3\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 12H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 16.7H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 16.7H14.59\"/></svg>', Mo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 7V12M12 17V12M17 12H12M12 12H7\"/></svg>', Lo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"10.5\" cy=\"10.5\" r=\"5.5\" stroke=\"currentColor\" stroke-width=\"2\"/><line x1=\"15.4142\" x2=\"19\" y1=\"15\" y2=\"18.5858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', Oo = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397\"/><line x1=\"12.1142\" x2=\"11.7\" y1=\"12.2\" y2=\"11.7858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>';\nclass P {\n  /**\n   * Constructs popover item instance\n   *\n   * @param params - popover item construction params\n   */\n  constructor(e) {\n    this.nodes = {\n      root: null,\n      icon: null\n    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {\n      this.nodes.root.classList.remove(P.CSS.noFocus);\n    }, this.removeSpecialHoverBehavior = () => {\n      this.nodes.root.classList.remove(P.CSS.noHover);\n    }, this.onErrorAnimationEnd = () => {\n      this.nodes.icon.classList.remove(P.CSS.wobbleAnimation), this.nodes.icon.removeEventListener(\"animationend\", this.onErrorAnimationEnd);\n    }, this.params = e, this.nodes.root = this.make(e);\n  }\n  /**\n   * True if item is disabled and hence not clickable\n   */\n  get isDisabled() {\n    return this.params.isDisabled;\n  }\n  /**\n   * Exposes popover item toggle parameter\n   */\n  get toggle() {\n    return this.params.toggle;\n  }\n  /**\n   * Item title\n   */\n  get title() {\n    return this.params.title;\n  }\n  /**\n   * True if popover should close once item is activated\n   */\n  get closeOnActivate() {\n    return this.params.closeOnActivate;\n  }\n  /**\n   * True if confirmation state is enabled for popover item\n   */\n  get isConfirmationStateEnabled() {\n    return this.confirmationState !== null;\n  }\n  /**\n   * True if item is focused in keyboard navigation process\n   */\n  get isFocused() {\n    return this.nodes.root.classList.contains(P.CSS.focused);\n  }\n  /**\n   * Popover item CSS classes\n   */\n  static get CSS() {\n    return {\n      container: \"ce-popover-item\",\n      title: \"ce-popover-item__title\",\n      secondaryTitle: \"ce-popover-item__secondary-title\",\n      icon: \"ce-popover-item__icon\",\n      active: \"ce-popover-item--active\",\n      disabled: \"ce-popover-item--disabled\",\n      focused: \"ce-popover-item--focused\",\n      hidden: \"ce-popover-item--hidden\",\n      confirmationState: \"ce-popover-item--confirmation\",\n      noHover: \"ce-popover-item--no-hover\",\n      noFocus: \"ce-popover-item--no-focus\",\n      wobbleAnimation: \"wobble\"\n    };\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    if (this.isConfirmationStateEnabled) {\n      this.activateOrEnableConfirmationMode(this.confirmationState);\n      return;\n    }\n    this.activateOrEnableConfirmationMode(this.params);\n  }\n  /**\n   * Toggles item active state\n   *\n   * @param isActive - true if item should strictly should become active\n   */\n  toggleActive(e) {\n    this.nodes.root.classList.toggle(P.CSS.active, e);\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    this.nodes.root.classList.toggle(P.CSS.hidden, e);\n  }\n  /**\n   * Resets popover item to its original state\n   */\n  reset() {\n    this.isConfirmationStateEnabled && this.disableConfirmationMode();\n  }\n  /**\n   * Method called once item becomes focused during keyboard navigation\n   */\n  onFocus() {\n    this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Constructs HTML element corresponding to popover item params\n   *\n   * @param params - item construction params\n   */\n  make(e) {\n    const t = d.make(\"div\", P.CSS.container);\n    return e.name && (t.dataset.itemName = e.name), this.nodes.icon = d.make(\"div\", P.CSS.icon, {\n      innerHTML: e.icon || To\n    }), t.appendChild(this.nodes.icon), t.appendChild(d.make(\"div\", P.CSS.title, {\n      innerHTML: e.title || \"\"\n    })), e.secondaryLabel && t.appendChild(d.make(\"div\", P.CSS.secondaryTitle, {\n      textContent: e.secondaryLabel\n    })), e.isActive && t.classList.add(P.CSS.active), e.isDisabled && t.classList.add(P.CSS.disabled), t;\n  }\n  /**\n   * Activates confirmation mode for the item.\n   *\n   * @param newState - new popover item params that should be applied\n   */\n  enableConfirmationMode(e) {\n    const t = {\n      ...this.params,\n      ...e,\n      confirmation: e.confirmation\n    }, o = this.make(t);\n    this.nodes.root.innerHTML = o.innerHTML, this.nodes.root.classList.add(P.CSS.confirmationState), this.confirmationState = e, this.enableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Returns item to its original state\n   */\n  disableConfirmationMode() {\n    const e = this.make(this.params);\n    this.nodes.root.innerHTML = e.innerHTML, this.nodes.root.classList.remove(P.CSS.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Enables special focus and hover behavior for item in confirmation state.\n   * This is needed to prevent item from being highlighted as hovered/focused just after click.\n   */\n  enableSpecialHoverAndFocusBehavior() {\n    this.nodes.root.classList.add(P.CSS.noHover), this.nodes.root.classList.add(P.CSS.noFocus), this.nodes.root.addEventListener(\"mouseleave\", this.removeSpecialHoverBehavior, { once: !0 });\n  }\n  /**\n   * Disables special focus and hover behavior\n   */\n  disableSpecialHoverAndFocusBehavior() {\n    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), this.nodes.root.removeEventListener(\"mouseleave\", this.removeSpecialHoverBehavior);\n  }\n  /**\n   * Executes item's onActivate callback if the item has no confirmation configured\n   *\n   * @param item - item to activate or bring to confirmation mode\n   */\n  activateOrEnableConfirmationMode(e) {\n    if (e.confirmation === void 0)\n      try {\n        e.onActivate(e), this.disableConfirmationMode();\n      } catch {\n        this.animateError();\n      }\n    else\n      this.enableConfirmationMode(e.confirmation);\n  }\n  /**\n   * Animates item which symbolizes that error occured while executing 'onActivate()' callback\n   */\n  animateError() {\n    this.nodes.icon.classList.contains(P.CSS.wobbleAnimation) || (this.nodes.icon.classList.add(P.CSS.wobbleAnimation), this.nodes.icon.addEventListener(\"animationend\", this.onErrorAnimationEnd));\n  }\n}\nconst ce = class {\n  /**\n   * @param {HTMLElement[]} nodeList — the list of iterable HTML-items\n   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process\n   */\n  constructor(s, e) {\n    this.cursor = -1, this.items = [], this.items = s || [], this.focusedCssClass = e;\n  }\n  /**\n   * Returns Focused button Node\n   *\n   * @returns {HTMLElement}\n   */\n  get currentItem() {\n    return this.cursor === -1 ? null : this.items[this.cursor];\n  }\n  /**\n   * Sets cursor to specified position\n   *\n   * @param cursorPosition - new cursor position\n   */\n  setCursor(s) {\n    s < this.items.length && s >= -1 && (this.dropCursor(), this.cursor = s, this.items[this.cursor].classList.add(this.focusedCssClass));\n  }\n  /**\n   * Sets items. Can be used when iterable items changed dynamically\n   *\n   * @param {HTMLElement[]} nodeList - nodes to iterate\n   */\n  setItems(s) {\n    this.items = s;\n  }\n  /**\n   * Sets cursor next to the current\n   */\n  next() {\n    this.cursor = this.leafNodesAndReturnIndex(ce.directions.RIGHT);\n  }\n  /**\n   * Sets cursor before current\n   */\n  previous() {\n    this.cursor = this.leafNodesAndReturnIndex(ce.directions.LEFT);\n  }\n  /**\n   * Sets cursor to the default position and removes CSS-class from previously focused item\n   */\n  dropCursor() {\n    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);\n  }\n  /**\n   * Leafs nodes inside the target list from active element\n   *\n   * @param {string} direction - leaf direction. Can be 'left' or 'right'\n   * @returns {number} index of focused node\n   */\n  leafNodesAndReturnIndex(s) {\n    if (this.items.length === 0)\n      return this.cursor;\n    let e = this.cursor;\n    return e === -1 ? e = s === ce.directions.RIGHT ? -1 : 0 : this.items[e].classList.remove(this.focusedCssClass), s === ce.directions.RIGHT ? e = (e + 1) % this.items.length : e = (this.items.length + e - 1) % this.items.length, d.canSetCaret(this.items[e]) && oe(() => m.setCursor(this.items[e]), 50)(), this.items[e].classList.add(this.focusedCssClass), e;\n  }\n};\nlet ne = ce;\nne.directions = {\n  RIGHT: \"right\",\n  LEFT: \"left\"\n};\nclass G {\n  /**\n   * @param {FlipperOptions} options - different constructing settings\n   */\n  constructor(e) {\n    this.iterator = null, this.activated = !1, this.flipCallbacks = [], this.onKeyDown = (t) => {\n      if (this.isEventReadyForHandling(t))\n        switch (G.usedKeys.includes(t.keyCode) && t.preventDefault(), t.keyCode) {\n          case B.TAB:\n            this.handleTabPress(t);\n            break;\n          case B.LEFT:\n          case B.UP:\n            this.flipLeft();\n            break;\n          case B.RIGHT:\n          case B.DOWN:\n            this.flipRight();\n            break;\n          case B.ENTER:\n            this.handleEnterPress(t);\n            break;\n        }\n    }, this.iterator = new ne(e.items, e.focusedItemClass), this.activateCallback = e.activateCallback, this.allowedKeys = e.allowedKeys || G.usedKeys;\n  }\n  /**\n   * True if flipper is currently activated\n   */\n  get isActivated() {\n    return this.activated;\n  }\n  /**\n   * Array of keys (codes) that is handled by Flipper\n   * Used to:\n   *  - preventDefault only for this keys, not all keydowns (@see constructor)\n   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)\n   */\n  static get usedKeys() {\n    return [\n      B.TAB,\n      B.LEFT,\n      B.RIGHT,\n      B.ENTER,\n      B.UP,\n      B.DOWN\n    ];\n  }\n  /**\n   * Active tab/arrows handling by flipper\n   *\n   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically\n   * @param cursorPosition - index of the item that should be focused once flipper is activated\n   */\n  activate(e, t) {\n    this.activated = !0, e && this.iterator.setItems(e), t !== void 0 && this.iterator.setCursor(t), document.addEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  /**\n   * Disable tab/arrows handling by flipper\n   */\n  deactivate() {\n    this.activated = !1, this.dropCursor(), document.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n  /**\n   * Focus first item\n   */\n  focusFirst() {\n    this.dropCursor(), this.flipRight();\n  }\n  /**\n   * Focuses previous flipper iterator item\n   */\n  flipLeft() {\n    this.iterator.previous(), this.flipCallback();\n  }\n  /**\n   * Focuses next flipper iterator item\n   */\n  flipRight() {\n    this.iterator.next(), this.flipCallback();\n  }\n  /**\n   * Return true if some button is focused\n   */\n  hasFocus() {\n    return !!this.iterator.currentItem;\n  }\n  /**\n   * Registeres function that should be executed on each navigation action\n   *\n   * @param cb - function to execute\n   */\n  onFlip(e) {\n    this.flipCallbacks.push(e);\n  }\n  /**\n   * Unregisteres function that is executed on each navigation action\n   *\n   * @param cb - function to stop executing\n   */\n  removeOnFlip(e) {\n    this.flipCallbacks = this.flipCallbacks.filter((t) => t !== e);\n  }\n  /**\n   * Drops flipper's iterator cursor\n   *\n   * @see DomIterator#dropCursor\n   */\n  dropCursor() {\n    this.iterator.dropCursor();\n  }\n  /**\n   * This function is fired before handling flipper keycodes\n   * The result of this function defines if it is need to be handled or not\n   *\n   * @param {KeyboardEvent} event - keydown keyboard event\n   * @returns {boolean}\n   */\n  isEventReadyForHandling(e) {\n    return this.activated && this.allowedKeys.includes(e.keyCode);\n  }\n  /**\n   * When flipper is activated tab press will leaf the items\n   *\n   * @param {KeyboardEvent} event - tab keydown event\n   */\n  handleTabPress(e) {\n    switch (e.shiftKey ? ne.directions.LEFT : ne.directions.RIGHT) {\n      case ne.directions.RIGHT:\n        this.flipRight();\n        break;\n      case ne.directions.LEFT:\n        this.flipLeft();\n        break;\n    }\n  }\n  /**\n   * Enter press will click current item if flipper is activated\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  handleEnterPress(e) {\n    this.activated && (this.iterator.currentItem && (e.stopPropagation(), e.preventDefault(), this.iterator.currentItem.click()), D(this.activateCallback) && this.activateCallback(this.iterator.currentItem));\n  }\n  /**\n   * Fired after flipping in any direction\n   */\n  flipCallback() {\n    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e) => e());\n  }\n}\nclass ue {\n  /**\n   * Styles\n   */\n  static get CSS() {\n    return {\n      wrapper: \"cdx-search-field\",\n      icon: \"cdx-search-field__icon\",\n      input: \"cdx-search-field__input\"\n    };\n  }\n  /**\n   * @param options - available config\n   * @param options.items - searchable items list\n   * @param options.onSearch - search callback\n   * @param options.placeholder - input placeholder\n   */\n  constructor({ items: e, onSearch: t, placeholder: o }) {\n    this.listeners = new Re(), this.items = e, this.onSearch = t, this.render(o);\n  }\n  /**\n   * Returns search field element\n   */\n  getElement() {\n    return this.wrapper;\n  }\n  /**\n   * Sets focus to the input\n   */\n  focus() {\n    this.input.focus();\n  }\n  /**\n   * Clears search query and results\n   */\n  clear() {\n    this.input.value = \"\", this.searchQuery = \"\", this.onSearch(\"\", this.foundItems);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.listeners.removeAll();\n  }\n  /**\n   * Creates the search field\n   *\n   * @param placeholder - input placeholder\n   */\n  render(e) {\n    this.wrapper = d.make(\"div\", ue.CSS.wrapper);\n    const t = d.make(\"div\", ue.CSS.icon, {\n      innerHTML: Lo\n    });\n    this.input = d.make(\"input\", ue.CSS.input, {\n      placeholder: e\n    }), this.wrapper.appendChild(t), this.wrapper.appendChild(this.input), this.listeners.on(this.input, \"input\", () => {\n      this.searchQuery = this.input.value, this.onSearch(this.searchQuery, this.foundItems);\n    });\n  }\n  /**\n   * Returns list of found items for the current search query\n   */\n  get foundItems() {\n    return this.items.filter((e) => this.checkItem(e));\n  }\n  /**\n   * Contains logic for checking whether passed item conforms the search query\n   *\n   * @param item - item to be checked\n   */\n  checkItem(e) {\n    var i;\n    const t = ((i = e.title) == null ? void 0 : i.toLowerCase()) || \"\", o = this.searchQuery.toLowerCase();\n    return t.includes(o);\n  }\n}\nconst de = class {\n  /**\n   * Locks body element scroll\n   */\n  lock() {\n    Ge ? this.lockHard() : document.body.classList.add(de.CSS.scrollLocked);\n  }\n  /**\n   * Unlocks body element scroll\n   */\n  unlock() {\n    Ge ? this.unlockHard() : document.body.classList.remove(de.CSS.scrollLocked);\n  }\n  /**\n   * Locks scroll in a hard way (via setting fixed position to body element)\n   */\n  lockHard() {\n    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(\n      \"--window-scroll-offset\",\n      `${this.scrollPosition}px`\n    ), document.body.classList.add(de.CSS.scrollLockedHard);\n  }\n  /**\n   * Unlocks hard scroll lock\n   */\n  unlockHard() {\n    document.body.classList.remove(de.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;\n  }\n};\nlet ft = de;\nft.CSS = {\n  scrollLocked: \"ce-scroll-locked\",\n  scrollLockedHard: \"ce-scroll-locked--hard\"\n};\nvar _o = Object.defineProperty, Ao = Object.getOwnPropertyDescriptor, No = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? Ao(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && _o(e, t, i), i;\n}, fe = /* @__PURE__ */ ((s) => (s.Close = \"close\", s))(fe || {});\nconst z = class extends we {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover construction params\n   */\n  constructor(s) {\n    super(), this.scopeElement = document.body, this.listeners = new Re(), this.scrollLocker = new ft(), this.nodes = {\n      wrapper: null,\n      popover: null,\n      nothingFoundMessage: null,\n      customContent: null,\n      items: null,\n      overlay: null\n    }, this.messages = {\n      nothingFound: \"Nothing found\",\n      search: \"Search\"\n    }, this.onFlip = () => {\n      this.items.find((t) => t.isFocused).onFocus();\n    }, this.items = s.items.map((e) => new P(e)), s.scopeElement !== void 0 && (this.scopeElement = s.scopeElement), s.messages && (this.messages = {\n      ...this.messages,\n      ...s.messages\n    }), s.customContentFlippableItems && (this.customContentFlippableItems = s.customContentFlippableItems), this.make(), s.customContent && this.addCustomContent(s.customContent), s.searchable && this.addSearch(), this.initializeFlipper();\n  }\n  /**\n   * Popover CSS classes\n   */\n  static get CSS() {\n    return {\n      popover: \"ce-popover\",\n      popoverOpenTop: \"ce-popover--open-top\",\n      popoverOpened: \"ce-popover--opened\",\n      search: \"ce-popover__search\",\n      nothingFoundMessage: \"ce-popover__nothing-found-message\",\n      nothingFoundMessageDisplayed: \"ce-popover__nothing-found-message--displayed\",\n      customContent: \"ce-popover__custom-content\",\n      customContentHidden: \"ce-popover__custom-content--hidden\",\n      items: \"ce-popover__items\",\n      overlay: \"ce-popover__overlay\",\n      overlayHidden: \"ce-popover__overlay--hidden\"\n    };\n  }\n  /**\n   * Returns HTML element corresponding to the popover\n   */\n  getElement() {\n    return this.nodes.wrapper;\n  }\n  /**\n   * Returns true if some item inside popover is focused\n   */\n  hasFocus() {\n    return this.flipper.hasFocus();\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.shouldOpenBottom || (this.nodes.popover.style.setProperty(\"--popover-height\", this.height + \"px\"), this.nodes.popover.classList.add(z.CSS.popoverOpenTop)), this.nodes.overlay.classList.remove(z.CSS.overlayHidden), this.nodes.popover.classList.add(z.CSS.popoverOpened), this.flipper.activate(this.flippableElements), this.search !== void 0 && setTimeout(() => {\n      this.search.focus();\n    }, 100), ee() && this.scrollLocker.lock();\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.nodes.popover.classList.remove(z.CSS.popoverOpened), this.nodes.popover.classList.remove(z.CSS.popoverOpenTop), this.nodes.overlay.classList.add(z.CSS.overlayHidden), this.flipper.deactivate(), this.items.forEach((s) => s.reset()), this.search !== void 0 && this.search.clear(), ee() && this.scrollLocker.unlock(), this.emit(\n      \"close\"\n      /* Close */\n    );\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.flipper.deactivate(), this.listeners.removeAll(), ee() && this.scrollLocker.unlock();\n  }\n  /**\n   * Constructs HTML element corresponding to popover\n   */\n  make() {\n    this.nodes.popover = d.make(\"div\", [z.CSS.popover]), this.nodes.nothingFoundMessage = d.make(\"div\", [z.CSS.nothingFoundMessage], {\n      textContent: this.messages.nothingFound\n    }), this.nodes.popover.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d.make(\"div\", [z.CSS.items]), this.items.forEach((s) => {\n      this.nodes.items.appendChild(s.getElement());\n    }), this.nodes.popover.appendChild(this.nodes.items), this.listeners.on(this.nodes.popover, \"click\", (s) => {\n      const e = this.getTargetItem(s);\n      e !== void 0 && this.handleItemClick(e);\n    }), this.nodes.wrapper = d.make(\"div\"), this.nodes.overlay = d.make(\"div\", [z.CSS.overlay, z.CSS.overlayHidden]), this.listeners.on(this.nodes.overlay, \"click\", () => {\n      this.hide();\n    }), this.nodes.wrapper.appendChild(this.nodes.overlay), this.nodes.wrapper.appendChild(this.nodes.popover);\n  }\n  /**\n   * Adds search to the popover\n   */\n  addSearch() {\n    this.search = new ue({\n      items: this.items,\n      placeholder: this.messages.search,\n      onSearch: (e, t) => {\n        this.items.forEach((i) => {\n          const n = !t.includes(i);\n          i.toggleHidden(n);\n        }), this.toggleNothingFoundMessage(t.length === 0), this.toggleCustomContent(e !== \"\");\n        const o = e === \"\" ? this.flippableElements : t.map((i) => i.getElement());\n        this.flipper.isActivated && (this.flipper.deactivate(), this.flipper.activate(o));\n      }\n    });\n    const s = this.search.getElement();\n    s.classList.add(z.CSS.search), this.nodes.popover.insertBefore(s, this.nodes.popover.firstChild);\n  }\n  /**\n   * Adds custom html content to the popover\n   *\n   * @param content - html content to append\n   */\n  addCustomContent(s) {\n    this.nodes.customContent = s, this.nodes.customContent.classList.add(z.CSS.customContent), this.nodes.popover.insertBefore(s, this.nodes.popover.firstChild);\n  }\n  /**\n   * Retrieves popover item that is the target of the specified event\n   *\n   * @param event - event to retrieve popover item from\n   */\n  getTargetItem(s) {\n    return this.items.find((e) => s.composedPath().includes(e.getElement()));\n  }\n  /**\n   * Handles item clicks\n   *\n   * @param item - item to handle click of\n   */\n  handleItemClick(s) {\n    s.isDisabled || (this.items.filter((e) => e !== s).forEach((e) => e.reset()), s.handleClick(), this.toggleItemActivenessIfNeeded(s), s.closeOnActivate && this.hide());\n  }\n  /**\n   * Creates Flipper instance which allows to navigate between popover items via keyboard\n   */\n  initializeFlipper() {\n    this.flipper = new G({\n      items: this.flippableElements,\n      focusedItemClass: P.CSS.focused,\n      allowedKeys: [\n        B.TAB,\n        B.UP,\n        B.DOWN,\n        B.ENTER\n      ]\n    }), this.flipper.onFlip(this.onFlip);\n  }\n  /**\n   * Returns list of elements available for keyboard navigation.\n   * Contains both usual popover items elements and custom html content.\n   */\n  get flippableElements() {\n    const s = this.items.map((t) => t.getElement());\n    return (this.customContentFlippableItems || []).concat(s);\n  }\n  get height() {\n    let s = 0;\n    if (this.nodes.popover === null)\n      return s;\n    const e = this.nodes.popover.cloneNode(!0);\n    return e.style.visibility = \"hidden\", e.style.position = \"absolute\", e.style.top = \"-1000px\", e.classList.add(z.CSS.popoverOpened), document.body.appendChild(e), s = e.offsetHeight, e.remove(), s;\n  }\n  /**\n   * Checks if popover should be opened bottom.\n   * It should happen when there is enough space below or not enough space above\n   */\n  get shouldOpenBottom() {\n    const s = this.nodes.popover.getBoundingClientRect(), e = this.scopeElement.getBoundingClientRect(), t = this.height, o = s.top + t, i = s.top - t, n = Math.min(window.innerHeight, e.bottom);\n    return i < e.top || o <= n;\n  }\n  /**\n   * Toggles nothing found message visibility\n   *\n   * @param isDisplayed - true if the message should be displayed\n   */\n  toggleNothingFoundMessage(s) {\n    this.nodes.nothingFoundMessage.classList.toggle(z.CSS.nothingFoundMessageDisplayed, s);\n  }\n  /**\n   * Toggles custom content visibility\n   *\n   * @param isDisplayed - true if custom content should be displayed\n   */\n  toggleCustomContent(s) {\n    var e;\n    (e = this.nodes.customContent) == null || e.classList.toggle(z.CSS.customContentHidden, s);\n  }\n  /**\n   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.\n   *\n   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.\n   * (All the other items with the same key get inactive, and the item gets active)\n   *\n   * @param clickedItem - popover item that was clicked\n   */\n  toggleItemActivenessIfNeeded(s) {\n    if (s.toggle === !0 && s.toggleActive(), typeof s.toggle == \"string\") {\n      const e = this.items.filter((t) => t.toggle === s.toggle);\n      if (e.length === 1) {\n        s.toggleActive();\n        return;\n      }\n      e.forEach((t) => {\n        t.toggleActive(t === s);\n      });\n    }\n  }\n};\nlet He = z;\nNo([\n  ae\n], He.prototype, \"height\", 1);\nclass Ro extends S {\n  constructor() {\n    super(...arguments), this.opened = !1, this.selection = new m(), this.onPopoverClose = () => {\n      this.close();\n    };\n  }\n  /**\n   * Module Events\n   *\n   * @returns {{opened: string, closed: string}}\n   */\n  get events() {\n    return {\n      opened: \"block-settings-opened\",\n      closed: \"block-settings-closed\"\n    };\n  }\n  /**\n   * Block Settings CSS\n   */\n  get CSS() {\n    return {\n      settings: \"ce-settings\"\n    };\n  }\n  /**\n   * Getter for inner popover's flipper instance\n   *\n   * @todo remove once BlockSettings becomes standalone non-module class\n   */\n  get flipper() {\n    var e;\n    return (e = this.popover) == null ? void 0 : e.flipper;\n  }\n  /**\n   * Panel with block settings with 2 sections:\n   *  - Tool's Settings\n   *  - Default Settings [Move, Remove, etc]\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [this.CSS.settings]);\n  }\n  /**\n   * Destroys module\n   */\n  destroy() {\n    this.removeAllNodes();\n  }\n  /**\n   * Open Block Settings pane\n   *\n   * @param targetBlock - near which Block we should open BlockSettings\n   */\n  open(e = this.Editor.BlockManager.currentBlock) {\n    this.opened = !0, this.selection.save(), e.selected = !0, this.Editor.BlockSelection.clearCache();\n    const [t, o] = e.getTunes();\n    this.eventsDispatcher.emit(this.events.opened), this.popover = new He({\n      searchable: !0,\n      items: t.map((i) => this.resolveTuneAliases(i)),\n      customContent: o,\n      customContentFlippableItems: this.getControls(o),\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: $.ui(X.ui.popover, \"Nothing found\"),\n        search: $.ui(X.ui.popover, \"Filter\")\n      }\n    }), this.popover.on(fe.Close, this.onPopoverClose), this.nodes.wrapper.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.wrapper;\n  }\n  /**\n   * Close Block Settings pane\n   */\n  close() {\n    this.opened = !1, m.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && (this.Editor.BlockManager.currentBlock.selected = !1), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(fe.Close, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null);\n  }\n  /**\n   * Returns list of buttons and inputs inside specified container\n   *\n   * @param container - container to query controls inside of\n   */\n  getControls(e) {\n    const { StylesAPI: t } = this.Editor, o = e.querySelectorAll(\n      `.${t.classes.settingsButton}, ${d.allInputsSelector}`\n    );\n    return Array.from(o);\n  }\n  /**\n   * Resolves aliases in tunes menu items\n   *\n   * @param item - item with resolved aliases\n   */\n  resolveTuneAliases(e) {\n    const t = yo(e, { label: \"title\" });\n    return e.confirmation && (t.confirmation = this.resolveTuneAliases(e.confirmation)), t;\n  }\n}\nclass Y extends S {\n  constructor() {\n    super(...arguments), this.opened = !1, this.tools = [], this.flipper = null, this.togglingCallback = null;\n  }\n  /**\n   * CSS getter\n   */\n  static get CSS() {\n    return {\n      conversionToolbarWrapper: \"ce-conversion-toolbar\",\n      conversionToolbarShowed: \"ce-conversion-toolbar--showed\",\n      conversionToolbarTools: \"ce-conversion-toolbar__tools\",\n      conversionToolbarLabel: \"ce-conversion-toolbar__label\",\n      conversionTool: \"ce-conversion-tool\",\n      conversionToolHidden: \"ce-conversion-tool--hidden\",\n      conversionToolIcon: \"ce-conversion-tool__icon\",\n      conversionToolFocused: \"ce-conversion-tool--focused\",\n      conversionToolActive: \"ce-conversion-tool--active\"\n    };\n  }\n  /**\n   * Create UI of Conversion Toolbar\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [\n      Y.CSS.conversionToolbarWrapper,\n      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []\n    ]), this.nodes.tools = d.make(\"div\", Y.CSS.conversionToolbarTools);\n    const e = d.make(\"div\", Y.CSS.conversionToolbarLabel, {\n      textContent: $.ui(X.ui.inlineToolbar.converter, \"Convert to\")\n    });\n    return this.addTools(), this.enableFlipper(), d.append(this.nodes.wrapper, e), d.append(this.nodes.wrapper, this.nodes.tools), this.nodes.wrapper;\n  }\n  /**\n   * Deactivates flipper and removes all nodes\n   */\n  destroy() {\n    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();\n  }\n  /**\n   * Toggle conversion dropdown visibility\n   *\n   * @param {Function} [togglingCallback] — callback that will accept opening state\n   */\n  toggle(e) {\n    this.opened ? this.close() : this.open(), D(e) && (this.togglingCallback = e);\n  }\n  /**\n   * Shows Conversion Toolbar\n   */\n  open() {\n    this.filterTools(), this.opened = !0, this.nodes.wrapper.classList.add(Y.CSS.conversionToolbarShowed), window.requestAnimationFrame(() => {\n      this.flipper.activate(this.tools.map((e) => e.button).filter((e) => !e.classList.contains(Y.CSS.conversionToolHidden))), this.flipper.focusFirst(), D(this.togglingCallback) && this.togglingCallback(!0);\n    });\n  }\n  /**\n   * Closes Conversion Toolbar\n   */\n  close() {\n    this.opened = !1, this.flipper.deactivate(), this.nodes.wrapper.classList.remove(Y.CSS.conversionToolbarShowed), D(this.togglingCallback) && this.togglingCallback(!1);\n  }\n  /**\n   * Returns true if it has more than one tool available for convert in\n   */\n  hasTools() {\n    return this.tools.length === 1 ? this.tools[0].name !== this.config.defaultBlock : !0;\n  }\n  /**\n   * Replaces one Block with another\n   * For that Tools must provide import/export methods\n   *\n   * @param {string} replacingToolName - name of Tool which replaces current\n   * @param blockDataOverrides - Block data overrides. Could be passed in case if Multiple Toolbox items specified\n   */\n  async replaceWithBlock(e, t) {\n    const o = this.Editor.BlockManager.currentBlock.tool, n = (await this.Editor.BlockManager.currentBlock.save()).data, r = this.Editor.Tools.blockTools.get(e);\n    let a = \"\";\n    const l = o.conversionConfig.export;\n    if (D(l))\n      a = l(n);\n    else if (J(l))\n      a = n[l];\n    else {\n      T(\"Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export.\");\n      return;\n    }\n    const c = Z(\n      a,\n      r.sanitizeConfig\n    );\n    let u = {};\n    const h = r.conversionConfig.import;\n    if (D(h))\n      u = h(c);\n    else if (J(h))\n      u[h] = c;\n    else {\n      T(\"Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data.\");\n      return;\n    }\n    t && (u = Object.assign(u, t)), this.Editor.BlockManager.replace({\n      tool: e,\n      data: u\n    }), this.Editor.BlockSelection.clearSelection(), this.close(), this.Editor.InlineToolbar.close(), oe(() => {\n      this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock);\n    }, 10)();\n  }\n  /**\n   * Iterates existing Tools and inserts to the ConversionToolbar\n   * if tools have ability to import\n   */\n  addTools() {\n    const e = this.Editor.Tools.blockTools;\n    Array.from(e.entries()).forEach(([t, o]) => {\n      const i = o.conversionConfig;\n      !i || !i.import || o.toolbox.forEach(\n        (n) => this.addToolIfValid(t, n)\n      );\n    });\n  }\n  /**\n   * Inserts a tool to the ConversionToolbar if the tool's toolbox config is valid\n   *\n   * @param name - tool's name\n   * @param toolboxSettings - tool's single toolbox setting\n   */\n  addToolIfValid(e, t) {\n    V(t) || !t.icon || this.addTool(e, t);\n  }\n  /**\n   * Add tool to the Conversion Toolbar\n   *\n   * @param toolName - name of Tool to add\n   * @param toolboxItem - tool's toolbox item data\n   */\n  addTool(e, t) {\n    const o = d.make(\"div\", [Y.CSS.conversionTool]), i = d.make(\"div\", [Y.CSS.conversionToolIcon]);\n    o.dataset.tool = e, i.innerHTML = t.icon, d.append(o, i), d.append(o, d.text($.t(X.toolNames, t.title || ke(e)))), d.append(this.nodes.tools, o), this.tools.push({\n      name: e,\n      button: o,\n      toolboxItem: t\n    }), this.listeners.on(o, \"click\", async () => {\n      await this.replaceWithBlock(e, t.data);\n    });\n  }\n  /**\n   * Hide current Tool and show others\n   */\n  async filterTools() {\n    const { currentBlock: e } = this.Editor.BlockManager, t = await e.getActiveToolboxEntry();\n    function o(i, n) {\n      return i.icon === n.icon && i.title === n.title;\n    }\n    this.tools.forEach((i) => {\n      let n = !1;\n      if (t) {\n        const r = o(t, i.toolboxItem);\n        n = i.button.dataset.tool === e.name && r;\n      }\n      i.button.hidden = n, i.button.classList.toggle(Y.CSS.conversionToolHidden, n);\n    });\n  }\n  /**\n   * Prepare Flipper to be able to leaf tools by arrows/tab\n   */\n  enableFlipper() {\n    this.flipper = new G({\n      focusedItemClass: Y.CSS.conversionToolFocused\n    });\n  }\n}\nvar Ae = {}, Do = {\n  get exports() {\n    return Ae;\n  },\n  set exports(s) {\n    Ae = s;\n  }\n};\n/*!\n * Library for handling keyboard shortcuts\n * @copyright CodeX (https://codex.so)\n * @license MIT\n * @author CodeX (https://codex.so)\n * @version 1.2.0\n */\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(n) {\n        if (o[n])\n          return o[n].exports;\n        var r = o[n] = { i: n, l: !1, exports: {} };\n        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(n, r, a) {\n        i.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: a });\n      }, i.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, i.t = function(n, r) {\n        if (1 & r && (n = i(n)), 8 & r || 4 & r && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: n }), 2 & r && typeof n != \"string\")\n          for (var l in n)\n            i.d(a, l, function(c) {\n              return n[c];\n            }.bind(null, l));\n        return a;\n      }, i.n = function(n) {\n        var r = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(n, r) {\n        return Object.prototype.hasOwnProperty.call(n, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      function n(l, c) {\n        for (var u = 0; u < c.length; u++) {\n          var h = c[u];\n          h.enumerable = h.enumerable || !1, h.configurable = !0, \"value\" in h && (h.writable = !0), Object.defineProperty(l, h.key, h);\n        }\n      }\n      function r(l, c, u) {\n        return c && n(l.prototype, c), u && n(l, u), l;\n      }\n      i.r(o);\n      var a = function() {\n        function l(c) {\n          var u = this;\n          (function(h, f) {\n            if (!(h instanceof f))\n              throw new TypeError(\"Cannot call a class as a function\");\n          })(this, l), this.commands = {}, this.keys = {}, this.name = c.name, this.parseShortcutName(c.name), this.element = c.on, this.callback = c.callback, this.executeShortcut = function(h) {\n            u.execute(h);\n          }, this.element.addEventListener(\"keydown\", this.executeShortcut, !1);\n        }\n        return r(l, null, [{ key: \"supportedCommands\", get: function() {\n          return { SHIFT: [\"SHIFT\"], CMD: [\"CMD\", \"CONTROL\", \"COMMAND\", \"WINDOWS\", \"CTRL\"], ALT: [\"ALT\", \"OPTION\"] };\n        } }, { key: \"keyCodes\", get: function() {\n          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, \".\": 190 };\n        } }]), r(l, [{ key: \"parseShortcutName\", value: function(c) {\n          c = c.split(\"+\");\n          for (var u = 0; u < c.length; u++) {\n            c[u] = c[u].toUpperCase();\n            var h = !1;\n            for (var f in l.supportedCommands)\n              if (l.supportedCommands[f].includes(c[u])) {\n                h = this.commands[f] = !0;\n                break;\n              }\n            h || (this.keys[c[u]] = !0);\n          }\n          for (var v in l.supportedCommands)\n            this.commands[v] || (this.commands[v] = !1);\n        } }, { key: \"execute\", value: function(c) {\n          var u, h = { CMD: c.ctrlKey || c.metaKey, SHIFT: c.shiftKey, ALT: c.altKey }, f = !0;\n          for (u in this.commands)\n            this.commands[u] !== h[u] && (f = !1);\n          var v, p = !0;\n          for (v in this.keys)\n            p = p && c.keyCode === l.keyCodes[v];\n          f && p && this.callback(c);\n        } }, { key: \"remove\", value: function() {\n          this.element.removeEventListener(\"keydown\", this.executeShortcut);\n        } }]), l;\n      }();\n      o.default = a;\n    }]).default;\n  });\n})(Do);\nconst Po = /* @__PURE__ */ xe(Ae);\nclass Fo {\n  constructor() {\n    this.registeredShortcuts = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Register shortcut\n   *\n   * @param shortcut - shortcut options\n   */\n  add(e) {\n    if (this.findShortcut(e.on, e.name))\n      throw Error(\n        `Shortcut ${e.name} is already registered for ${e.on}. Please remove it before add a new handler.`\n      );\n    const o = new Po({\n      name: e.name,\n      on: e.on,\n      callback: e.handler\n    }), i = this.registeredShortcuts.get(e.on) || [];\n    this.registeredShortcuts.set(e.on, [...i, o]);\n  }\n  /**\n   * Remove shortcut\n   *\n   * @param element - Element shortcut is set for\n   * @param name - shortcut name\n   */\n  remove(e, t) {\n    const o = this.findShortcut(e, t);\n    if (!o)\n      return;\n    o.remove();\n    const i = this.registeredShortcuts.get(e);\n    this.registeredShortcuts.set(e, i.filter((n) => n !== o));\n  }\n  /**\n   * Get Shortcut instance if exist\n   *\n   * @param element - Element shorcut is set for\n   * @param shortcut - shortcut name\n   * @returns {number} index - shortcut index if exist\n   */\n  findShortcut(e, t) {\n    return (this.registeredShortcuts.get(e) || []).find(({ name: i }) => i === t);\n  }\n}\nconst re = new Fo();\nvar Ho = Object.defineProperty, zo = Object.getOwnPropertyDescriptor, gt = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? zo(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && Ho(e, t, i), i;\n}, be = /* @__PURE__ */ ((s) => (s.Opened = \"toolbox-opened\", s.Closed = \"toolbox-closed\", s.BlockAdded = \"toolbox-block-added\", s))(be || {});\nconst bt = class extends we {\n  /**\n   * Toolbox constructor\n   *\n   * @param options - available parameters\n   * @param options.api - Editor API methods\n   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not\n   */\n  constructor({ api: s, tools: e, i18nLabels: t }) {\n    super(), this.opened = !1, this.nodes = {\n      toolbox: null\n    }, this.onPopoverClose = () => {\n      this.opened = !1, this.emit(\n        \"toolbox-closed\"\n        /* Closed */\n      );\n    }, this.api = s, this.tools = e, this.i18nLabels = t;\n  }\n  /**\n   * Returns True if Toolbox is Empty and nothing to show\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    return this.toolsToBeDisplayed.length === 0;\n  }\n  /**\n   * CSS styles\n   *\n   * @returns {Object<string, string>}\n   */\n  static get CSS() {\n    return {\n      toolbox: \"ce-toolbox\"\n    };\n  }\n  /**\n   * Makes the Toolbox\n   */\n  make() {\n    return this.popover = new He({\n      scopeElement: this.api.ui.nodes.redactor,\n      searchable: !0,\n      messages: {\n        nothingFound: this.i18nLabels.nothingFound,\n        search: this.i18nLabels.filter\n      },\n      items: this.toolboxItemsToBeDisplayed\n    }), this.popover.on(fe.Close, this.onPopoverClose), this.enableShortcuts(), this.nodes.toolbox = this.popover.getElement(), this.nodes.toolbox.classList.add(bt.CSS.toolbox), this.nodes.toolbox;\n  }\n  /**\n   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button\n   */\n  hasFocus() {\n    var s;\n    return (s = this.popover) == null ? void 0 : s.hasFocus();\n  }\n  /**\n   * Destroy Module\n   */\n  destroy() {\n    var s;\n    super.destroy(), this.nodes && this.nodes.toolbox && (this.nodes.toolbox.remove(), this.nodes.toolbox = null), this.removeAllShortcuts(), (s = this.popover) == null || s.off(fe.Close, this.onPopoverClose);\n  }\n  /**\n   * Toolbox Tool's button click handler\n   *\n   * @param toolName - tool type to be activated\n   * @param blockDataOverrides - Block data predefined by the activated Toolbox item\n   */\n  toolButtonActivated(s, e) {\n    this.insertNewBlock(s, e);\n  }\n  /**\n   * Open Toolbox with Tools\n   */\n  open() {\n    var s;\n    this.isEmpty || ((s = this.popover) == null || s.show(), this.opened = !0, this.emit(\n      \"toolbox-opened\"\n      /* Opened */\n    ));\n  }\n  /**\n   * Close Toolbox\n   */\n  close() {\n    var s;\n    (s = this.popover) == null || s.hide(), this.opened = !1, this.emit(\n      \"toolbox-closed\"\n      /* Closed */\n    );\n  }\n  /**\n   * Close Toolbox\n   */\n  toggle() {\n    this.opened ? this.close() : this.open();\n  }\n  get toolsToBeDisplayed() {\n    const s = [];\n    return this.tools.forEach((e) => {\n      e.toolbox && s.push(e);\n    }), s;\n  }\n  get toolboxItemsToBeDisplayed() {\n    const s = (e, t) => ({\n      icon: e.icon,\n      title: $.t(X.toolNames, e.title || ke(t.name)),\n      name: t.name,\n      onActivate: () => {\n        this.toolButtonActivated(t.name, e.data);\n      },\n      secondaryLabel: t.shortcut ? nt(t.shortcut) : \"\"\n    });\n    return this.toolsToBeDisplayed.reduce((e, t) => (Array.isArray(t.toolbox) ? t.toolbox.forEach((o) => {\n      e.push(s(o, t));\n    }) : t.toolbox !== void 0 && e.push(s(t.toolbox, t)), e), []);\n  }\n  /**\n   * Iterate all tools and enable theirs shortcuts if specified\n   */\n  enableShortcuts() {\n    this.toolsToBeDisplayed.forEach((s) => {\n      const e = s.shortcut;\n      e && this.enableShortcutForTool(s.name, e);\n    });\n  }\n  /**\n   * Enable shortcut Block Tool implemented shortcut\n   *\n   * @param {string} toolName - Tool name\n   * @param {string} shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcutForTool(s, e) {\n    re.add({\n      name: e,\n      on: this.api.ui.nodes.redactor,\n      handler: (t) => {\n        t.preventDefault(), this.insertNewBlock(s);\n      }\n    });\n  }\n  /**\n   * Removes all added shortcuts\n   * Fired when the Read-Only mode is activated\n   */\n  removeAllShortcuts() {\n    this.toolsToBeDisplayed.forEach((s) => {\n      const e = s.shortcut;\n      e && re.remove(this.api.ui.nodes.redactor, e);\n    });\n  }\n  /**\n   * Inserts new block\n   * Can be called when button clicked on Toolbox or by ShortcutData\n   *\n   * @param {string} toolName - Tool name\n   * @param blockDataOverrides - predefined Block data\n   */\n  async insertNewBlock(s, e) {\n    const t = this.api.blocks.getCurrentBlockIndex(), o = this.api.blocks.getBlockByIndex(t);\n    if (!o)\n      return;\n    const i = o.isEmpty ? t : t + 1;\n    let n;\n    if (e) {\n      const a = await this.api.blocks.composeBlockData(s);\n      n = Object.assign(a, e);\n    }\n    const r = this.api.blocks.insert(\n      s,\n      n,\n      void 0,\n      i,\n      void 0,\n      o.isEmpty\n    );\n    r.call(q.APPEND_CALLBACK), this.api.caret.setToBlock(i), this.emit(\"toolbox-block-added\", {\n      block: r\n    }), this.api.toolbar.close();\n  }\n};\nlet ze = bt;\ngt([\n  ae\n], ze.prototype, \"toolsToBeDisplayed\", 1);\ngt([\n  ae\n], ze.prototype, \"toolboxItemsToBeDisplayed\", 1);\nconst mt = \"block hovered\";\nclass jo extends S {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.tooltip = new Fe();\n  }\n  /**\n   * CSS styles\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      toolbar: \"ce-toolbar\",\n      content: \"ce-toolbar__content\",\n      actions: \"ce-toolbar__actions\",\n      actionsOpened: \"ce-toolbar__actions--opened\",\n      toolbarOpened: \"ce-toolbar--opened\",\n      openedToolboxHolderModifier: \"codex-editor--toolbox-opened\",\n      plusButton: \"ce-toolbar__plus\",\n      plusButtonShortcut: \"ce-toolbar__plus-shortcut\",\n      settingsToggler: \"ce-toolbar__settings-btn\",\n      settingsTogglerHidden: \"ce-toolbar__settings-btn--hidden\"\n    };\n  }\n  /**\n   * Returns the Toolbar opening state\n   *\n   * @returns {boolean}\n   */\n  get opened() {\n    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);\n  }\n  /**\n   * Public interface for accessing the Toolbox\n   */\n  get toolbox() {\n    return {\n      opened: this.toolboxInstance.opened,\n      close: () => {\n        this.toolboxInstance.close();\n      },\n      open: () => {\n        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();\n      },\n      toggle: () => this.toolboxInstance.toggle(),\n      hasFocus: () => this.toolboxInstance.hasFocus()\n    };\n  }\n  /**\n   * Block actions appearance manipulations\n   */\n  get blockActions() {\n    return {\n      hide: () => {\n        this.nodes.actions.classList.remove(this.CSS.actionsOpened);\n      },\n      show: () => {\n        this.nodes.actions.classList.add(this.CSS.actionsOpened);\n      }\n    };\n  }\n  /**\n   * Methods for working with Block Tunes toggler\n   */\n  get blockTunesToggler() {\n    return {\n      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),\n      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)\n    };\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : (this.drawUI(), this.enableModuleBindings());\n  }\n  /**\n   * Move Toolbar to the passed (or current) Block\n   *\n   * @param block - block to move Toolbar near it\n   */\n  moveAndOpen(e = this.Editor.BlockManager.currentBlock) {\n    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e)\n      return;\n    this.hoveredBlock = e;\n    const t = e.holder, { isMobile: o } = this.Editor.UI, i = e.pluginsContent, n = window.getComputedStyle(i), r = parseInt(n.paddingTop, 10), a = t.offsetHeight;\n    let l;\n    o ? l = t.offsetTop + a : l = t.offsetTop + r, this.nodes.wrapper.style.top = `${Math.floor(l)}px`, this.Editor.BlockManager.blocks.length === 1 && e.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();\n  }\n  /**\n   * Close the Toolbar\n   */\n  close() {\n    this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), this.toolboxInstance.close(), this.Editor.BlockSettings.close());\n  }\n  /**\n   * Open Toolbar with Plus Button and Actions\n   *\n   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.\n   *                                     This flag allows to open Toolbar without Actions.\n   */\n  open(e = !0) {\n    oe(() => {\n      this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e ? this.blockActions.show() : this.blockActions.hide();\n    }, 50)();\n  }\n  /**\n   * Draws Toolbar elements\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", this.CSS.toolbar), [\"content\", \"actions\"].forEach((t) => {\n      this.nodes[t] = d.make(\"div\", this.CSS[t]);\n    }), d.append(this.nodes.wrapper, this.nodes.content), d.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d.make(\"div\", this.CSS.plusButton, {\n      innerHTML: Mo\n    }), d.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, \"click\", () => {\n      this.tooltip.hide(!0), this.plusButtonClicked();\n    }, !1);\n    const e = d.make(\"div\");\n    e.appendChild(document.createTextNode($.ui(X.ui.toolbar.toolbox, \"Add\"))), e.appendChild(d.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: \"⇥ Tab\"\n    })), this.tooltip.onHover(this.nodes.plusButton, e, {\n      hidingDelay: 400\n    }), this.nodes.settingsToggler = d.make(\"span\", this.CSS.settingsToggler, {\n      innerHTML: Io\n    }), d.append(this.nodes.actions, this.nodes.settingsToggler), this.tooltip.onHover(\n      this.nodes.settingsToggler,\n      $.ui(X.ui.blockTunes.toggler, \"Click to tune\"),\n      {\n        hidingDelay: 400\n      }\n    ), d.append(this.nodes.actions, this.makeToolbox()), d.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Creates the Toolbox instance and return it's rendered element\n   */\n  makeToolbox() {\n    return this.toolboxInstance = new ze({\n      api: this.Editor.API.methods,\n      tools: this.Editor.Tools.blockTools,\n      i18nLabels: {\n        filter: $.ui(X.ui.popover, \"Filter\"),\n        nothingFound: $.ui(X.ui.popover, \"Nothing found\")\n      }\n    }), this.toolboxInstance.on(be.Opened, () => {\n      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(be.Closed, () => {\n      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(be.BlockAdded, ({ block: e }) => {\n      const { BlockManager: t, Caret: o } = this.Editor, i = t.getBlockById(e.id);\n      i.inputs.length === 0 && (i === t.lastBlock ? (t.insertAtEnd(), o.setToBlock(t.lastBlock)) : o.setToBlock(t.nextBlock));\n    }), this.toolboxInstance.make();\n  }\n  /**\n   * Handler for Plus Button\n   */\n  plusButtonClicked() {\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.toggle();\n  }\n  /**\n   * Enable bindings\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, \"mousedown\", (e) => {\n      e.stopPropagation(), this.settingsTogglerClicked(), this.toolboxInstance.opened && this.toolboxInstance.close(), this.tooltip.hide(!0);\n    }, !0), ee() || this.eventsDispatcher.on(mt, (e) => {\n      this.Editor.BlockSettings.opened || this.toolboxInstance.opened || this.moveAndOpen(e.block);\n    });\n  }\n  /**\n   * Disable bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Clicks on the Block Settings toggler\n   */\n  settingsTogglerClicked() {\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);\n  }\n  /**\n   * Draws Toolbar UI\n   *\n   * Toolbar contains BlockSettings and Toolbox.\n   * That's why at first we draw its components and then Toolbar itself\n   *\n   * Steps:\n   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on\n   *  - Make itself and append dependent nodes to itself\n   *\n   */\n  drawUI() {\n    this.Editor.BlockSettings.make(), this.make();\n  }\n  /**\n   * Removes all created and saved HTMLElements\n   * It is used in Read-Only mode\n   */\n  destroy() {\n    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy(), this.tooltip.destroy();\n  }\n}\nvar ye = /* @__PURE__ */ ((s) => (s[s.Block = 0] = \"Block\", s[s.Inline = 1] = \"Inline\", s[s.Tune = 2] = \"Tune\", s))(ye || {}), me = /* @__PURE__ */ ((s) => (s.Shortcut = \"shortcut\", s.Toolbox = \"toolbox\", s.EnabledInlineTools = \"inlineToolbar\", s.EnabledBlockTunes = \"tunes\", s.Config = \"config\", s))(me || {}), kt = /* @__PURE__ */ ((s) => (s.Shortcut = \"shortcut\", s.SanitizeConfig = \"sanitize\", s))(kt || {}), se = /* @__PURE__ */ ((s) => (s.IsEnabledLineBreaks = \"enableLineBreaks\", s.Toolbox = \"toolbox\", s.ConversionConfig = \"conversionConfig\", s.IsReadOnlySupported = \"isReadOnlySupported\", s.PasteConfig = \"pasteConfig\", s))(se || {}), je = /* @__PURE__ */ ((s) => (s.IsInline = \"isInline\", s.Title = \"title\", s))(je || {}), vt = /* @__PURE__ */ ((s) => (s.IsTune = \"isTune\", s))(vt || {});\nclass Ue {\n  /**\n   * @class\n   * @param {ConstructorOptions} options - Constructor options\n   */\n  constructor({\n    name: e,\n    constructable: t,\n    config: o,\n    api: i,\n    isDefault: n,\n    isInternal: r = !1,\n    defaultPlaceholder: a\n  }) {\n    this.api = i, this.name = e, this.constructable = t, this.config = o, this.isDefault = n, this.isInternal = r, this.defaultPlaceholder = a;\n  }\n  /**\n   * Returns Tool user configuration\n   */\n  get settings() {\n    const e = this.config.config || {};\n    return this.isDefault && !(\"placeholder\" in e) && this.defaultPlaceholder && (e.placeholder = this.defaultPlaceholder), e;\n  }\n  /**\n   * Calls Tool's reset method\n   */\n  reset() {\n    if (D(this.constructable.reset))\n      return this.constructable.reset();\n  }\n  /**\n   * Calls Tool's prepare method\n   */\n  prepare() {\n    if (D(this.constructable.prepare))\n      return this.constructable.prepare({\n        toolName: this.name,\n        config: this.settings\n      });\n  }\n  /**\n   * Returns shortcut for Tool (internal or specified by user)\n   */\n  get shortcut() {\n    const e = this.constructable.shortcut;\n    return this.config.shortcut || e;\n  }\n  /**\n   * Returns Tool's sanitizer configuration\n   */\n  get sanitizeConfig() {\n    return this.constructable.sanitize || {};\n  }\n  /**\n   * Returns true if Tools is inline\n   */\n  isInline() {\n    return this.type === 1;\n  }\n  /**\n   * Returns true if Tools is block\n   */\n  isBlock() {\n    return this.type === 0;\n  }\n  /**\n   * Returns true if Tools is tune\n   */\n  isTune() {\n    return this.type === 2;\n  }\n}\nclass Uo extends S {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.CSS = {\n      inlineToolbar: \"ce-inline-toolbar\",\n      inlineToolbarShowed: \"ce-inline-toolbar--showed\",\n      inlineToolbarLeftOriented: \"ce-inline-toolbar--left-oriented\",\n      inlineToolbarRightOriented: \"ce-inline-toolbar--right-oriented\",\n      inlineToolbarShortcut: \"ce-inline-toolbar__shortcut\",\n      buttonsWrapper: \"ce-inline-toolbar__buttons\",\n      actionsWrapper: \"ce-inline-toolbar__actions\",\n      inlineToolButton: \"ce-inline-tool\",\n      inputField: \"cdx-input\",\n      focusedButton: \"ce-inline-tool--focused\",\n      conversionToggler: \"ce-inline-toolbar__dropdown\",\n      conversionTogglerArrow: \"ce-inline-toolbar__dropdown-arrow\",\n      conversionTogglerHidden: \"ce-inline-toolbar__dropdown--hidden\",\n      conversionTogglerContent: \"ce-inline-toolbar__dropdown-content\",\n      togglerAndButtonsWrapper: \"ce-inline-toolbar__toggler-and-button-wrapper\"\n    }, this.opened = !1, this.toolbarVerticalMargin = ee() ? 20 : 6, this.buttonsList = null, this.width = 0, this.flipper = null, this.tooltip = new Fe();\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? (this.destroy(), this.Editor.ConversionToolbar.destroy()) : this.make();\n  }\n  /**\n   *  Moving / appearance\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Shows Inline Toolbar if something is selected\n   *\n   * @param [needToClose] - pass true to close toolbar if it is not allowed.\n   *                                  Avoid to use it just for closing IT, better call .close() clearly.\n   * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar\n   */\n  tryToShow(e = !1, t = !0) {\n    if (!this.allowedToShow()) {\n      e && this.close();\n      return;\n    }\n    this.move(), this.open(t), this.Editor.Toolbar.close();\n  }\n  /**\n   * Move Toolbar to the selected text\n   */\n  move() {\n    const e = m.rect, t = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), o = {\n      x: e.x - t.left,\n      y: e.y + e.height - // + window.scrollY\n      t.top + this.toolbarVerticalMargin\n    };\n    e.width && (o.x += Math.floor(e.width / 2));\n    const i = o.x - this.width / 2, n = o.x + this.width / 2;\n    this.nodes.wrapper.classList.toggle(\n      this.CSS.inlineToolbarLeftOriented,\n      i < this.Editor.UI.contentRect.left\n    ), this.nodes.wrapper.classList.toggle(\n      this.CSS.inlineToolbarRightOriented,\n      n > this.Editor.UI.contentRect.right\n    ), this.nodes.wrapper.style.left = Math.floor(o.x) + \"px\", this.nodes.wrapper.style.top = Math.floor(o.y) + \"px\";\n  }\n  /**\n   * Hides Inline Toolbar\n   */\n  close() {\n    this.opened && (this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.inlineToolbarShowed), Array.from(this.toolsInstances.entries()).forEach(([e, t]) => {\n      const o = this.getToolShortcut(e);\n      o && re.remove(this.Editor.UI.nodes.redactor, o), D(t.clear) && t.clear();\n    }), this.opened = !1, this.flipper.deactivate(), this.Editor.ConversionToolbar.close()));\n  }\n  /**\n   * Shows Inline Toolbar\n   *\n   * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar\n   */\n  open(e = !0) {\n    if (this.opened)\n      return;\n    this.addToolsFiltered(), this.nodes.wrapper.classList.add(this.CSS.inlineToolbarShowed), this.buttonsList = this.nodes.buttons.querySelectorAll(`.${this.CSS.inlineToolButton}`), this.opened = !0, e && this.Editor.ConversionToolbar.hasTools() ? this.setConversionTogglerContent() : this.nodes.conversionToggler.hidden = !0;\n    let t = Array.from(this.buttonsList);\n    t.unshift(this.nodes.conversionToggler), t = t.filter((o) => !o.hidden), this.flipper.activate(t);\n  }\n  /**\n   * Check if node is contained by Inline Toolbar\n   *\n   * @param {Node} node — node to check\n   */\n  containsNode(e) {\n    return this.nodes.wrapper.contains(e);\n  }\n  /**\n   * Removes UI and its components\n   */\n  destroy() {\n    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes(), this.tooltip.destroy();\n  }\n  /**\n   * Making DOM\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.inlineToolbar,\n      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []\n    ]), this.nodes.togglerAndButtonsWrapper = d.make(\"div\", this.CSS.togglerAndButtonsWrapper), this.nodes.buttons = d.make(\"div\", this.CSS.buttonsWrapper), this.nodes.actions = d.make(\"div\", this.CSS.actionsWrapper), this.listeners.on(this.nodes.wrapper, \"mousedown\", (e) => {\n      e.target.closest(`.${this.CSS.actionsWrapper}`) || e.preventDefault();\n    }), d.append(this.nodes.wrapper, [this.nodes.togglerAndButtonsWrapper, this.nodes.actions]), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper), this.addConversionToggler(), d.append(this.nodes.togglerAndButtonsWrapper, this.nodes.buttons), this.prepareConversionToolbar(), this.recalculateWidth(), this.enableFlipper();\n  }\n  /**\n   * Need to show Inline Toolbar or not\n   */\n  allowedToShow() {\n    const e = [\"IMG\", \"INPUT\"], t = m.get(), o = m.text;\n    if (!t || !t.anchorNode || t.isCollapsed || o.length < 1)\n      return !1;\n    const i = d.isElement(t.anchorNode) ? t.anchorNode : t.anchorNode.parentElement;\n    if (t && e.includes(i.tagName) || i.closest('[contenteditable=\"true\"]') === null)\n      return !1;\n    const r = this.Editor.BlockManager.getBlock(t.anchorNode);\n    return r ? r.tool.inlineTools.size !== 0 : !1;\n  }\n  /**\n   * Recalculate inline toolbar width\n   */\n  recalculateWidth() {\n    this.width = this.nodes.wrapper.offsetWidth;\n  }\n  /**\n   * Create a toggler for Conversion Dropdown\n   * and prepend it to the buttons list\n   */\n  addConversionToggler() {\n    this.nodes.conversionToggler = d.make(\"div\", this.CSS.conversionToggler), this.nodes.conversionTogglerContent = d.make(\"div\", this.CSS.conversionTogglerContent);\n    const e = d.make(\"div\", this.CSS.conversionTogglerArrow, {\n      innerHTML: pt\n    });\n    this.nodes.conversionToggler.appendChild(this.nodes.conversionTogglerContent), this.nodes.conversionToggler.appendChild(e), this.nodes.togglerAndButtonsWrapper.appendChild(this.nodes.conversionToggler), this.listeners.on(this.nodes.conversionToggler, \"click\", () => {\n      this.Editor.ConversionToolbar.toggle((t) => {\n        !t && this.opened ? this.flipper.activate() : this.opened && this.flipper.deactivate();\n      });\n    }), ee() === !1 && this.tooltip.onHover(this.nodes.conversionToggler, $.ui(X.ui.inlineToolbar.converter, \"Convert to\"), {\n      placement: \"top\",\n      hidingDelay: 100\n    });\n  }\n  /**\n   * Changes Conversion Dropdown content for current block's Tool\n   */\n  async setConversionTogglerContent() {\n    const { BlockManager: e } = this.Editor, { currentBlock: t } = e, o = t.name, i = t.tool.conversionConfig, n = i && i.export;\n    this.nodes.conversionToggler.hidden = !n, this.nodes.conversionToggler.classList.toggle(this.CSS.conversionTogglerHidden, !n);\n    const r = await t.getActiveToolboxEntry() || {};\n    this.nodes.conversionTogglerContent.innerHTML = r.icon || r.title || ke(o);\n  }\n  /**\n   * Makes the Conversion Dropdown\n   */\n  prepareConversionToolbar() {\n    const e = this.Editor.ConversionToolbar.make();\n    d.append(this.nodes.wrapper, e);\n  }\n  /**\n   *  Working with Tools\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Append only allowed Tools\n   */\n  addToolsFiltered() {\n    const e = m.get(), t = this.Editor.BlockManager.getBlock(e.anchorNode);\n    this.nodes.buttons.innerHTML = \"\", this.nodes.actions.innerHTML = \"\", this.toolsInstances = /* @__PURE__ */ new Map(), Array.from(t.tool.inlineTools.values()).forEach((o) => {\n      this.addTool(o);\n    }), this.recalculateWidth();\n  }\n  /**\n   * Add tool button and activate clicks\n   *\n   * @param {InlineTool} tool - InlineTool object\n   */\n  addTool(e) {\n    const t = e.create(), o = t.render();\n    if (!o) {\n      T(\"Render method must return an instance of Node\", \"warn\", e.name);\n      return;\n    }\n    if (o.dataset.tool = e.name, this.nodes.buttons.appendChild(o), this.toolsInstances.set(e.name, t), D(t.renderActions)) {\n      const a = t.renderActions();\n      this.nodes.actions.appendChild(a);\n    }\n    this.listeners.on(o, \"click\", (a) => {\n      this.toolClicked(t), a.preventDefault();\n    });\n    const i = this.getToolShortcut(e.name);\n    if (i)\n      try {\n        this.enableShortcuts(t, i);\n      } catch {\n      }\n    const n = d.make(\"div\"), r = $.t(\n      X.toolNames,\n      e.title || ke(e.name)\n    );\n    n.appendChild(d.text(r)), i && n.appendChild(d.make(\"div\", this.CSS.inlineToolbarShortcut, {\n      textContent: nt(i)\n    })), ee() === !1 && this.tooltip.onHover(o, n, {\n      placement: \"top\",\n      hidingDelay: 100\n    }), t.checkState(m.get());\n  }\n  /**\n   * Get shortcut name for tool\n   *\n   * @param toolName — Tool name\n   */\n  getToolShortcut(e) {\n    const { Tools: t } = this.Editor, o = t.inlineTools.get(e), i = t.internal.inlineTools;\n    return Array.from(i.keys()).includes(e) ? this.inlineTools[e][kt.Shortcut] : o.shortcut;\n  }\n  /**\n   * Enable Tool shortcut with Editor Shortcuts Module\n   *\n   * @param {InlineTool} tool - Tool instance\n   * @param {string} shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcuts(e, t) {\n    re.add({\n      name: t,\n      handler: (o) => {\n        const { currentBlock: i } = this.Editor.BlockManager;\n        i && i.tool.enabledInlineTools && (o.preventDefault(), this.toolClicked(e));\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Inline Tool button clicks\n   *\n   * @param {InlineTool} tool - Tool's instance\n   */\n  toolClicked(e) {\n    const t = m.range;\n    e.surround(t), this.checkToolsState(), e.renderActions !== void 0 && this.flipper.deactivate();\n  }\n  /**\n   * Check Tools` state by selection\n   */\n  checkToolsState() {\n    this.toolsInstances.forEach((e) => {\n      e.checkState(m.get());\n    });\n  }\n  /**\n   * Get inline tools tools\n   * Tools that has isInline is true\n   */\n  get inlineTools() {\n    const e = {};\n    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t, o]) => {\n      e[t] = o.create();\n    }), e;\n  }\n  /**\n   * Allow to leaf buttons by arrows / tab\n   * Buttons will be filled on opening\n   */\n  enableFlipper() {\n    this.flipper = new G({\n      focusedItemClass: this.CSS.focusedButton,\n      allowedKeys: [\n        B.ENTER,\n        B.TAB\n      ]\n    });\n  }\n}\nclass $o extends S {\n  /**\n   * All keydowns on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  keydown(e) {\n    switch (this.beforeKeydownProcessing(e), e.keyCode) {\n      case B.BACKSPACE:\n        this.backspace(e);\n        break;\n      case B.ENTER:\n        this.enter(e);\n        break;\n      case B.DOWN:\n      case B.RIGHT:\n        this.arrowRightAndDown(e);\n        break;\n      case B.UP:\n      case B.LEFT:\n        this.arrowLeftAndUp(e);\n        break;\n      case B.TAB:\n        this.tabPressed(e);\n        break;\n    }\n  }\n  /**\n   * Fires on keydown before event processing\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  beforeKeydownProcessing(e) {\n    this.needToolbarClosing(e) && tt(e.keyCode) && (this.Editor.Toolbar.close(), this.Editor.ConversionToolbar.close(), e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || (this.Editor.BlockManager.clearFocused(), this.Editor.BlockSelection.clearSelection(e)));\n  }\n  /**\n   * Key up on Block:\n   * - shows Inline Toolbar if something selected\n   * - shows conversion toolbar with 85% of block selection\n   *\n   * @param {KeyboardEvent} event - keyup event\n   */\n  keyup(e) {\n    e.shiftKey || this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Open Toolbox to leaf Tools\n   *\n   * @param {KeyboardEvent} event - tab keydown event\n   */\n  tabPressed(e) {\n    this.Editor.BlockSelection.clearSelection(e);\n    const { BlockManager: t, InlineToolbar: o, ConversionToolbar: i } = this.Editor, n = t.currentBlock;\n    if (!n)\n      return;\n    const r = n.isEmpty, a = n.tool.isDefault && r, l = !r && i.opened, c = !r && !m.isCollapsed && o.opened;\n    a ? this.activateToolbox() : !l && !c && this.activateBlockSettings();\n  }\n  /**\n   * Add drop target styles\n   *\n   * @param {DragEvent} event - drag over event\n   */\n  dragOver(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !0;\n  }\n  /**\n   * Remove drop target style\n   *\n   * @param {DragEvent} event - drag leave event\n   */\n  dragLeave(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !1;\n  }\n  /**\n   * Copying selected blocks\n   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandC(e) {\n    const { BlockSelection: t } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e);\n  }\n  /**\n   * Copy and Delete selected Blocks\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandX(e) {\n    const { BlockSelection: t, BlockManager: o, Caret: i } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e).then(() => {\n      const n = o.removeSelectedBlocks(), r = o.insertDefaultBlockAtIndex(n, !0);\n      i.setToBlock(r, i.positions.START), t.clearSelection(e);\n    });\n  }\n  /**\n   * ENTER pressed on block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  enter(e) {\n    const { BlockManager: t, UI: o } = this.Editor;\n    if (t.currentBlock.tool.isLineBreaksEnabled || o.someToolbarOpened && o.someFlipperButtonFocused || e.shiftKey)\n      return;\n    let n = this.Editor.BlockManager.currentBlock;\n    this.Editor.Caret.isAtStart && !this.Editor.BlockManager.currentBlock.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : this.Editor.Caret.isAtEnd ? n = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : n = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(n), this.Editor.Toolbar.moveAndOpen(n), e.preventDefault();\n  }\n  /**\n   * Handle backspace keydown on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  backspace(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor, n = t.currentBlock, r = n.tool;\n    if (n.selected || n.isEmpty && n.currentInput === n.firstInput) {\n      e.preventDefault();\n      const c = t.currentBlockIndex;\n      t.previousBlock && t.previousBlock.inputs.length === 0 ? t.removeBlock(c - 1) : t.removeBlock(), i.setToBlock(\n        t.currentBlock,\n        c ? i.positions.END : i.positions.START\n      ), this.Editor.Toolbar.close(), o.clearSelection(e);\n      return;\n    }\n    if (r.isLineBreaksEnabled && !i.isAtStart)\n      return;\n    const a = t.currentBlockIndex === 0;\n    i.isAtStart && m.isCollapsed && n.currentInput === n.firstInput && !a && (e.preventDefault(), this.mergeBlocks());\n  }\n  /**\n   * Merge current and previous Blocks if they have the same type\n   */\n  mergeBlocks() {\n    const { BlockManager: e, Caret: t, Toolbar: o } = this.Editor, i = e.previousBlock, n = e.currentBlock;\n    if (n.name !== i.name || !i.mergeable) {\n      if (i.inputs.length === 0 || i.isEmpty) {\n        e.removeBlock(e.currentBlockIndex - 1), t.setToBlock(e.currentBlock), o.close();\n        return;\n      }\n      t.navigatePrevious() && o.close();\n      return;\n    }\n    t.createShadow(i.pluginsContent), e.mergeBlocks(i, n).then(() => {\n      t.restoreCaret(i.pluginsContent), i.pluginsContent.normalize(), o.close();\n    });\n  }\n  /**\n   * Handle right and down keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowRightAndDown(e) {\n    const t = G.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === B.TAB);\n    if (this.Editor.UI.someToolbarOpened && t)\n      return;\n    this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();\n    const o = this.Editor.Caret.isAtEnd || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === B.DOWN && o) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState();\n      return;\n    }\n    (e.keyCode === B.DOWN || e.keyCode === B.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) ? e.preventDefault() : oe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Handle left and up keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowLeftAndUp(e) {\n    if (this.Editor.UI.someToolbarOpened) {\n      if (G.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === B.TAB))\n        return;\n      this.Editor.UI.closeAllToolbars();\n    }\n    this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();\n    const t = this.Editor.Caret.isAtStart || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === B.UP && t) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState(!1);\n      return;\n    }\n    (e.keyCode === B.UP || e.keyCode === B.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) ? e.preventDefault() : oe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Cases when we need to close Toolbar\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  needToolbarClosing(e) {\n    const t = e.keyCode === B.ENTER && this.Editor.Toolbar.toolbox.opened, o = e.keyCode === B.ENTER && this.Editor.BlockSettings.opened, i = e.keyCode === B.ENTER && this.Editor.InlineToolbar.opened, n = e.keyCode === B.ENTER && this.Editor.ConversionToolbar.opened, r = e.keyCode === B.TAB;\n    return !(e.shiftKey || r || t || o || i || n);\n  }\n  /**\n   * If Toolbox is not open, then just open it and show plus button\n   */\n  activateToolbox() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();\n  }\n  /**\n   * Open Toolbar and show BlockSettings before flipping Tools\n   */\n  activateBlockSettings() {\n    this.Editor.Toolbar.opened || (this.Editor.BlockManager.currentBlock.focused = !0, this.Editor.Toolbar.moveAndOpen()), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();\n  }\n}\nclass Ce {\n  /**\n   * @class\n   * @param {HTMLElement} workingArea — editor`s working node\n   */\n  constructor(e) {\n    this.blocks = [], this.workingArea = e;\n  }\n  /**\n   * Get length of Block instances array\n   *\n   * @returns {number}\n   */\n  get length() {\n    return this.blocks.length;\n  }\n  /**\n   * Get Block instances array\n   *\n   * @returns {Block[]}\n   */\n  get array() {\n    return this.blocks;\n  }\n  /**\n   * Get blocks html elements array\n   *\n   * @returns {HTMLElement[]}\n   */\n  get nodes() {\n    return it(this.workingArea.children);\n  }\n  /**\n   * Proxy trap to implement array-like setter\n   *\n   * @example\n   * blocks[0] = new Block(...)\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — block index or any Blocks class property key to set\n   * @param {Block} value — value to set\n   * @returns {boolean}\n   */\n  static set(e, t, o) {\n    return isNaN(Number(t)) ? (Reflect.set(e, t, o), !0) : (e.insert(+t, o), !0);\n  }\n  /**\n   * Proxy trap to implement array-like getter\n   *\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — Blocks class property key\n   * @returns {Block|*}\n   */\n  static get(e, t) {\n    return isNaN(Number(t)) ? Reflect.get(e, t) : e.get(+t);\n  }\n  /**\n   * Push new Block to the blocks array and append it to working area\n   *\n   * @param {Block} block - Block to add\n   */\n  push(e) {\n    this.blocks.push(e), this.insertToDOM(e);\n  }\n  /**\n   * Swaps blocks with indexes first and second\n   *\n   * @param {number} first - first block index\n   * @param {number} second - second block index\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    const o = this.blocks[t];\n    d.swap(this.blocks[e].holder, o.holder), this.blocks[t] = this.blocks[e], this.blocks[e] = o;\n  }\n  /**\n   * Move a block from one to another index\n   *\n   * @param {number} toIndex - new index of the block\n   * @param {number} fromIndex - block to move\n   */\n  move(e, t) {\n    const o = this.blocks.splice(t, 1)[0], i = e - 1, n = Math.max(0, i), r = this.blocks[n];\n    e > 0 ? this.insertToDOM(o, \"afterend\", r) : this.insertToDOM(o, \"beforebegin\", r), this.blocks.splice(e, 0, o);\n    const a = this.composeBlockEvent(\"move\", {\n      fromIndex: t,\n      toIndex: e\n    });\n    o.call(q.MOVED, a);\n  }\n  /**\n   * Insert new Block at passed index\n   *\n   * @param {number} index — index to insert Block\n   * @param {Block} block — Block to insert\n   * @param {boolean} replace — it true, replace block on given index\n   */\n  insert(e, t, o = !1) {\n    if (!this.length) {\n      this.push(t);\n      return;\n    }\n    e > this.length && (e = this.length), o && (this.blocks[e].holder.remove(), this.blocks[e].call(q.REMOVED));\n    const i = o ? 1 : 0;\n    if (this.blocks.splice(e, i, t), e > 0) {\n      const n = this.blocks[e - 1];\n      this.insertToDOM(t, \"afterend\", n);\n    } else {\n      const n = this.blocks[e + 1];\n      n ? this.insertToDOM(t, \"beforebegin\", n) : this.insertToDOM(t);\n    }\n  }\n  /**\n   * Remove block\n   *\n   * @param {number} index - index of Block to remove\n   */\n  remove(e) {\n    isNaN(e) && (e = this.length - 1), this.blocks[e].holder.remove(), this.blocks[e].call(q.REMOVED), this.blocks.splice(e, 1);\n  }\n  /**\n   * Remove all blocks\n   */\n  removeAll() {\n    this.workingArea.innerHTML = \"\", this.blocks.forEach((e) => e.call(q.REMOVED)), this.blocks.length = 0;\n  }\n  /**\n   * Insert Block after passed target\n   *\n   * @todo decide if this method is necessary\n   * @param {Block} targetBlock — target after which Block should be inserted\n   * @param {Block} newBlock — Block to insert\n   */\n  insertAfter(e, t) {\n    const o = this.blocks.indexOf(e);\n    this.insert(o + 1, t);\n  }\n  /**\n   * Get Block by index\n   *\n   * @param {number} index — Block index\n   * @returns {Block}\n   */\n  get(e) {\n    return this.blocks[e];\n  }\n  /**\n   * Return index of passed Block\n   *\n   * @param {Block} block - Block to find\n   * @returns {number}\n   */\n  indexOf(e) {\n    return this.blocks.indexOf(e);\n  }\n  /**\n   * Insert new Block into DOM\n   *\n   * @param {Block} block - Block to insert\n   * @param {InsertPosition} position — insert position (if set, will use insertAdjacentElement)\n   * @param {Block} target — Block related to position\n   */\n  insertToDOM(e, t, o) {\n    t ? o.holder.insertAdjacentElement(t, e.holder) : this.workingArea.appendChild(e.holder), e.call(q.RENDERED);\n  }\n  /**\n   * Composes Block event with passed type and details\n   *\n   * @param {string} type - event type\n   * @param {object} detail - event detail\n   */\n  composeBlockEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n}\nconst Je = \"block-removed\", Qe = \"block-added\", Wo = \"block-moved\", Yo = \"block-changed\";\nclass Ko extends S {\n  constructor() {\n    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;\n  }\n  /**\n   * Returns current Block index\n   *\n   * @returns {number}\n   */\n  get currentBlockIndex() {\n    return this._currentBlockIndex;\n  }\n  /**\n   * Set current Block index and fire Block lifecycle callbacks\n   *\n   * @param {number} newIndex - index of Block to set as current\n   */\n  set currentBlockIndex(e) {\n    this._currentBlockIndex = e;\n  }\n  /**\n   * returns first Block\n   *\n   * @returns {Block}\n   */\n  get firstBlock() {\n    return this._blocks[0];\n  }\n  /**\n   * returns last Block\n   *\n   * @returns {Block}\n   */\n  get lastBlock() {\n    return this._blocks[this._blocks.length - 1];\n  }\n  /**\n   * Get current Block instance\n   *\n   * @returns {Block}\n   */\n  get currentBlock() {\n    return this._blocks[this.currentBlockIndex];\n  }\n  /**\n   * Set passed Block as a current\n   *\n   * @param block - block to set as a current\n   */\n  set currentBlock(e) {\n    this.currentBlockIndex = this.getBlockIndex(e);\n  }\n  /**\n   * Returns next Block instance\n   *\n   * @returns {Block|null}\n   */\n  get nextBlock() {\n    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];\n  }\n  /**\n   * Return first Block with inputs after current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get nextContentfulBlock() {\n    return this.blocks.slice(this.currentBlockIndex + 1).find((t) => !!t.inputs.length);\n  }\n  /**\n   * Return first Block with inputs before current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get previousContentfulBlock() {\n    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t) => !!t.inputs.length);\n  }\n  /**\n   * Returns previous Block instance\n   *\n   * @returns {Block|null}\n   */\n  get previousBlock() {\n    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];\n  }\n  /**\n   * Get array of Block instances\n   *\n   * @returns {Block[]} {@link Blocks#array}\n   */\n  get blocks() {\n    return this._blocks.array;\n  }\n  /**\n   * Check if each Block is empty\n   *\n   * @returns {boolean}\n   */\n  get isEditorEmpty() {\n    return this.blocks.every((e) => e.isEmpty);\n  }\n  /**\n   * Should be called after Editor.UI preparation\n   * Define this._blocks property\n   */\n  prepare() {\n    const e = new Ce(this.Editor.UI.nodes.redactor);\n    this._blocks = new Proxy(e, {\n      set: Ce.set,\n      get: Ce.get\n    }), this.listeners.on(\n      document,\n      \"copy\",\n      (t) => this.Editor.BlockEvents.handleCommandC(t)\n    );\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - Unbind event handlers from created Blocks\n   *\n   * if readOnly is false:\n   *  - Bind event handlers to all existing Blocks\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Creates Block instance by tool name\n   *\n   * @param {object} options - block creation options\n   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}\n   * @param {string} [options.id] - unique id for this block\n   * @param {BlockToolData} [options.data] - constructor params\n   * @returns {Block}\n   */\n  composeBlock({\n    tool: e,\n    data: t = {},\n    id: o = void 0,\n    tunes: i = {}\n  }) {\n    const n = this.Editor.ReadOnly.isEnabled, r = this.Editor.Tools.blockTools.get(e), a = new F({\n      id: o,\n      data: t,\n      tool: r,\n      api: this.Editor.API,\n      readOnly: n,\n      tunesData: i\n    }, this.eventsDispatcher);\n    return n || this.bindBlockEvents(a), a;\n  }\n  /**\n   * Insert new block into _blocks\n   *\n   * @param {object} options - insert options\n   * @param {string} [options.id] - block's unique id\n   * @param {string} [options.tool] - plugin name, by default method inserts the default block type\n   * @param {object} [options.data] - plugin data\n   * @param {number} [options.index] - index where to insert new Block\n   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index\n   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one\n   * @returns {Block}\n   */\n  insert({\n    id: e = void 0,\n    tool: t = this.config.defaultBlock,\n    data: o = {},\n    index: i,\n    needToFocus: n = !0,\n    replace: r = !1,\n    tunes: a = {}\n  } = {}) {\n    let l = i;\n    l === void 0 && (l = this.currentBlockIndex + (r ? 0 : 1));\n    const c = this.composeBlock({\n      id: e,\n      tool: t,\n      data: o,\n      tunes: a\n    });\n    return r && this.blockDidMutated(Je, this.getBlockByIndex(l), {\n      index: l\n    }), this._blocks.insert(l, c, r), this.blockDidMutated(Qe, c, {\n      index: l\n    }), n ? this.currentBlockIndex = l : l <= this.currentBlockIndex && this.currentBlockIndex++, c;\n  }\n  /**\n   * Replace current working block\n   *\n   * @param {object} options - replace options\n   * @param {string} options.tool — plugin name\n   * @param {BlockToolData} options.data — plugin data\n   * @returns {Block}\n   */\n  replace({\n    tool: e = this.config.defaultBlock,\n    data: t = {}\n  }) {\n    return this.insert({\n      tool: e,\n      data: t,\n      index: this.currentBlockIndex,\n      replace: !0\n    });\n  }\n  /**\n   * Insert pasted content. Call onPaste callback after insert.\n   *\n   * @param {string} toolName - name of Tool to insert\n   * @param {PasteEvent} pasteEvent - pasted data\n   * @param {boolean} replace - should replace current block\n   */\n  paste(e, t, o = !1) {\n    const i = this.insert({\n      tool: e,\n      replace: o\n    });\n    try {\n      i.call(q.ON_PASTE, t);\n    } catch (n) {\n      T(`${e}: onPaste callback call is failed`, \"error\", n);\n    }\n    return i;\n  }\n  /**\n   * Insert new default block at passed index\n   *\n   * @param {number} index - index where Block should be inserted\n   * @param {boolean} needToFocus - if true, updates current Block index\n   *\n   * TODO: Remove method and use insert() with index instead (?)\n   * @returns {Block} inserted Block\n   */\n  insertDefaultBlockAtIndex(e, t = !1) {\n    const o = this.composeBlock({ tool: this.config.defaultBlock });\n    return this._blocks[e] = o, this.blockDidMutated(Qe, o, {\n      index: e\n    }), t ? this.currentBlockIndex = e : e <= this.currentBlockIndex && this.currentBlockIndex++, o;\n  }\n  /**\n   * Always inserts at the end\n   *\n   * @returns {Block}\n   */\n  insertAtEnd() {\n    return this.currentBlockIndex = this.blocks.length - 1, this.insert();\n  }\n  /**\n   * Merge two blocks\n   *\n   * @param {Block} targetBlock - previous block will be append to this block\n   * @param {Block} blockToMerge - block that will be merged with target block\n   * @returns {Promise} - the sequence that can be continued\n   */\n  async mergeBlocks(e, t) {\n    const o = this._blocks.indexOf(t);\n    if (t.isEmpty)\n      return;\n    const i = await t.data;\n    V(i) || await e.mergeWith(i), this.removeBlock(o), this.currentBlockIndex = this._blocks.indexOf(e);\n  }\n  /**\n   * Remove block with passed index or remove last\n   *\n   * @param {number|null} index - index of Block to remove\n   * @throws {Error} if Block to remove is not found\n   */\n  removeBlock(e = this.currentBlockIndex) {\n    if (!this.validateIndex(e))\n      throw new Error(\"Can't find a Block to remove\");\n    const t = this._blocks[e];\n    t.destroy(), this._blocks.remove(e), this.blockDidMutated(Je, t, {\n      index: e\n    }), this.currentBlockIndex >= e && this.currentBlockIndex--, this.blocks.length ? e === 0 && (this.currentBlockIndex = 0) : (this.currentBlockIndex = -1, this.insert());\n  }\n  /**\n   * Remove only selected Blocks\n   * and returns first Block index where started removing...\n   *\n   * @returns {number|undefined}\n   */\n  removeSelectedBlocks() {\n    let e;\n    for (let t = this.blocks.length - 1; t >= 0; t--)\n      this.blocks[t].selected && (this.removeBlock(t), e = t);\n    return e;\n  }\n  /**\n   * Attention!\n   * After removing insert the new default typed Block and focus on it\n   * Removes all blocks\n   */\n  removeAllBlocks() {\n    for (let e = this.blocks.length - 1; e >= 0; e--)\n      this._blocks.remove(e);\n    this.currentBlockIndex = -1, this.insert(), this.currentBlock.firstInput.focus();\n  }\n  /**\n   * Split current Block\n   * 1. Extract content from Caret position to the Block`s end\n   * 2. Insert a new Block below current one with extracted content\n   *\n   * @returns {Block}\n   */\n  split() {\n    const e = this.Editor.Caret.extractFragmentFromCaretPosition(), t = d.make(\"div\");\n    t.appendChild(e);\n    const o = {\n      text: d.isEmpty(t) ? \"\" : t.innerHTML\n    };\n    return this.insert({ data: o });\n  }\n  /**\n   * Returns Block by passed index\n   *\n   * @param {number} index - index to get. -1 to get last\n   * @returns {Block}\n   */\n  getBlockByIndex(e) {\n    return e === -1 && (e = this._blocks.length - 1), this._blocks[e];\n  }\n  /**\n   * Returns an index for passed Block\n   *\n   * @param block - block to find index\n   */\n  getBlockIndex(e) {\n    return this._blocks.indexOf(e);\n  }\n  /**\n   * Returns the Block by passed id\n   *\n   * @param id - id of block to get\n   * @returns {Block}\n   */\n  getBlockById(e) {\n    return this._blocks.array.find((t) => t.id === e);\n  }\n  /**\n   * Get Block instance by html element\n   *\n   * @param {Node} element - html element to get Block by\n   */\n  getBlock(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = this._blocks.nodes, o = e.closest(`.${F.CSS.wrapper}`), i = t.indexOf(o);\n    if (i >= 0)\n      return this._blocks[i];\n  }\n  /**\n   * Remove selection from all Blocks then highlight only Current Block\n   */\n  highlightCurrentNode() {\n    this.clearFocused(), this.currentBlock.focused = !0;\n  }\n  /**\n   * Remove selection from all Blocks\n   */\n  clearFocused() {\n    this.blocks.forEach((e) => {\n      e.focused = !1;\n    });\n  }\n  /**\n   * 1) Find first-level Block from passed child Node\n   * 2) Mark it as current\n   *\n   * @param {Node} childNode - look ahead from this node.\n   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance\n   */\n  setCurrentBlockByChildNode(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${F.CSS.wrapper}`);\n    if (!t)\n      return;\n    const o = t.closest(`.${this.Editor.UI.CSS.editorWrapper}`);\n    if (o != null && o.isEqualNode(this.Editor.UI.nodes.wrapper))\n      return this.currentBlockIndex = this._blocks.nodes.indexOf(t), this.currentBlock.updateCurrentInput(), this.currentBlock;\n  }\n  /**\n   * Return block which contents passed node\n   *\n   * @param {Node} childNode - node to get Block by\n   * @returns {Block}\n   */\n  getBlockByChildNode(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${F.CSS.wrapper}`);\n    return this.blocks.find((o) => o.holder === t);\n  }\n  /**\n   * Swap Blocks Position\n   *\n   * @param {number} fromIndex - index of first block\n   * @param {number} toIndex - index of second block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    this._blocks.swap(e, t), this.currentBlockIndex = t;\n  }\n  /**\n   * Move a block to a new index\n   *\n   * @param {number} toIndex - index where to move Block\n   * @param {number} fromIndex - index of Block to move\n   */\n  move(e, t = this.currentBlockIndex) {\n    if (isNaN(e) || isNaN(t)) {\n      T(\"Warning during 'move' call: incorrect indices provided.\", \"warn\");\n      return;\n    }\n    if (!this.validateIndex(e) || !this.validateIndex(t)) {\n      T(\"Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.\", \"warn\");\n      return;\n    }\n    this._blocks.move(e, t), this.currentBlockIndex = e, this.blockDidMutated(Wo, this.currentBlock, {\n      fromIndex: t,\n      toIndex: e\n    });\n  }\n  /**\n   * Sets current Block Index -1 which means unknown\n   * and clear highlights\n   */\n  dropPointer() {\n    this.currentBlockIndex = -1, this.clearFocused();\n  }\n  /**\n   * Clears Editor\n   *\n   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)\n   *                                             we don't need to add an empty default block\n   *                                        2) in api.blocks.clear we should add empty block\n   */\n  clear(e = !1) {\n    this._blocks.removeAll(), this.dropPointer(), e && this.insert(), this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Cleans up all the block tools' resources\n   * This is called when editor is destroyed\n   */\n  async destroy() {\n    await Promise.all(this.blocks.map((e) => e.destroy()));\n  }\n  /**\n   * Bind Block events\n   *\n   * @param {Block} block - Block to which event should be bound\n   */\n  bindBlockEvents(e) {\n    const { BlockEvents: t } = this.Editor;\n    this.readOnlyMutableListeners.on(e.holder, \"keydown\", (o) => {\n      t.keydown(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"keyup\", (o) => {\n      t.keyup(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragover\", (o) => {\n      t.dragOver(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragleave\", (o) => {\n      t.dragLeave(o);\n    }), e.on(\"didMutated\", (o) => this.blockDidMutated(Yo, o, {\n      index: this.getBlockIndex(o)\n    }));\n  }\n  /**\n   * Disable mutable handlers and bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Enables all module handlers and bindings for all Blocks\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(\n      document,\n      \"cut\",\n      (e) => this.Editor.BlockEvents.handleCommandX(e)\n    ), this.blocks.forEach((e) => {\n      this.bindBlockEvents(e);\n    });\n  }\n  /**\n   * Validates that the given index is not lower than 0 or higher than the amount of blocks\n   *\n   * @param {number} index - index of blocks array to validate\n   * @returns {boolean}\n   */\n  validateIndex(e) {\n    return !(e < 0 || e >= this._blocks.length);\n  }\n  /**\n   * Block mutation callback\n   *\n   * @param mutationType - what happened with block\n   * @param block - mutated block\n   * @param detailData - additional data to pass with change event\n   */\n  blockDidMutated(e, t, o) {\n    const i = new CustomEvent(e, {\n      detail: {\n        target: new he(t),\n        ...o\n      }\n    });\n    return this.eventsDispatcher.emit(lt, {\n      event: i\n    }), t;\n  }\n}\nclass Xo extends S {\n  constructor() {\n    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n  }\n  /**\n   * Sanitizer Config\n   *\n   * @returns {SanitizerConfig}\n   */\n  get sanitizerConfig() {\n    return {\n      p: {},\n      h1: {},\n      h2: {},\n      h3: {},\n      h4: {},\n      h5: {},\n      h6: {},\n      ol: {},\n      ul: {},\n      li: {},\n      br: !0,\n      img: {\n        src: !0,\n        width: !0,\n        height: !0\n      },\n      a: {\n        href: !0\n      },\n      b: {},\n      i: {},\n      u: {}\n    };\n  }\n  /**\n   * Flag that identifies all Blocks selection\n   *\n   * @returns {boolean}\n   */\n  get allBlocksSelected() {\n    const { BlockManager: e } = this.Editor;\n    return e.blocks.every((t) => t.selected === !0);\n  }\n  /**\n   * Set selected all blocks\n   *\n   * @param {boolean} state - state to set\n   */\n  set allBlocksSelected(e) {\n    const { BlockManager: t } = this.Editor;\n    t.blocks.forEach((o) => {\n      o.selected = e;\n    }), this.clearCache();\n  }\n  /**\n   * Flag that identifies any Block selection\n   *\n   * @returns {boolean}\n   */\n  get anyBlockSelected() {\n    const { BlockManager: e } = this.Editor;\n    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e.blocks.some((t) => t.selected === !0)), this.anyBlockSelectedCache;\n  }\n  /**\n   * Return selected Blocks array\n   *\n   * @returns {Block[]}\n   */\n  get selectedBlocks() {\n    return this.Editor.BlockManager.blocks.filter((e) => e.selected);\n  }\n  /**\n   * Module Preparation\n   * Registers Shortcuts CMD+A and CMD+C\n   * to select all and copy them\n   */\n  prepare() {\n    this.selection = new m(), re.add({\n      name: \"CMD+A\",\n      handler: (e) => {\n        const { BlockManager: t, ReadOnly: o } = this.Editor;\n        if (o.isEnabled) {\n          e.preventDefault(), this.selectAllBlocks();\n          return;\n        }\n        t.currentBlock && this.handleCommandA(e);\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Toggle read-only state\n   *\n   *  - Remove all ranges\n   *  - Unselect all Blocks\n   */\n  toggleReadOnly() {\n    m.get().removeAllRanges(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Remove selection of Block\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  unSelectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    isNaN(e) ? o = t.currentBlock : o = t.getBlockByIndex(e), o.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear selection from Blocks\n   *\n   * @param {Event} reason - event caused clear of selection\n   * @param {boolean} restoreSelection - if true, restore saved selection\n   */\n  clearSelection(e, t = !1) {\n    const { BlockManager: o, Caret: i, RectangleSelection: n } = this.Editor;\n    this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n    const r = e && e instanceof KeyboardEvent, a = r && tt(e.keyCode);\n    if (this.anyBlockSelected && r && a && !m.isSelectionExists) {\n      const l = o.removeSelectedBlocks();\n      o.insertDefaultBlockAtIndex(l, !0), i.setToBlock(o.currentBlock), oe(() => {\n        const c = e.key;\n        i.insertContentAtCaretPosition(c.length > 1 ? \"\" : c);\n      }, 20)();\n    }\n    if (this.Editor.CrossBlockSelection.clear(e), !this.anyBlockSelected || n.isRectActivated()) {\n      this.Editor.RectangleSelection.clearSelection();\n      return;\n    }\n    t && this.selection.restore(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Reduce each Block and copy its content\n   *\n   * @param {ClipboardEvent} e - copy/cut event\n   * @returns {Promise<void>}\n   */\n  copySelectedBlocks(e) {\n    e.preventDefault();\n    const t = d.make(\"div\");\n    this.selectedBlocks.forEach((n) => {\n      const r = Z(n.holder.innerHTML, this.sanitizerConfig), a = d.make(\"p\");\n      a.innerHTML = r, t.appendChild(a);\n    });\n    const o = Array.from(t.childNodes).map((n) => n.textContent).join(`\n\n`), i = t.innerHTML;\n    return e.clipboardData.setData(\"text/plain\", o), e.clipboardData.setData(\"text/html\", i), Promise.all(this.selectedBlocks.map((n) => n.save())).then((n) => {\n      try {\n        e.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(n));\n      } catch {\n      }\n    });\n  }\n  /**\n   * select Block\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  selectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor;\n    t.clearFocused();\n    let o;\n    isNaN(e) ? o = t.currentBlock : o = t.getBlockByIndex(e), this.selection.save(), m.get().removeAllRanges(), o.selected = !0, this.clearCache(), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Clear anyBlockSelected cache\n   */\n  clearCache() {\n    this.anyBlockSelectedCache = null;\n  }\n  /**\n   * Module destruction\n   * De-registers Shortcut CMD+A\n   */\n  destroy() {\n    re.remove(this.Editor.UI.nodes.redactor, \"CMD+A\");\n  }\n  /**\n   * First CMD+A selects all input content by native behaviour,\n   * next CMD+A keypress selects all blocks\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  handleCommandA(e) {\n    if (this.Editor.RectangleSelection.clearSelection(), d.isNativeInput(e.target) && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    const o = this.Editor.BlockManager.getBlock(e.target).inputs;\n    if (o.length > 1 && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    if (o.length === 1 && !this.needToSelectAll) {\n      this.needToSelectAll = !0;\n      return;\n    }\n    this.needToSelectAll ? (e.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = !1, this.readyToBlockSelection = !1, this.Editor.ConversionToolbar.close()) : this.readyToBlockSelection && (e.preventDefault(), this.selectBlockByIndex(), this.needToSelectAll = !0);\n  }\n  /**\n   * Select All Blocks\n   * Each Block has selected setter that makes Block copyable\n   */\n  selectAllBlocks() {\n    this.selection.save(), m.get().removeAllRanges(), this.allBlocksSelected = !0, this.Editor.InlineToolbar.close();\n  }\n}\nclass ve extends S {\n  /**\n   * Allowed caret positions in input\n   *\n   * @static\n   * @returns {{START: string, END: string, DEFAULT: string}}\n   */\n  get positions() {\n    return {\n      START: \"start\",\n      END: \"end\",\n      DEFAULT: \"default\"\n    };\n  }\n  /**\n   * Elements styles that can be useful for Caret Module\n   */\n  static get CSS() {\n    return {\n      shadowCaret: \"cdx-shadow-caret\"\n    };\n  }\n  /**\n   * Get's deepest first node and checks if offset is zero\n   *\n   * @returns {boolean}\n   */\n  get isAtStart() {\n    const e = m.get(), t = d.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput);\n    let o = e.focusNode;\n    if (d.isNativeInput(t))\n      return t.selectionEnd === 0;\n    if (!e.anchorNode)\n      return !1;\n    let i = o.textContent.search(/\\S/);\n    i === -1 && (i = 0);\n    let n = e.focusOffset;\n    return o.nodeType !== Node.TEXT_NODE && o.childNodes.length && (o.childNodes[n] ? (o = o.childNodes[n], n = 0) : (o = o.childNodes[n - 1], n = o.textContent.length)), (d.isLineBreakTag(t) || d.isEmpty(t)) && this.getHigherLevelSiblings(o, \"left\").every((l) => {\n      const c = d.isLineBreakTag(l), u = l.children.length === 1 && d.isLineBreakTag(l.children[0]), h = c || u;\n      return d.isEmpty(l) && !h;\n    }) && n === i ? !0 : t === null || o === t && n <= i;\n  }\n  /**\n   * Get's deepest last node and checks if offset is last node text length\n   *\n   * @returns {boolean}\n   */\n  get isAtEnd() {\n    const e = m.get();\n    let t = e.focusNode;\n    const o = d.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput, !0);\n    if (d.isNativeInput(o))\n      return o.selectionEnd === o.value.length;\n    if (!e.focusNode)\n      return !1;\n    let i = e.focusOffset;\n    if (t.nodeType !== Node.TEXT_NODE && t.childNodes.length && (t.childNodes[i - 1] ? (t = t.childNodes[i - 1], i = t.textContent.length) : (t = t.childNodes[0], i = 0)), d.isLineBreakTag(o) || d.isEmpty(o)) {\n      const r = this.getHigherLevelSiblings(t, \"right\");\n      if (r.every((l, c) => c === r.length - 1 && d.isLineBreakTag(l) || d.isEmpty(l) && !d.isLineBreakTag(l)) && i === t.textContent.length)\n        return !0;\n    }\n    const n = o.textContent.replace(/\\s+$/, \"\");\n    return t === o && i >= n.length;\n  }\n  /**\n   * Method gets Block instance and puts caret to the text node with offset\n   * There two ways that method applies caret position:\n   *   - first found text node: sets at the beginning, but you can pass an offset\n   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour\n   *\n   * @param {Block} block - Block class\n   * @param {string} position - position where to set caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToBlock(e, t = this.positions.DEFAULT, o = 0) {\n    const { BlockManager: i } = this.Editor;\n    let n;\n    switch (t) {\n      case this.positions.START:\n        n = e.firstInput;\n        break;\n      case this.positions.END:\n        n = e.lastInput;\n        break;\n      default:\n        n = e.currentInput;\n    }\n    if (!n)\n      return;\n    const r = d.getDeepestNode(n, t === this.positions.END), a = d.getContentLength(r);\n    switch (!0) {\n      case t === this.positions.START:\n        o = 0;\n        break;\n      case t === this.positions.END:\n      case o > a:\n        o = a;\n        break;\n    }\n    oe(() => {\n      this.set(r, o);\n    }, 20)(), i.setCurrentBlockByChildNode(e.holder), i.currentBlock.currentInput = n;\n  }\n  /**\n   * Set caret to the current input of current Block.\n   *\n   * @param {HTMLElement} input - input where caret should be set\n   * @param {string} position - position of the caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToInput(e, t = this.positions.DEFAULT, o = 0) {\n    const { currentBlock: i } = this.Editor.BlockManager, n = d.getDeepestNode(e);\n    switch (t) {\n      case this.positions.START:\n        this.set(n, 0);\n        break;\n      case this.positions.END:\n        this.set(n, d.getContentLength(n));\n        break;\n      default:\n        o && this.set(n, o);\n    }\n    i.currentInput = e;\n  }\n  /**\n   * Creates Document Range and sets caret to the element with offset\n   *\n   * @param {HTMLElement} element - target node.\n   * @param {number} offset - offset\n   */\n  set(e, t = 0) {\n    const { top: o, bottom: i } = m.setCursor(e, t), { innerHeight: n } = window;\n    o < 0 && window.scrollBy(0, o), i > n && window.scrollBy(0, i - n);\n  }\n  /**\n   * Set Caret to the last Block\n   * If last block is not empty, append another empty block\n   */\n  setToTheLastBlock() {\n    const e = this.Editor.BlockManager.lastBlock;\n    if (e)\n      if (e.tool.isDefault && e.isEmpty)\n        this.setToBlock(e);\n      else {\n        const t = this.Editor.BlockManager.insertAtEnd();\n        this.setToBlock(t);\n      }\n  }\n  /**\n   * Extract content fragment of current Block from Caret position to the end of the Block\n   */\n  extractFragmentFromCaretPosition() {\n    const e = m.get();\n    if (e.rangeCount) {\n      const t = e.getRangeAt(0), o = this.Editor.BlockManager.currentBlock.currentInput;\n      if (t.deleteContents(), o)\n        if (d.isNativeInput(o)) {\n          const i = o, n = document.createDocumentFragment(), r = i.value.substring(0, i.selectionStart), a = i.value.substring(i.selectionStart);\n          return n.textContent = a, i.value = r, n;\n        } else {\n          const i = t.cloneRange();\n          return i.selectNodeContents(o), i.setStart(t.endContainer, t.endOffset), i.extractContents();\n        }\n    }\n  }\n  /**\n   * Set's caret to the next Block or Tool`s input\n   * Before moving caret, we should check if caret position is at the end of Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @returns {boolean}\n   */\n  navigateNext() {\n    const { BlockManager: e } = this.Editor, { currentBlock: t, nextContentfulBlock: o } = e, { nextInput: i } = t, n = this.isAtEnd;\n    let r = o;\n    if (!r && !i) {\n      if (t.tool.isDefault || !n)\n        return !1;\n      r = e.insertAtEnd();\n    }\n    return n ? (i ? this.setToInput(i, this.positions.START) : this.setToBlock(r, this.positions.START), !0) : !1;\n  }\n  /**\n   * Set's caret to the previous Tool`s input or Block\n   * Before moving caret, we should check if caret position is start of the Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @returns {boolean}\n   */\n  navigatePrevious() {\n    const { currentBlock: e, previousContentfulBlock: t } = this.Editor.BlockManager;\n    if (!e)\n      return !1;\n    const { previousInput: o } = e;\n    return !t && !o ? !1 : this.isAtStart ? (o ? this.setToInput(o, this.positions.END) : this.setToBlock(t, this.positions.END), !0) : !1;\n  }\n  /**\n   * Inserts shadow element after passed element where caret can be placed\n   *\n   * @param {Element} element - element after which shadow caret should be inserted\n   */\n  createShadow(e) {\n    const t = document.createElement(\"span\");\n    t.classList.add(ve.CSS.shadowCaret), e.insertAdjacentElement(\"beforeend\", t);\n  }\n  /**\n   * Restores caret position\n   *\n   * @param {HTMLElement} element - element where caret should be restored\n   */\n  restoreCaret(e) {\n    const t = e.querySelector(`.${ve.CSS.shadowCaret}`);\n    if (!t)\n      return;\n    new m().expandToTag(t), setTimeout(() => {\n      const i = document.createRange();\n      i.selectNode(t), i.extractContents();\n    }, 50);\n  }\n  /**\n   * Inserts passed content at caret position\n   *\n   * @param {string} content - content to insert\n   */\n  insertContentAtCaretPosition(e) {\n    const t = document.createDocumentFragment(), o = document.createElement(\"div\"), i = m.get(), n = m.range;\n    o.innerHTML = e, Array.from(o.childNodes).forEach((l) => t.appendChild(l)), t.childNodes.length === 0 && t.appendChild(new Text());\n    const r = t.lastChild;\n    n.deleteContents(), n.insertNode(t);\n    const a = document.createRange();\n    a.setStart(r, r.textContent.length), i.removeAllRanges(), i.addRange(a);\n  }\n  /**\n   * Get all first-level (first child of [contenteditable]) siblings from passed node\n   * Then you can check it for emptiness\n   *\n   * @example\n   * <div contenteditable>\n   * <p></p>                            |\n   * <p></p>                            | left first-level siblings\n   * <p></p>                            |\n   * <blockquote><a><b>adaddad</b><a><blockquote>       <-- passed node for example <b>\n   * <p></p>                            |\n   * <p></p>                            | right first-level siblings\n   * <p></p>                            |\n   * </div>\n   * @param {HTMLElement} from - element from which siblings should be searched\n   * @param {'left' | 'right'} direction - direction of search\n   * @returns {HTMLElement[]}\n   */\n  getHigherLevelSiblings(e, t) {\n    let o = e;\n    const i = [];\n    for (; o.parentNode && o.parentNode.contentEditable !== \"true\"; )\n      o = o.parentNode;\n    const n = t === \"left\" ? \"previousSibling\" : \"nextSibling\";\n    for (; o[n]; )\n      o = o[n], i.push(o);\n    return i;\n  }\n}\nclass Vo extends S {\n  constructor() {\n    super(...arguments), this.onMouseUp = () => {\n      this.listeners.off(document, \"mouseover\", this.onMouseOver), this.listeners.off(document, \"mouseup\", this.onMouseUp);\n    }, this.onMouseOver = (e) => {\n      const { BlockManager: t, BlockSelection: o } = this.Editor, i = t.getBlockByChildNode(e.relatedTarget) || this.lastSelectedBlock, n = t.getBlockByChildNode(e.target);\n      if (!(!i || !n) && n !== i) {\n        if (i === this.firstSelectedBlock) {\n          m.get().removeAllRanges(), i.selected = !0, n.selected = !0, o.clearCache();\n          return;\n        }\n        if (n === this.firstSelectedBlock) {\n          i.selected = !1, n.selected = !1, o.clearCache();\n          return;\n        }\n        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i, n), this.lastSelectedBlock = n;\n      }\n    };\n  }\n  /**\n   * Module preparation\n   *\n   * @returns {Promise}\n   */\n  async prepare() {\n    this.listeners.on(document, \"mousedown\", (e) => {\n      this.enableCrossBlockSelection(e);\n    });\n  }\n  /**\n   * Sets up listeners\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  watchSelection(e) {\n    if (e.button !== _t.LEFT)\n      return;\n    const { BlockManager: t } = this.Editor;\n    this.firstSelectedBlock = t.getBlock(e.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, \"mouseover\", this.onMouseOver), this.listeners.on(document, \"mouseup\", this.onMouseUp);\n  }\n  /**\n   * return boolean is cross block selection started\n   */\n  get isCrossBlockSelectionStarted() {\n    return !!this.firstSelectedBlock && !!this.lastSelectedBlock;\n  }\n  /**\n   * Change selection state of the next Block\n   * Used for CBS via Shift + arrow keys\n   *\n   * @param {boolean} next - if true, toggle next block. Previous otherwise\n   */\n  toggleBlockSelectedState(e = !0) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = !0, o.clearCache(), m.get().removeAllRanges());\n    const i = t.blocks.indexOf(this.lastSelectedBlock) + (e ? 1 : -1), n = t.blocks[i];\n    n && (this.lastSelectedBlock.selected !== n.selected ? (n.selected = !0, o.clearCache()) : (this.lastSelectedBlock.selected = !1, o.clearCache()), this.lastSelectedBlock = n, this.Editor.InlineToolbar.close(), n.holder.scrollIntoView({\n      block: \"nearest\"\n    }));\n  }\n  /**\n   * Clear saved state\n   *\n   * @param {Event} reason - event caused clear of selection\n   */\n  clear(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor, n = t.blocks.indexOf(this.firstSelectedBlock), r = t.blocks.indexOf(this.lastSelectedBlock);\n    if (o.anyBlockSelected && n > -1 && r > -1)\n      if (e && e instanceof KeyboardEvent)\n        switch (e.keyCode) {\n          case B.DOWN:\n          case B.RIGHT:\n            i.setToBlock(t.blocks[Math.max(n, r)], i.positions.END);\n            break;\n          case B.UP:\n          case B.LEFT:\n            i.setToBlock(t.blocks[Math.min(n, r)], i.positions.START);\n            break;\n          default:\n            i.setToBlock(t.blocks[Math.max(n, r)], i.positions.END);\n        }\n      else\n        i.setToBlock(t.blocks[Math.max(n, r)], i.positions.END);\n    this.firstSelectedBlock = this.lastSelectedBlock = null;\n  }\n  /**\n   * Enables Cross Block Selection\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  enableCrossBlockSelection(e) {\n    const { UI: t } = this.Editor;\n    m.isCollapsed || this.Editor.BlockSelection.clearSelection(e), t.nodes.redactor.contains(e.target) ? this.watchSelection(e) : this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Change blocks selection state between passed two blocks.\n   *\n   * @param {Block} firstBlock - first block in range\n   * @param {Block} lastBlock - last block in range\n   */\n  toggleBlocksSelectedState(e, t) {\n    const { BlockManager: o, BlockSelection: i } = this.Editor, n = o.blocks.indexOf(e), r = o.blocks.indexOf(t), a = e.selected !== t.selected;\n    for (let l = Math.min(n, r); l <= Math.max(n, r); l++) {\n      const c = o.blocks[l];\n      c !== this.firstSelectedBlock && c !== (a ? e : t) && (o.blocks[l].selected = !o.blocks[l].selected, i.clearCache());\n    }\n  }\n}\nclass Zo extends S {\n  constructor() {\n    super(...arguments), this.isStartedAtEditor = !1;\n  }\n  /**\n   * Toggle read-only state\n   *\n   * if state is true:\n   *  - disable all drag-n-drop event handlers\n   *\n   * if state is false:\n   *  - restore drag-n-drop event handlers\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Add drag events listeners to editor zone\n   */\n  enableModuleBindings() {\n    const { UI: e } = this.Editor;\n    this.readOnlyMutableListeners.on(e.nodes.holder, \"drop\", async (t) => {\n      await this.processDrop(t);\n    }, !0), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragstart\", () => {\n      this.processDragStart();\n    }), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragover\", (t) => {\n      this.processDragOver(t);\n    }, !0);\n  }\n  /**\n   * Unbind drag-n-drop event handlers\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Handle drop event\n   *\n   * @param {DragEvent} dropEvent - drop event\n   */\n  async processDrop(e) {\n    const {\n      BlockManager: t,\n      Caret: o,\n      Paste: i\n    } = this.Editor;\n    e.preventDefault(), t.blocks.forEach((r) => {\n      r.dropTarget = !1;\n    }), m.isAtEditor && !m.isCollapsed && this.isStartedAtEditor && document.execCommand(\"delete\"), this.isStartedAtEditor = !1;\n    const n = t.setCurrentBlockByChildNode(e.target);\n    if (n)\n      this.Editor.Caret.setToBlock(n, o.positions.END);\n    else {\n      const r = t.setCurrentBlockByChildNode(t.lastBlock.holder);\n      this.Editor.Caret.setToBlock(r, o.positions.END);\n    }\n    await i.processDataTransfer(e.dataTransfer, !0);\n  }\n  /**\n   * Handle drag start event\n   */\n  processDragStart() {\n    m.isAtEditor && !m.isCollapsed && (this.isStartedAtEditor = !0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * @param {DragEvent} dragEvent - drag event\n   */\n  processDragOver(e) {\n    e.preventDefault();\n  }\n}\nclass Go extends S {\n  /**\n   * Prepare the module\n   *\n   * @param options - options used by the modification observer module\n   * @param options.config - Editor configuration object\n   * @param options.eventsDispatcher - common Editor event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.disabled = !1, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = 400, this.mutationObserver = new MutationObserver((o) => {\n      this.redactorChanged(o);\n    }), this.eventsDispatcher.on(lt, (o) => {\n      this.particularBlockChanged(o.event);\n    }), this.eventsDispatcher.on(ct, () => {\n      this.disable();\n    }), this.eventsDispatcher.on(dt, () => {\n      this.enable();\n    });\n  }\n  /**\n   * Enables onChange event\n   */\n  enable() {\n    this.mutationObserver.observe(\n      this.Editor.UI.nodes.redactor,\n      {\n        childList: !0,\n        subtree: !0,\n        characterData: !0,\n        attributes: !0\n      }\n    ), this.disabled = !1;\n  }\n  /**\n   * Disables onChange event\n   */\n  disable() {\n    this.mutationObserver.disconnect(), this.disabled = !0;\n  }\n  /**\n   * Call onChange event passed to Editor.js configuration\n   *\n   * @param event - some of our custom change events\n   */\n  particularBlockChanged(e) {\n    this.disabled || !D(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e.detail.target.id}:event:${e.type}`, e), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {\n      let t;\n      this.batchingOnChangeQueue.size === 1 ? t = this.batchingOnChangeQueue.values().next().value : t = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t), this.batchingOnChangeQueue.clear();\n    }, this.batchTime));\n  }\n  /**\n   * Fired on every blocks wrapper dom change\n   *\n   * @param mutations - mutations happened\n   */\n  redactorChanged(e) {\n    this.eventsDispatcher.emit(Me, {\n      mutations: e\n    });\n  }\n}\nconst xt = class extends S {\n  constructor() {\n    super(...arguments), this.MIME_TYPE = \"application/x-editor-js\", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (s) => {\n      try {\n        const e = s.create({}, {}, !1);\n        if (s.pasteConfig === !1) {\n          this.exceptionList.push(s.name);\n          return;\n        }\n        if (!D(e.onPaste))\n          return;\n        this.getTagsConfig(s), this.getFilesConfig(s), this.getPatternsConfig(s);\n      } catch (e) {\n        T(\n          `Paste handling for «${s.name}» Tool hasn't been set up because of the error`,\n          \"warn\",\n          e\n        );\n      }\n    }, this.handlePasteEvent = async (s) => {\n      const { BlockManager: e, Toolbar: t } = this.Editor;\n      !e.currentBlock || this.isNativeBehaviour(s.target) && !s.clipboardData.types.includes(\"Files\") || e.currentBlock && this.exceptionList.includes(e.currentBlock.name) || (s.preventDefault(), this.processDataTransfer(s.clipboardData), e.clearFocused(), t.close());\n    };\n  }\n  /**\n   * Set onPaste callback and collect tools` paste configurations\n   */\n  async prepare() {\n    this.processTools();\n  }\n  /**\n   * Set read-only state\n   *\n   * @param {boolean} readOnlyEnabled - read only flag value\n   */\n  toggleReadOnly(s) {\n    s ? this.unsetCallback() : this.setCallback();\n  }\n  /**\n   * Handle pasted or dropped data transfer object\n   *\n   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object\n   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events\n   */\n  async processDataTransfer(s, e = !1) {\n    const { Tools: t } = this.Editor, o = s.types;\n    if ((o.includes ? o.includes(\"Files\") : o.contains(\"Files\")) && !V(this.toolsFiles)) {\n      await this.processFiles(s.files);\n      return;\n    }\n    const n = s.getData(this.MIME_TYPE), r = s.getData(\"text/plain\");\n    let a = s.getData(\"text/html\");\n    if (n)\n      try {\n        this.insertEditorJSData(JSON.parse(n));\n        return;\n      } catch {\n      }\n    e && r.trim() && a.trim() && (a = \"<p>\" + (a.trim() ? a : r) + \"</p>\");\n    const l = Object.keys(this.toolsTags).reduce((h, f) => (h[f.toLowerCase()] = this.toolsTags[f].sanitizationConfig ?? {}, h), {}), c = Object.assign({}, l, t.getAllInlineToolsSanitizeConfig(), { br: {} }), u = Z(a, c);\n    !u.trim() || u.trim() === r || !d.isHTMLString(u) ? await this.processText(r) : await this.processText(u, !0);\n  }\n  /**\n   * Process pasted text and divide them into Blocks\n   *\n   * @param {string} data - text to process. Can be HTML or plain.\n   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true\n   */\n  async processText(s, e = !1) {\n    const { Caret: t, BlockManager: o } = this.Editor, i = e ? this.processHTML(s) : this.processPlain(s);\n    if (!i.length)\n      return;\n    if (i.length === 1) {\n      i[0].isBlock ? this.processSingleBlock(i.pop()) : this.processInlinePaste(i.pop());\n      return;\n    }\n    const r = o.currentBlock && o.currentBlock.tool.isDefault && o.currentBlock.isEmpty;\n    i.map(\n      async (a, l) => this.insertBlock(a, l === 0 && r)\n    ), o.currentBlock && t.setToBlock(o.currentBlock, t.positions.END);\n  }\n  /**\n   * Set onPaste callback handler\n   */\n  setCallback() {\n    this.listeners.on(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Unset onPaste callback handler\n   */\n  unsetCallback() {\n    this.listeners.off(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Get and process tool`s paste configs\n   */\n  processTools() {\n    const s = this.Editor.Tools.blockTools;\n    Array.from(s.values()).forEach(this.processTool);\n  }\n  /**\n   * Get tags name list from either tag name or sanitization config.\n   *\n   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.\n   * @returns {string[]} array of tags.\n   */\n  collectTagNames(s) {\n    return J(s) ? [s] : j(s) ? Object.keys(s) : [];\n  }\n  /**\n   * Get tags to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getTagsConfig(s) {\n    if (s.pasteConfig === !1)\n      return;\n    const e = s.pasteConfig.tags || [], t = [];\n    e.forEach((o) => {\n      const i = this.collectTagNames(o);\n      t.push(...i), i.forEach((n) => {\n        if (Object.prototype.hasOwnProperty.call(this.toolsTags, n)) {\n          T(\n            `Paste handler for «${s.name}» Tool on «${n}» tag is skipped because it is already used by «${this.toolsTags[n].tool.name}» Tool.`,\n            \"warn\"\n          );\n          return;\n        }\n        const r = j(o) ? o[n] : null;\n        this.toolsTags[n.toUpperCase()] = {\n          tool: s,\n          sanitizationConfig: r\n        };\n      });\n    }), this.tagsByTool[s.name] = t.map((o) => o.toUpperCase());\n  }\n  /**\n   * Get files` types and extensions to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getFilesConfig(s) {\n    if (s.pasteConfig === !1)\n      return;\n    const { files: e = {} } = s.pasteConfig;\n    let { extensions: t, mimeTypes: o } = e;\n    !t && !o || (t && !Array.isArray(t) && (T(`«extensions» property of the onDrop config for «${s.name}» Tool should be an array`), t = []), o && !Array.isArray(o) && (T(`«mimeTypes» property of the onDrop config for «${s.name}» Tool should be an array`), o = []), o && (o = o.filter((i) => Dt(i) ? !0 : (T(`MIME type value «${i}» for the «${s.name}» Tool is not a valid MIME type`, \"warn\"), !1))), this.toolsFiles[s.name] = {\n      extensions: t || [],\n      mimeTypes: o || []\n    });\n  }\n  /**\n   * Get RegExp patterns to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getPatternsConfig(s) {\n    s.pasteConfig === !1 || !s.pasteConfig.patterns || V(s.pasteConfig.patterns) || Object.entries(s.pasteConfig.patterns).forEach(([e, t]) => {\n      t instanceof RegExp || T(\n        `Pattern ${t} for «${s.name}» Tool is skipped because it should be a Regexp instance.`,\n        \"warn\"\n      ), this.toolsPatterns.push({\n        key: e,\n        pattern: t,\n        tool: s\n      });\n    });\n  }\n  /**\n   * Check if browser behavior suits better\n   *\n   * @param {EventTarget} element - element where content has been pasted\n   * @returns {boolean}\n   */\n  isNativeBehaviour(s) {\n    return d.isNativeInput(s);\n  }\n  /**\n   * Get files from data transfer object and insert related Tools\n   *\n   * @param {FileList} items - pasted or dropped items\n   */\n  async processFiles(s) {\n    const { BlockManager: e } = this.Editor;\n    let t;\n    t = await Promise.all(\n      Array.from(s).map((n) => this.processFile(n))\n    ), t = t.filter((n) => !!n);\n    const i = e.currentBlock.tool.isDefault && e.currentBlock.isEmpty;\n    t.forEach(\n      (n, r) => {\n        e.paste(n.type, n.event, r === 0 && i);\n      }\n    );\n  }\n  /**\n   * Get information about file and find Tool to handle it\n   *\n   * @param {File} file - file to process\n   */\n  async processFile(s) {\n    const e = Rt(s), t = Object.entries(this.toolsFiles).find(([n, { mimeTypes: r, extensions: a }]) => {\n      const [l, c] = s.type.split(\"/\"), u = a.find((f) => f.toLowerCase() === e.toLowerCase()), h = r.find((f) => {\n        const [v, p] = f.split(\"/\");\n        return v === l && (p === c || p === \"*\");\n      });\n      return !!u || !!h;\n    });\n    if (!t)\n      return;\n    const [o] = t;\n    return {\n      event: this.composePasteEvent(\"file\", {\n        file: s\n      }),\n      type: o\n    };\n  }\n  /**\n   * Split HTML string to blocks and return it as array of Block data\n   *\n   * @param {string} innerHTML - html string to process\n   * @returns {PasteData[]}\n   */\n  processHTML(s) {\n    const { Tools: e } = this.Editor, t = d.make(\"DIV\");\n    return t.innerHTML = s, this.getNodes(t).map((i) => {\n      let n, r = e.defaultTool, a = !1;\n      switch (i.nodeType) {\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          n = d.make(\"div\"), n.appendChild(i);\n          break;\n        case Node.ELEMENT_NODE:\n          n = i, a = !0, this.toolsTags[n.tagName] && (r = this.toolsTags[n.tagName].tool);\n          break;\n      }\n      const { tags: l } = r.pasteConfig || { tags: [] }, c = l.reduce((f, v) => (this.collectTagNames(v).forEach((k) => {\n        const _ = j(v) ? v[k] : null;\n        f[k.toLowerCase()] = _ || {};\n      }), f), {}), u = Object.assign({}, c, r.baseSanitizeConfig);\n      if (n.tagName.toLowerCase() === \"table\") {\n        const f = Z(n.outerHTML, u);\n        n = d.make(\"div\", void 0, {\n          innerHTML: f\n        }).firstChild;\n      } else\n        n.innerHTML = Z(n.innerHTML, u);\n      const h = this.composePasteEvent(\"tag\", {\n        data: n\n      });\n      return {\n        content: n,\n        isBlock: a,\n        tool: r.name,\n        event: h\n      };\n    }).filter((i) => {\n      const n = d.isEmpty(i.content), r = d.isSingleTag(i.content);\n      return !n || r;\n    });\n  }\n  /**\n   * Split plain text by new line symbols and return it as array of Block data\n   *\n   * @param {string} plain - string to process\n   * @returns {PasteData[]}\n   */\n  processPlain(s) {\n    const { defaultBlock: e } = this.config;\n    if (!s)\n      return [];\n    const t = e;\n    return s.split(/\\r?\\n/).filter((o) => o.trim()).map((o) => {\n      const i = d.make(\"div\");\n      i.textContent = o;\n      const n = this.composePasteEvent(\"tag\", {\n        data: i\n      });\n      return {\n        content: i,\n        tool: t,\n        isBlock: !1,\n        event: n\n      };\n    });\n  }\n  /**\n   * Process paste of single Block tool content\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processSingleBlock(s) {\n    const { Caret: e, BlockManager: t } = this.Editor, { currentBlock: o } = t;\n    if (!o || s.tool !== o.name || !d.containsOnlyInlineElements(s.content.innerHTML)) {\n      this.insertBlock(s, (o == null ? void 0 : o.tool.isDefault) && o.isEmpty);\n      return;\n    }\n    e.insertContentAtCaretPosition(s.content.innerHTML);\n  }\n  /**\n   * Process paste to single Block:\n   * 1. Find patterns` matches\n   * 2. Insert new block if it is not the same type as current one\n   * 3. Just insert text if there is no substitutions\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processInlinePaste(s) {\n    const { BlockManager: e, Caret: t } = this.Editor, { content: o } = s;\n    if (e.currentBlock && e.currentBlock.tool.isDefault && o.textContent.length < xt.PATTERN_PROCESSING_MAX_LENGTH) {\n      const n = await this.processPattern(o.textContent);\n      if (n) {\n        const r = e.currentBlock && e.currentBlock.tool.isDefault && e.currentBlock.isEmpty, a = e.paste(n.tool, n.event, r);\n        t.setToBlock(a, t.positions.END);\n        return;\n      }\n    }\n    if (e.currentBlock && e.currentBlock.currentInput) {\n      const n = e.currentBlock.tool.baseSanitizeConfig;\n      document.execCommand(\n        \"insertHTML\",\n        !1,\n        Z(o.innerHTML, n)\n      );\n    } else\n      this.insertBlock(s);\n  }\n  /**\n   * Get patterns` matches\n   *\n   * @param {string} text - text to process\n   * @returns {Promise<{event: PasteEvent, tool: string}>}\n   */\n  async processPattern(s) {\n    const e = this.toolsPatterns.find((o) => {\n      const i = o.pattern.exec(s);\n      return i ? s === i.shift() : !1;\n    });\n    return e ? {\n      event: this.composePasteEvent(\"pattern\", {\n        key: e.key,\n        data: s\n      }),\n      tool: e.tool.name\n    } : void 0;\n  }\n  /**\n   * Insert pasted Block content to Editor\n   *\n   * @param {PasteData} data - data to insert\n   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block\n   * @returns {void}\n   */\n  insertBlock(s, e = !1) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i } = t;\n    let n;\n    if (e && i && i.isEmpty) {\n      n = t.paste(s.tool, s.event, !0), o.setToBlock(n, o.positions.END);\n      return;\n    }\n    n = t.paste(s.tool, s.event), o.setToBlock(n, o.positions.END);\n  }\n  /**\n   * Insert data passed as application/x-editor-js JSON\n   *\n   * @param {Array} blocks — Blocks' data to insert\n   * @returns {void}\n   */\n  insertEditorJSData(s) {\n    const { BlockManager: e, Caret: t, Tools: o } = this.Editor;\n    ht(\n      s,\n      (n) => o.blockTools.get(n).sanitizeConfig\n    ).forEach(({ tool: n, data: r }, a) => {\n      let l = !1;\n      a === 0 && (l = e.currentBlock && e.currentBlock.tool.isDefault && e.currentBlock.isEmpty);\n      const c = e.insert({\n        tool: n,\n        data: r,\n        replace: l\n      });\n      t.setToBlock(c, t.positions.END);\n    });\n  }\n  /**\n   * Fetch nodes from Element node\n   *\n   * @param {Node} node - current node\n   * @param {Node[]} nodes - processed nodes\n   * @param {Node} destNode - destination node\n   */\n  processElementNode(s, e, t) {\n    const o = Object.keys(this.toolsTags), i = s, { tool: n } = this.toolsTags[i.tagName] || {}, r = this.tagsByTool[n == null ? void 0 : n.name] || [], a = o.includes(i.tagName), l = d.blockElements.includes(i.tagName.toLowerCase()), c = Array.from(i.children).some(\n      ({ tagName: h }) => o.includes(h) && !r.includes(h)\n    ), u = Array.from(i.children).some(\n      ({ tagName: h }) => d.blockElements.includes(h.toLowerCase())\n    );\n    if (!l && !a && !c)\n      return t.appendChild(i), [...e, t];\n    if (a && !c || l && !u && !c)\n      return [...e, t, i];\n  }\n  /**\n   * Recursively divide HTML string to two types of nodes:\n   * 1. Block element\n   * 2. Document Fragments contained text and markup tags like a, b, i etc.\n   *\n   * @param {Node} wrapper - wrapper of paster HTML content\n   * @returns {Node[]}\n   */\n  getNodes(s) {\n    const e = Array.from(s.childNodes);\n    let t;\n    const o = (i, n) => {\n      if (d.isEmpty(n) && !d.isSingleTag(n))\n        return i;\n      const r = i[i.length - 1];\n      let a = new DocumentFragment();\n      switch (r && d.isFragment(r) && (a = i.pop()), n.nodeType) {\n        case Node.ELEMENT_NODE:\n          if (t = this.processElementNode(n, i, a), t)\n            return t;\n          break;\n        case Node.TEXT_NODE:\n          return a.appendChild(n), [...i, a];\n        default:\n          return [...i, a];\n      }\n      return [...i, ...Array.from(n.childNodes).reduce(o, [])];\n    };\n    return e.reduce(o, []);\n  }\n  /**\n   * Compose paste event with passed type and detail\n   *\n   * @param {string} type - event type\n   * @param {PasteEventDetail} detail - event detail\n   */\n  composePasteEvent(s, e) {\n    return new CustomEvent(s, {\n      detail: e\n    });\n  }\n};\nlet wt = xt;\nwt.PATTERN_PROCESSING_MAX_LENGTH = 450;\nclass qo extends S {\n  constructor() {\n    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = !1;\n  }\n  /**\n   * Returns state of read only mode\n   */\n  get isEnabled() {\n    return this.readOnlyEnabled;\n  }\n  /**\n   * Set initial state\n   */\n  async prepare() {\n    const { Tools: e } = this.Editor, { blockTools: t } = e, o = [];\n    Array.from(t.entries()).forEach(([i, n]) => {\n      n.isReadOnlySupported || o.push(i);\n    }), this.toolsDontSupportReadOnly = o, this.config.readOnly && o.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly);\n  }\n  /**\n   * Set read-only mode or toggle current state\n   * Call all Modules `toggleReadOnly` method and re-render Editor\n   *\n   * @param {boolean} state - (optional) read-only state or toggle\n   */\n  async toggle(e = !this.readOnlyEnabled) {\n    e && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();\n    const t = this.readOnlyEnabled;\n    this.readOnlyEnabled = e;\n    for (const i in this.Editor)\n      this.Editor[i].toggleReadOnly && this.Editor[i].toggleReadOnly(e);\n    if (t === e)\n      return this.readOnlyEnabled;\n    const o = await this.Editor.Saver.save();\n    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(o.blocks), this.readOnlyEnabled;\n  }\n  /**\n   * Throws an error about tools which don't support read-only mode\n   */\n  throwCriticalError() {\n    throw new at(\n      `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(\", \")} don't support read-only mode.`\n    );\n  }\n}\nclass pe extends S {\n  constructor() {\n    super(...arguments), this.isRectSelectionActivated = !1, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = !1, this.isScrolling = !1, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      overlay: \"codex-editor-overlay\",\n      overlayContainer: \"codex-editor-overlay__container\",\n      rect: \"codex-editor-overlay__rectangle\",\n      topScrollZone: \"codex-editor-overlay__scroll-zone--top\",\n      bottomScrollZone: \"codex-editor-overlay__scroll-zone--bottom\"\n    };\n  }\n  /**\n   * Module Preparation\n   * Creating rect and hang handlers\n   */\n  prepare() {\n    this.enableModuleBindings();\n  }\n  /**\n   * Init rect params\n   *\n   * @param {number} pageX - X coord of mouse\n   * @param {number} pageY - Y coord of mouse\n   */\n  startSelection(e, t) {\n    const o = document.elementFromPoint(e - window.pageXOffset, t - window.pageYOffset);\n    o.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = !1, this.clearSelection(), this.stackOfSelected = []);\n    const n = [\n      `.${F.CSS.content}`,\n      `.${this.Editor.Toolbar.CSS.toolbar}`,\n      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`\n    ], r = o.closest(\".\" + this.Editor.UI.CSS.editorWrapper), a = n.some((l) => !!o.closest(l));\n    !r || a || (this.mousedown = !0, this.startX = e, this.startY = t);\n  }\n  /**\n   * Clear all params to end selection\n   */\n  endSelection() {\n    this.mousedown = !1, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = \"none\";\n  }\n  /**\n   * is RectSelection Activated\n   */\n  isRectActivated() {\n    return this.isRectSelectionActivated;\n  }\n  /**\n   * Mark that selection is end\n   */\n  clearSelection() {\n    this.isRectSelectionActivated = !1;\n  }\n  /**\n   * Sets Module necessary event handlers\n   */\n  enableModuleBindings() {\n    const { container: e } = this.genHTML();\n    this.listeners.on(e, \"mousedown\", (t) => {\n      this.processMouseDown(t);\n    }, !1), this.listeners.on(document.body, \"mousemove\", Te((t) => {\n      this.processMouseMove(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseleave\", () => {\n      this.processMouseLeave();\n    }), this.listeners.on(window, \"scroll\", Te((t) => {\n      this.processScroll(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseup\", () => {\n      this.processMouseUp();\n    }, !1);\n  }\n  /**\n   * Handle mouse down events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseDown(e) {\n    if (e.button !== this.MAIN_MOUSE_BUTTON)\n      return;\n    e.target.closest(d.allInputsSelector) !== null || this.startSelection(e.pageX, e.pageY);\n  }\n  /**\n   * Handle mouse move events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseMove(e) {\n    this.changingRectangle(e), this.scrollByZones(e.clientY);\n  }\n  /**\n   * Handle mouse leave\n   */\n  processMouseLeave() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processScroll(e) {\n    this.changingRectangle(e);\n  }\n  /**\n   * Handle mouse up\n   */\n  processMouseUp() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * Scroll If mouse in scroll zone\n   *\n   * @param {number} clientY - Y coord of mouse\n   */\n  scrollByZones(e) {\n    if (this.inScrollZone = null, e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {\n      this.isScrolling = !1;\n      return;\n    }\n    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = !0);\n  }\n  /**\n   * Generates required HTML elements\n   *\n   * @returns {Object<string, Element>}\n   */\n  genHTML() {\n    const { UI: e } = this.Editor, t = e.nodes.holder.querySelector(\".\" + e.CSS.editorWrapper), o = d.make(\"div\", pe.CSS.overlay, {}), i = d.make(\"div\", pe.CSS.overlayContainer, {}), n = d.make(\"div\", pe.CSS.rect, {});\n    return i.appendChild(n), o.appendChild(i), t.appendChild(o), this.overlayRectangle = n, {\n      container: t,\n      overlay: o\n    };\n  }\n  /**\n   * Activates scrolling if blockSelection is active and mouse is in scroll zone\n   *\n   * @param {number} speed - speed of scrolling\n   */\n  scrollVertical(e) {\n    if (!(this.inScrollZone && this.mousedown))\n      return;\n    const t = window.pageYOffset;\n    window.scrollBy(0, e), this.mouseY += window.pageYOffset - t, setTimeout(() => {\n      this.scrollVertical(e);\n    }, 0);\n  }\n  /**\n   * Handles the change in the rectangle and its effect\n   *\n   * @param {MouseEvent} event - mouse event\n   */\n  changingRectangle(e) {\n    if (!this.mousedown)\n      return;\n    e.pageY !== void 0 && (this.mouseX = e.pageX, this.mouseY = e.pageY);\n    const { rightPos: t, leftPos: o, index: i } = this.genInfoForMouseSelection(), n = this.startX > t && this.mouseX > t, r = this.startX < o && this.mouseX < o;\n    this.rectCrossesBlocks = !(n || r), this.isRectSelectionActivated || (this.rectCrossesBlocks = !1, this.isRectSelectionActivated = !0, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = \"block\"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i !== void 0 && (this.trySelectNextBlock(i), this.inverseSelection(), m.get().removeAllRanges());\n  }\n  /**\n   * Shrink rect to singular point\n   */\n  shrinkRectangleToPoint() {\n    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;\n  }\n  /**\n   * Select or unselect all of blocks in array if rect is out or in selectable area\n   */\n  inverseSelection() {\n    const t = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;\n    if (this.rectCrossesBlocks && !t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.selectBlockByIndex(o);\n    if (!this.rectCrossesBlocks && t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.unSelectBlockByIndex(o);\n  }\n  /**\n   * Updates size of rectangle\n   */\n  updateRectangleSize() {\n    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);\n  }\n  /**\n   * Collects information needed to determine the behavior of the rectangle\n   *\n   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border\n   */\n  genInfoForMouseSelection() {\n    const t = document.body.offsetWidth / 2, o = this.mouseY - window.pageYOffset, i = document.elementFromPoint(t, o), n = this.Editor.BlockManager.getBlockByChildNode(i);\n    let r;\n    n !== void 0 && (r = this.Editor.BlockManager.blocks.findIndex((h) => h.holder === n.holder));\n    const a = this.Editor.BlockManager.lastBlock.holder.querySelector(\".\" + F.CSS.content), l = Number.parseInt(window.getComputedStyle(a).width, 10) / 2, c = t - l, u = t + l;\n    return {\n      index: r,\n      leftPos: c,\n      rightPos: u\n    };\n  }\n  /**\n   * Select block with index index\n   *\n   * @param index - index of block in redactor\n   */\n  addBlockInSelection(e) {\n    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e), this.stackOfSelected.push(e);\n  }\n  /**\n   * Adds a block to the selection and determines which blocks should be selected\n   *\n   * @param {object} index - index of new block in the reactor\n   */\n  trySelectNextBlock(e) {\n    const t = this.stackOfSelected[this.stackOfSelected.length - 1] === e, o = this.stackOfSelected.length, i = 1, n = -1, r = 0;\n    if (t)\n      return;\n    const a = this.stackOfSelected[o - 1] - this.stackOfSelected[o - 2] > 0;\n    let l = r;\n    o > 1 && (l = a ? i : n);\n    const c = e > this.stackOfSelected[o - 1] && l === i, u = e < this.stackOfSelected[o - 1] && l === n, f = !(c || u || l === r);\n    if (!f && (e > this.stackOfSelected[o - 1] || this.stackOfSelected[o - 1] === void 0)) {\n      let k = this.stackOfSelected[o - 1] + 1 || e;\n      for (k; k <= e; k++)\n        this.addBlockInSelection(k);\n      return;\n    }\n    if (!f && e < this.stackOfSelected[o - 1]) {\n      for (let k = this.stackOfSelected[o - 1] - 1; k >= e; k--)\n        this.addBlockInSelection(k);\n      return;\n    }\n    if (!f)\n      return;\n    let v = o - 1, p;\n    for (e > this.stackOfSelected[o - 1] ? p = () => e > this.stackOfSelected[v] : p = () => e < this.stackOfSelected[v]; p(); )\n      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[v]), this.stackOfSelected.pop(), v--;\n  }\n}\nclass Jo extends S {\n  /**\n   * @typedef {object} RendererBlocks\n   * @property {string} type - tool name\n   * @property {object} data - tool data\n   */\n  /**\n   * @example\n   *\n   * blocks: [\n   *   {\n   *     id   : 'oDe-EVrGWA',\n   *     type : 'paragraph',\n   *     data : {\n   *       text : 'Hello from Codex!'\n   *     }\n   *   },\n   *   {\n   *     id   : 'Ld5BJjJCHs',\n   *     type : 'paragraph',\n   *     data : {\n   *       text : 'Leave feedback if you like it!'\n   *     }\n   *   },\n   * ]\n   */\n  /**\n   * Make plugin blocks from array of plugin`s data\n   *\n   * @param {OutputBlockData[]} blocks - blocks to render\n   */\n  async render(e) {\n    const t = e.map((i) => ({ function: () => this.insertBlock(i) }));\n    this.Editor.ModificationsObserver.disable();\n    const o = await ot(t);\n    return this.Editor.ModificationsObserver.enable(), this.Editor.UI.checkEmptiness(), o;\n  }\n  /**\n   * Get plugin instance\n   * Add plugin instance to BlockManager\n   * Insert block to working zone\n   *\n   * @param {object} item - Block data to insert\n   * @returns {Promise<void>}\n   */\n  async insertBlock(e) {\n    var l;\n    const { Tools: t, BlockManager: o } = this.Editor, { type: i, data: n, tunes: r, id: a } = e;\n    if (t.available.has(i))\n      try {\n        o.insert({\n          id: a,\n          tool: i,\n          data: n,\n          tunes: r\n        });\n      } catch (c) {\n        throw T(`Block «${i}» skipped because of plugins error`, \"warn\", {\n          data: n,\n          error: c\n        }), Error(c);\n      }\n    else {\n      const c = {\n        savedData: {\n          id: a,\n          type: i,\n          data: n\n        },\n        title: i\n      };\n      if (t.unavailable.has(i)) {\n        const f = (l = t.unavailable.get(i).toolbox[0]) == null ? void 0 : l.title;\n        c.title = f || c.title;\n      }\n      const u = o.insert({\n        id: a,\n        tool: t.stubTool,\n        data: c\n      });\n      u.stretched = !0, T(`Tool «${i}» is not found. Check 'tools' property at your initial Editor.js config.`, \"warn\");\n    }\n  }\n}\nclass Qo extends S {\n  /**\n   * Composes new chain of Promises to fire them alternatelly\n   *\n   * @returns {OutputData}\n   */\n  async save() {\n    const { BlockManager: e, Tools: t } = this.Editor, o = e.blocks, i = [];\n    try {\n      o.forEach((a) => {\n        i.push(this.getSavedData(a));\n      });\n      const n = await Promise.all(i), r = await ht(n, (a) => t.blockTools.get(a).sanitizeConfig);\n      return this.makeOutput(r);\n    } catch (n) {\n      K(\"Saving failed due to the Error %o\", \"error\", n);\n    }\n  }\n  /**\n   * Saves and validates\n   *\n   * @param {Block} block - Editor's Tool\n   * @returns {ValidatedData} - Tool's validated data\n   */\n  async getSavedData(e) {\n    const t = await e.save(), o = t && await e.validate(t.data);\n    return {\n      ...t,\n      isValid: o\n    };\n  }\n  /**\n   * Creates output object with saved data, time and version of editor\n   *\n   * @param {ValidatedData} allExtractedData - data extracted from Blocks\n   * @returns {OutputData}\n   */\n  makeOutput(e) {\n    let t = 0;\n    const o = [];\n    return T(\"[Editor.js saving]:\", \"groupCollapsed\"), e.forEach(({ id: i, tool: n, data: r, tunes: a, time: l, isValid: c }) => {\n      if (t += l, T(`${n.charAt(0).toUpperCase() + n.slice(1)}`, \"group\"), c)\n        T(r), T(void 0, \"groupEnd\");\n      else {\n        T(`Block «${n}» skipped because saved data is invalid`), T(void 0, \"groupEnd\");\n        return;\n      }\n      if (n === this.Editor.Tools.stubTool) {\n        o.push(r);\n        return;\n      }\n      const u = {\n        id: i,\n        type: n,\n        data: r,\n        ...!V(a) && {\n          tunes: a\n        }\n      };\n      o.push(u);\n    }), T(\"Total\", \"log\", t), T(void 0, \"groupEnd\"), {\n      time: +/* @__PURE__ */ new Date(),\n      blocks: o,\n      version: \"2.27.2\"\n    };\n  }\n}\nvar Ne = {}, ei = {\n  get exports() {\n    return Ne;\n  },\n  set exports(s) {\n    Ne = s;\n  }\n};\n(function(s, e) {\n  (function(t, o) {\n    s.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(n) {\n        if (o[n])\n          return o[n].exports;\n        var r = o[n] = { i: n, l: !1, exports: {} };\n        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(n, r, a) {\n        i.o(n, r) || Object.defineProperty(n, r, { enumerable: !0, get: a });\n      }, i.r = function(n) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(n, \"__esModule\", { value: !0 });\n      }, i.t = function(n, r) {\n        if (1 & r && (n = i(n)), 8 & r || 4 & r && typeof n == \"object\" && n && n.__esModule)\n          return n;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: n }), 2 & r && typeof n != \"string\")\n          for (var l in n)\n            i.d(a, l, function(c) {\n              return n[c];\n            }.bind(null, l));\n        return a;\n      }, i.n = function(n) {\n        var r = n && n.__esModule ? function() {\n          return n.default;\n        } : function() {\n          return n;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(n, r) {\n        return Object.prototype.hasOwnProperty.call(n, r);\n      }, i.p = \"/\", i(i.s = 4);\n    }([function(t, o, i) {\n      var n = i(1), r = i(2);\n      typeof (r = r.__esModule ? r.default : r) == \"string\" && (r = [[t.i, r, \"\"]]);\n      var a = { insert: \"head\", singleton: !1 };\n      n(r, a), t.exports = r.locals || {};\n    }, function(t, o, i) {\n      var n, r = function() {\n        return n === void 0 && (n = !!(window && document && document.all && !window.atob)), n;\n      }, a = function() {\n        var y = {};\n        return function(x) {\n          if (y[x] === void 0) {\n            var w = document.querySelector(x);\n            if (window.HTMLIFrameElement && w instanceof window.HTMLIFrameElement)\n              try {\n                w = w.contentDocument.head;\n              } catch {\n                w = null;\n              }\n            y[x] = w;\n          }\n          return y[x];\n        };\n      }(), l = [];\n      function c(y) {\n        for (var x = -1, w = 0; w < l.length; w++)\n          if (l[w].identifier === y) {\n            x = w;\n            break;\n          }\n        return x;\n      }\n      function u(y, x) {\n        for (var w = {}, M = [], R = 0; R < y.length; R++) {\n          var b = y[R], g = x.base ? b[0] + x.base : b[0], E = w[g] || 0, C = \"\".concat(g, \" \").concat(E);\n          w[g] = E + 1;\n          var O = c(C), I = { css: b[1], media: b[2], sourceMap: b[3] };\n          O !== -1 ? (l[O].references++, l[O].updater(I)) : l.push({ identifier: C, updater: A(I, x), references: 1 }), M.push(C);\n        }\n        return M;\n      }\n      function h(y) {\n        var x = document.createElement(\"style\"), w = y.attributes || {};\n        if (w.nonce === void 0) {\n          var M = i.nc;\n          M && (w.nonce = M);\n        }\n        if (Object.keys(w).forEach(function(b) {\n          x.setAttribute(b, w[b]);\n        }), typeof y.insert == \"function\")\n          y.insert(x);\n        else {\n          var R = a(y.insert || \"head\");\n          if (!R)\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n          R.appendChild(x);\n        }\n        return x;\n      }\n      var f, v = (f = [], function(y, x) {\n        return f[y] = x, f.filter(Boolean).join(`\n`);\n      });\n      function p(y, x, w, M) {\n        var R = w ? \"\" : M.media ? \"@media \".concat(M.media, \" {\").concat(M.css, \"}\") : M.css;\n        if (y.styleSheet)\n          y.styleSheet.cssText = v(x, R);\n        else {\n          var b = document.createTextNode(R), g = y.childNodes;\n          g[x] && y.removeChild(g[x]), g.length ? y.insertBefore(b, g[x]) : y.appendChild(b);\n        }\n      }\n      function k(y, x, w) {\n        var M = w.css, R = w.media, b = w.sourceMap;\n        if (R ? y.setAttribute(\"media\", R) : y.removeAttribute(\"media\"), b && btoa && (M += `\n/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(b)))), \" */\")), y.styleSheet)\n          y.styleSheet.cssText = M;\n        else {\n          for (; y.firstChild; )\n            y.removeChild(y.firstChild);\n          y.appendChild(document.createTextNode(M));\n        }\n      }\n      var _ = null, N = 0;\n      function A(y, x) {\n        var w, M, R;\n        if (x.singleton) {\n          var b = N++;\n          w = _ || (_ = h(x)), M = p.bind(null, w, b, !1), R = p.bind(null, w, b, !0);\n        } else\n          w = h(x), M = k.bind(null, w, x), R = function() {\n            (function(g) {\n              if (g.parentNode === null)\n                return !1;\n              g.parentNode.removeChild(g);\n            })(w);\n          };\n        return M(y), function(g) {\n          if (g) {\n            if (g.css === y.css && g.media === y.media && g.sourceMap === y.sourceMap)\n              return;\n            M(y = g);\n          } else\n            R();\n        };\n      }\n      t.exports = function(y, x) {\n        (x = x || {}).singleton || typeof x.singleton == \"boolean\" || (x.singleton = r());\n        var w = u(y = y || [], x);\n        return function(M) {\n          if (M = M || [], Object.prototype.toString.call(M) === \"[object Array]\") {\n            for (var R = 0; R < w.length; R++) {\n              var b = c(w[R]);\n              l[b].references--;\n            }\n            for (var g = u(M, x), E = 0; E < w.length; E++) {\n              var C = c(w[E]);\n              l[C].references === 0 && (l[C].updater(), l.splice(C, 1));\n            }\n            w = g;\n          }\n        };\n      };\n    }, function(t, o, i) {\n      (o = i(3)(!1)).push([t.i, `.ce-paragraph {\n    line-height: 1.6em;\n    outline: none;\n}\n\n.ce-paragraph[data-placeholder]:empty::before{\n  content: attr(data-placeholder);\n  color: #707684;\n  font-weight: normal;\n  opacity: 0;\n}\n\n/** Show placeholder at the first paragraph if Editor is empty */\n.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before {\n  opacity: 1;\n}\n\n.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before,\n.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus::before {\n  opacity: 0;\n}\n\n.ce-paragraph p:first-of-type{\n    margin-top: 0;\n}\n\n.ce-paragraph p:last-of-type{\n    margin-bottom: 0;\n}\n`, \"\"]), t.exports = o;\n    }, function(t, o, i) {\n      t.exports = function(n) {\n        var r = [];\n        return r.toString = function() {\n          return this.map(function(a) {\n            var l = function(c, u) {\n              var h = c[1] || \"\", f = c[3];\n              if (!f)\n                return h;\n              if (u && typeof btoa == \"function\") {\n                var v = (k = f, _ = btoa(unescape(encodeURIComponent(JSON.stringify(k)))), N = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(_), \"/*# \".concat(N, \" */\")), p = f.sources.map(function(A) {\n                  return \"/*# sourceURL=\".concat(f.sourceRoot || \"\").concat(A, \" */\");\n                });\n                return [h].concat(p).concat([v]).join(`\n`);\n              }\n              var k, _, N;\n              return [h].join(`\n`);\n            }(a, n);\n            return a[2] ? \"@media \".concat(a[2], \" {\").concat(l, \"}\") : l;\n          }).join(\"\");\n        }, r.i = function(a, l, c) {\n          typeof a == \"string\" && (a = [[null, a, \"\"]]);\n          var u = {};\n          if (c)\n            for (var h = 0; h < this.length; h++) {\n              var f = this[h][0];\n              f != null && (u[f] = !0);\n            }\n          for (var v = 0; v < a.length; v++) {\n            var p = [].concat(a[v]);\n            c && u[p[0]] || (l && (p[2] ? p[2] = \"\".concat(l, \" and \").concat(p[2]) : p[2] = l), r.push(p));\n          }\n        }, r;\n      };\n    }, function(t, o, i) {\n      i.r(o), i.d(o, \"default\", function() {\n        return a;\n      }), i(0);\n      function n(l, c) {\n        for (var u = 0; u < c.length; u++) {\n          var h = c[u];\n          h.enumerable = h.enumerable || !1, h.configurable = !0, \"value\" in h && (h.writable = !0), Object.defineProperty(l, h.key, h);\n        }\n      }\n      function r(l, c, u) {\n        return c && n(l.prototype, c), u && n(l, u), l;\n      }\n      /**\n       * Base Paragraph Block for the Editor.js.\n       * Represents simple paragraph\n       *\n       * @author CodeX (team@codex.so)\n       * @copyright CodeX 2018\n       * @license The MIT License (MIT)\n       */\n      var a = function() {\n        function l(c) {\n          var u = c.data, h = c.config, f = c.api, v = c.readOnly;\n          (function(p, k) {\n            if (!(p instanceof k))\n              throw new TypeError(\"Cannot call a class as a function\");\n          })(this, l), this.api = f, this.readOnly = v, this._CSS = { block: this.api.styles.block, wrapper: \"ce-paragraph\" }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = h.placeholder ? h.placeholder : l.DEFAULT_PLACEHOLDER, this._data = {}, this._element = this.drawView(), this._preserveBlank = h.preserveBlank !== void 0 && h.preserveBlank, this.data = u;\n        }\n        return r(l, null, [{ key: \"DEFAULT_PLACEHOLDER\", get: function() {\n          return \"\";\n        } }]), r(l, [{ key: \"onKeyUp\", value: function(c) {\n          c.code !== \"Backspace\" && c.code !== \"Delete\" || this._element.textContent === \"\" && (this._element.innerHTML = \"\");\n        } }, { key: \"drawView\", value: function() {\n          var c = document.createElement(\"DIV\");\n          return c.classList.add(this._CSS.wrapper, this._CSS.block), c.contentEditable = !1, c.dataset.placeholder = this.api.i18n.t(this._placeholder), this.readOnly || (c.contentEditable = !0, c.addEventListener(\"keyup\", this.onKeyUp)), c;\n        } }, { key: \"render\", value: function() {\n          return this._element;\n        } }, { key: \"merge\", value: function(c) {\n          var u = { text: this.data.text + c.text };\n          this.data = u;\n        } }, { key: \"validate\", value: function(c) {\n          return !(c.text.trim() === \"\" && !this._preserveBlank);\n        } }, { key: \"save\", value: function(c) {\n          return { text: c.innerHTML };\n        } }, { key: \"onPaste\", value: function(c) {\n          var u = { text: c.detail.data.innerHTML };\n          this.data = u;\n        } }, { key: \"data\", get: function() {\n          var c = this._element.innerHTML;\n          return this._data.text = c, this._data;\n        }, set: function(c) {\n          this._data = c || {}, this._element.innerHTML = this._data.text || \"\";\n        } }], [{ key: \"conversionConfig\", get: function() {\n          return { export: \"text\", import: \"text\" };\n        } }, { key: \"sanitize\", get: function() {\n          return { text: { br: !0 } };\n        } }, { key: \"isReadOnlySupported\", get: function() {\n          return !0;\n        } }, { key: \"pasteConfig\", get: function() {\n          return { tags: [\"P\"] };\n        } }, { key: \"toolbox\", get: function() {\n          return { icon: '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>', title: \"Text\" };\n        } }]), l;\n      }();\n    }]).default;\n  });\n})(ei);\nconst ti = /* @__PURE__ */ xe(Ne);\nclass $e {\n  constructor() {\n    this.commandName = \"bold\", this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--bold\"\n    }, this.nodes = {\n      button: void 0\n    };\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <b> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      b: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Eo, this.nodes.button;\n  }\n  /**\n   * Wrap range with <b> tag\n   */\n  surround() {\n    document.execCommand(this.commandName);\n  }\n  /**\n   * Check selection and set activated state to button if there are <b> tag\n   *\n   * @returns {boolean}\n   */\n  checkState() {\n    const e = document.queryCommandState(this.commandName);\n    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;\n  }\n  /**\n   * Set a shortcut\n   *\n   * @returns {boolean}\n   */\n  get shortcut() {\n    return \"CMD+B\";\n  }\n}\n$e.isInline = !0;\n$e.title = \"Bold\";\nclass We {\n  constructor() {\n    this.commandName = \"italic\", this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--italic\"\n    }, this.nodes = {\n      button: null\n    };\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <i> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      i: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = So, this.nodes.button;\n  }\n  /**\n   * Wrap range with <i> tag\n   */\n  surround() {\n    document.execCommand(this.commandName);\n  }\n  /**\n   * Check selection and set activated state to button if there are <i> tag\n   */\n  checkState() {\n    const e = document.queryCommandState(this.commandName);\n    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+I\";\n  }\n}\nWe.isInline = !0;\nWe.title = \"Italic\";\nclass Ye {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.commandLink = \"createLink\", this.commandUnlink = \"unlink\", this.ENTER_KEY = 13, this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--link\",\n      buttonUnlink: \"ce-inline-tool--unlink\",\n      input: \"ce-inline-tool-input\",\n      inputShowed: \"ce-inline-tool-input--showed\"\n    }, this.nodes = {\n      button: null,\n      input: null\n    }, this.inputOpened = !1, this.toolbar = e.toolbar, this.inlineToolbar = e.inlineToolbar, this.notifier = e.notifier, this.i18n = e.i18n, this.selection = new m();\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <a> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      a: {\n        href: !0,\n        target: \"_blank\",\n        rel: \"nofollow\"\n      }\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = qe, this.nodes.button;\n  }\n  /**\n   * Input for the link\n   */\n  renderActions() {\n    return this.nodes.input = document.createElement(\"input\"), this.nodes.input.placeholder = this.i18n.t(\"Add a link\"), this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener(\"keydown\", (e) => {\n      e.keyCode === this.ENTER_KEY && this.enterPressed(e);\n    }), this.nodes.input;\n  }\n  /**\n   * Handle clicks on the Inline Toolbar icon\n   *\n   * @param {Range} range - range to wrap with link\n   */\n  surround(e) {\n    if (e) {\n      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());\n      const t = this.selection.findParentTag(\"A\");\n      if (t) {\n        this.selection.expandToTag(t), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();\n        return;\n      }\n    }\n    this.toggleActions();\n  }\n  /**\n   * Check selection and set activated state to button if there are <a> tag\n   */\n  checkState() {\n    const e = this.selection.findParentTag(\"A\");\n    if (e) {\n      this.nodes.button.innerHTML = Oo, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();\n      const t = e.getAttribute(\"href\");\n      this.nodes.input.value = t !== \"null\" ? t : \"\", this.selection.save();\n    } else\n      this.nodes.button.innerHTML = qe, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);\n    return !!e;\n  }\n  /**\n   * Function called with Inline Toolbar closing\n   */\n  clear() {\n    this.closeActions();\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+K\";\n  }\n  /**\n   * Show/close link input\n   */\n  toggleActions() {\n    this.inputOpened ? this.closeActions(!1) : this.openActions(!0);\n  }\n  /**\n   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.\n   */\n  openActions(e = !1) {\n    this.nodes.input.classList.add(this.CSS.inputShowed), e && this.nodes.input.focus(), this.inputOpened = !0;\n  }\n  /**\n   * Close input\n   *\n   * @param {boolean} clearSavedSelection — we don't need to clear saved selection\n   *                                        on toggle-clicks on the icon of opened Toolbar\n   */\n  closeActions(e = !0) {\n    if (this.selection.isFakeBackgroundEnabled) {\n      const t = new m();\n      t.save(), this.selection.restore(), this.selection.removeFakeBackground(), t.restore();\n    }\n    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = \"\", e && this.selection.clearSaved(), this.inputOpened = !1;\n  }\n  /**\n   * Enter pressed on input\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  enterPressed(e) {\n    let t = this.nodes.input.value || \"\";\n    if (!t.trim()) {\n      this.selection.restore(), this.unlink(), e.preventDefault(), this.closeActions();\n      return;\n    }\n    if (!this.validateURL(t)) {\n      this.notifier.show({\n        message: \"Pasted link is not valid.\",\n        style: \"error\"\n      }), T(\"Incorrect Link pasted\", \"warn\", t);\n      return;\n    }\n    t = this.prepareLink(t), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();\n  }\n  /**\n   * Detects if passed string is URL\n   *\n   * @param {string} str - string to validate\n   * @returns {boolean}\n   */\n  validateURL(e) {\n    return !/\\s/.test(e);\n  }\n  /**\n   * Process link before injection\n   * - sanitize\n   * - add protocol for links like 'google.com'\n   *\n   * @param {string} link - raw user input\n   */\n  prepareLink(e) {\n    return e = e.trim(), e = this.addProtocol(e), e;\n  }\n  /**\n   * Add 'http' protocol to the links like 'vc.ru', 'google.com'\n   *\n   * @param {string} link - string to process\n   */\n  addProtocol(e) {\n    if (/^(\\w+):(\\/\\/)?/.test(e))\n      return e;\n    const t = /^\\/[^/\\s]/.test(e), o = e.substring(0, 1) === \"#\", i = /^\\/\\/[^/\\s]/.test(e);\n    return !t && !o && !i && (e = \"http://\" + e), e;\n  }\n  /**\n   * Inserts <a> tag with \"href\"\n   *\n   * @param {string} link - \"href\" value\n   */\n  insertLink(e) {\n    const t = this.selection.findParentTag(\"A\");\n    t && this.selection.expandToTag(t), document.execCommand(this.commandLink, !1, e);\n  }\n  /**\n   * Removes <a> tag\n   */\n  unlink() {\n    document.execCommand(this.commandUnlink);\n  }\n}\nYe.isInline = !0;\nYe.title = \"Link\";\nclass yt {\n  /**\n   * @param options - constructor options\n   * @param options.data - stub tool data\n   * @param options.api - Editor.js API\n   */\n  constructor({ data: e, api: t }) {\n    this.CSS = {\n      wrapper: \"ce-stub\",\n      info: \"ce-stub__info\",\n      title: \"ce-stub__title\",\n      subtitle: \"ce-stub__subtitle\"\n    }, this.api = t, this.title = e.title || this.api.i18n.t(\"Error\"), this.subtitle = this.api.i18n.t(\"The block can not be displayed correctly.\"), this.savedData = e.savedData, this.wrapper = this.make();\n  }\n  /**\n   * Returns stub holder\n   *\n   * @returns {HTMLElement}\n   */\n  render() {\n    return this.wrapper;\n  }\n  /**\n   * Return original Tool data\n   *\n   * @returns {BlockToolData}\n   */\n  save() {\n    return this.savedData;\n  }\n  /**\n   * Create Tool html markup\n   *\n   * @returns {HTMLElement}\n   */\n  make() {\n    const e = d.make(\"div\", this.CSS.wrapper), t = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"52\" height=\"52\" viewBox=\"0 0 52 52\"><path fill=\"#D76B6B\" fill-rule=\"nonzero\" d=\"M26 52C11.64 52 0 40.36 0 26S11.64 0 26 0s26 11.64 26 26-11.64 26-26 26zm0-3.25c12.564 0 22.75-10.186 22.75-22.75S38.564 3.25 26 3.25 3.25 13.436 3.25 26 13.436 48.75 26 48.75zM15.708 33.042a2.167 2.167 0 1 1 0-4.334 2.167 2.167 0 0 1 0 4.334zm23.834 0a2.167 2.167 0 1 1 0-4.334 2.167 2.167 0 0 1 0 4.334zm-15.875 5.452a1.083 1.083 0 1 1-1.834-1.155c1.331-2.114 3.49-3.179 6.334-3.179 2.844 0 5.002 1.065 6.333 3.18a1.083 1.083 0 1 1-1.833 1.154c-.913-1.45-2.366-2.167-4.5-2.167s-3.587.717-4.5 2.167z\"/></svg>', o = d.make(\"div\", this.CSS.info), i = d.make(\"div\", this.CSS.title, {\n      textContent: this.title\n    }), n = d.make(\"div\", this.CSS.subtitle, {\n      textContent: this.subtitle\n    });\n    return e.innerHTML = t, o.appendChild(i), o.appendChild(n), e.appendChild(o), e;\n  }\n}\nyt.isReadOnlySupported = !0;\nclass oi extends Ue {\n  constructor() {\n    super(...arguments), this.type = ye.Inline;\n  }\n  /**\n   * Returns title for Inline Tool if specified by user\n   */\n  get title() {\n    return this.constructable[je.Title];\n  }\n  /**\n   * Constructs new InlineTool instance from constructable\n   */\n  create() {\n    return new this.constructable({\n      api: this.api.getMethodsForTool(this),\n      config: this.settings\n    });\n  }\n}\nclass ii extends Ue {\n  constructor() {\n    super(...arguments), this.type = ye.Tune;\n  }\n  /**\n   * Constructs new BlockTune instance from constructable\n   *\n   * @param data - Tune data\n   * @param block - Block API object\n   */\n  create(e, t) {\n    return new this.constructable({\n      api: this.api.getMethodsForTool(this),\n      config: this.settings,\n      block: t,\n      data: e\n    });\n  }\n}\nclass U extends Map {\n  /**\n   * Returns Block Tools collection\n   */\n  get blockTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isBlock());\n    return new U(e);\n  }\n  /**\n   * Returns Inline Tools collection\n   */\n  get inlineTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInline());\n    return new U(e);\n  }\n  /**\n   * Returns Block Tunes collection\n   */\n  get blockTunes() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isTune());\n    return new U(e);\n  }\n  /**\n   * Returns internal Tools collection\n   */\n  get internalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInternal);\n    return new U(e);\n  }\n  /**\n   * Returns Tools collection provided by user\n   */\n  get externalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => !t.isInternal);\n    return new U(e);\n  }\n}\nvar ni = Object.defineProperty, si = Object.getOwnPropertyDescriptor, Et = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? si(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && ni(e, t, i), i;\n};\nclass Ke extends Ue {\n  constructor() {\n    super(...arguments), this.type = ye.Block, this.inlineTools = new U(), this.tunes = new U();\n  }\n  /**\n   * Creates new Tool instance\n   *\n   * @param data - Tool data\n   * @param block - BlockAPI for current Block\n   * @param readOnly - True if Editor is in read-only mode\n   */\n  create(e, t, o) {\n    return new this.constructable({\n      data: e,\n      block: t,\n      readOnly: o,\n      api: this.api.getMethodsForTool(this),\n      config: this.settings\n    });\n  }\n  /**\n   * Returns true if read-only mode is supported by Tool\n   */\n  get isReadOnlySupported() {\n    return this.constructable[se.IsReadOnlySupported] === !0;\n  }\n  /**\n   * Returns true if Tool supports linebreaks\n   */\n  get isLineBreaksEnabled() {\n    return this.constructable[se.IsEnabledLineBreaks];\n  }\n  /**\n   * Returns Tool toolbox configuration (internal or user-specified).\n   *\n   * Merges internal and user-defined toolbox configs based on the following rules:\n   *\n   * - If both internal and user-defined toolbox configs are arrays their items are merged.\n   * Length of the second one is kept.\n   *\n   * - If both are objects their properties are merged.\n   *\n   * - If one is an object and another is an array than internal config is replaced with user-defined\n   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)\n   */\n  get toolbox() {\n    const e = this.constructable[se.Toolbox], t = this.config[me.Toolbox];\n    if (!V(e) && t !== !1)\n      return t ? Array.isArray(e) ? Array.isArray(t) ? t.map((o, i) => {\n        const n = e[i];\n        return n ? {\n          ...n,\n          ...o\n        } : o;\n      }) : [t] : Array.isArray(t) ? t : [\n        {\n          ...e,\n          ...t\n        }\n      ] : Array.isArray(e) ? e : [e];\n  }\n  /**\n   * Returns Tool conversion configuration\n   */\n  get conversionConfig() {\n    return this.constructable[se.ConversionConfig];\n  }\n  /**\n   * Returns enabled inline tools for Tool\n   */\n  get enabledInlineTools() {\n    return this.config[me.EnabledInlineTools] || !1;\n  }\n  /**\n   * Returns enabled tunes for Tool\n   */\n  get enabledBlockTunes() {\n    return this.config[me.EnabledBlockTunes];\n  }\n  /**\n   * Returns Tool paste configuration\n   */\n  get pasteConfig() {\n    return this.constructable[se.PasteConfig] ?? {};\n  }\n  get sanitizeConfig() {\n    const e = super.sanitizeConfig, t = this.baseSanitizeConfig;\n    if (V(e))\n      return t;\n    const o = {};\n    for (const i in e)\n      if (Object.prototype.hasOwnProperty.call(e, i)) {\n        const n = e[i];\n        j(n) ? o[i] = Object.assign({}, t, n) : o[i] = n;\n      }\n    return o;\n  }\n  get baseSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), e;\n  }\n}\nEt([\n  ae\n], Ke.prototype, \"sanitizeConfig\", 1);\nEt([\n  ae\n], Ke.prototype, \"baseSanitizeConfig\", 1);\nclass ri {\n  /**\n   * @class\n   * @param config - tools config\n   * @param editorConfig - EditorJS config\n   * @param api - EditorJS API module\n   */\n  constructor(e, t, o) {\n    this.api = o, this.config = e, this.editorConfig = t;\n  }\n  /**\n   * Returns Tool object based on it's type\n   *\n   * @param name - tool name\n   */\n  get(e) {\n    const { class: t, isInternal: o = !1, ...i } = this.config[e], n = this.getConstructor(t);\n    return new n({\n      name: e,\n      constructable: t,\n      config: i,\n      api: this.api,\n      isDefault: e === this.editorConfig.defaultBlock,\n      defaultPlaceholder: this.editorConfig.placeholder,\n      isInternal: o\n    });\n  }\n  /**\n   * Find appropriate Tool object constructor for Tool constructable\n   *\n   * @param constructable - Tools constructable\n   */\n  getConstructor(e) {\n    switch (!0) {\n      case e[je.IsInline]:\n        return oi;\n      case e[vt.IsTune]:\n        return ii;\n      default:\n        return Ke;\n    }\n  }\n}\nclass Bt {\n  /**\n   * MoveDownTune constructor\n   *\n   * @param {API} api — Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: pt,\n      title: this.api.i18n.t(\"Move down\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-down\"\n    };\n  }\n  /**\n   * Handle clicks on 'move down' button\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e + 1);\n    if (!t)\n      throw new Error(\"Unable to move Block down since it is already the last\");\n    const o = t.holder, i = o.getBoundingClientRect();\n    let n = Math.abs(window.innerHeight - o.offsetHeight);\n    i.top < window.innerHeight && (n = window.scrollY + o.offsetHeight), window.scrollTo(0, n), this.api.blocks.move(e + 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nBt.isTune = !0;\nclass Ct {\n  /**\n   * DeleteTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Co,\n      title: this.api.i18n.t(\"Delete\"),\n      name: \"delete\",\n      confirmation: {\n        title: this.api.i18n.t(\"Click to delete\"),\n        onActivate: () => this.handleClick()\n      }\n    };\n  }\n  /**\n   * Delete block conditions passed\n   */\n  handleClick() {\n    this.api.blocks.delete();\n  }\n}\nCt.isTune = !0;\nclass Tt {\n  /**\n   * MoveUpTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Bo,\n      title: this.api.i18n.t(\"Move up\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-up\"\n    };\n  }\n  /**\n   * Move current block up\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e), o = this.api.blocks.getBlockByIndex(e - 1);\n    if (e === 0 || !t || !o)\n      throw new Error(\"Unable to move Block up since it is already the first\");\n    const i = t.holder, n = o.holder, r = i.getBoundingClientRect(), a = n.getBoundingClientRect();\n    let l;\n    a.top > 0 ? l = Math.abs(r.top) - Math.abs(a.top) : l = Math.abs(r.top) + a.height, window.scrollBy(0, -1 * l), this.api.blocks.move(e - 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nTt.isTune = !0;\nvar ai = Object.defineProperty, li = Object.getOwnPropertyDescriptor, ci = (s, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? li(e, t) : e, n = s.length - 1, r; n >= 0; n--)\n    (r = s[n]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && ai(e, t, i), i;\n};\nclass St extends S {\n  constructor() {\n    super(...arguments), this.stubTool = \"stub\", this.toolsAvailable = new U(), this.toolsUnavailable = new U();\n  }\n  /**\n   * Returns available Tools\n   */\n  get available() {\n    return this.toolsAvailable;\n  }\n  /**\n   * Returns unavailable Tools\n   */\n  get unavailable() {\n    return this.toolsUnavailable;\n  }\n  /**\n   * Return Tools for the Inline Toolbar\n   */\n  get inlineTools() {\n    return this.available.inlineTools;\n  }\n  /**\n   * Return editor block tools\n   */\n  get blockTools() {\n    return this.available.blockTools;\n  }\n  /**\n   * Return available Block Tunes\n   *\n   * @returns {object} - object of Inline Tool's classes\n   */\n  get blockTunes() {\n    return this.available.blockTunes;\n  }\n  /**\n   * Returns default Tool object\n   */\n  get defaultTool() {\n    return this.blockTools.get(this.config.defaultBlock);\n  }\n  /**\n   * Returns internal tools\n   */\n  get internal() {\n    return this.available.internalTools;\n  }\n  /**\n   * Creates instances via passed or default configuration\n   *\n   * @returns {Promise<void>}\n   */\n  async prepare() {\n    if (this.validateTools(), this.config.tools = Se({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, \"tools\") || Object.keys(this.config.tools).length === 0)\n      throw Error(\"Can't start without tools\");\n    const e = this.prepareConfig();\n    this.factory = new ri(e, this.config, this.Editor.API);\n    const t = this.getListOfPrepareFunctions(e);\n    if (t.length === 0)\n      return Promise.resolve();\n    await ot(t, (o) => {\n      this.toolPrepareMethodSuccess(o);\n    }, (o) => {\n      this.toolPrepareMethodFallback(o);\n    }), this.prepareBlockTools();\n  }\n  getAllInlineToolsSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => {\n      Object.assign(e, t.sanitizeConfig);\n    }), e;\n  }\n  /**\n   * Calls each Tool reset method to clean up anything set by Tool\n   */\n  destroy() {\n    Object.values(this.available).forEach(async (e) => {\n      D(e.reset) && await e.reset();\n    });\n  }\n  /**\n   * Returns internal tools\n   * Includes Bold, Italic, Link and Paragraph\n   */\n  get internalTools() {\n    return {\n      bold: {\n        class: $e,\n        isInternal: !0\n      },\n      italic: {\n        class: We,\n        isInternal: !0\n      },\n      link: {\n        class: Ye,\n        isInternal: !0\n      },\n      paragraph: {\n        class: ti,\n        inlineToolbar: !0,\n        isInternal: !0\n      },\n      stub: {\n        class: yt,\n        isInternal: !0\n      },\n      moveUp: {\n        class: Tt,\n        isInternal: !0\n      },\n      delete: {\n        class: Ct,\n        isInternal: !0\n      },\n      moveDown: {\n        class: Bt,\n        isInternal: !0\n      }\n    };\n  }\n  /**\n   * Tool prepare method success callback\n   *\n   * @param {object} data - append tool to available list\n   */\n  toolPrepareMethodSuccess(e) {\n    const t = this.factory.get(e.toolName);\n    if (t.isInline()) {\n      const i = [\"render\", \"surround\", \"checkState\"].filter((n) => !t.create()[n]);\n      if (i.length) {\n        T(\n          `Incorrect Inline Tool: ${t.name}. Some of required methods is not implemented %o`,\n          \"warn\",\n          i\n        ), this.toolsUnavailable.set(t.name, t);\n        return;\n      }\n    }\n    this.toolsAvailable.set(t.name, t);\n  }\n  /**\n   * Tool prepare method fail callback\n   *\n   * @param {object} data - append tool to unavailable list\n   */\n  toolPrepareMethodFallback(e) {\n    this.toolsUnavailable.set(e.toolName, this.factory.get(e.toolName));\n  }\n  /**\n   * Binds prepare function of plugins with user or default config\n   *\n   * @returns {Array} list of functions that needs to be fired sequentially\n   * @param config - tools config\n   */\n  getListOfPrepareFunctions(e) {\n    const t = [];\n    return Object.entries(e).forEach(([o, i]) => {\n      t.push({\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function: D(i.class.prepare) ? i.class.prepare : () => {\n        },\n        data: {\n          toolName: o,\n          config: i.config\n        }\n      });\n    }), t;\n  }\n  /**\n   * Assign enabled Inline Tools and Block Tunes for Block Tool\n   */\n  prepareBlockTools() {\n    Array.from(this.blockTools.values()).forEach((e) => {\n      this.assignInlineToolsToBlockTool(e), this.assignBlockTunesToBlockTool(e);\n    });\n  }\n  /**\n   * Assign enabled Inline Tools for Block Tool\n   *\n   * @param tool - Block Tool\n   */\n  assignInlineToolsToBlockTool(e) {\n    if (this.config.inlineToolbar !== !1) {\n      if (e.enabledInlineTools === !0) {\n        e.inlineTools = new U(\n          Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t) => [t, this.inlineTools.get(t)]) : Array.from(this.inlineTools.entries())\n        );\n        return;\n      }\n      Array.isArray(e.enabledInlineTools) && (e.inlineTools = new U(\n        e.enabledInlineTools.map((t) => [t, this.inlineTools.get(t)])\n      ));\n    }\n  }\n  /**\n   * Assign enabled Block Tunes for Block Tool\n   *\n   * @param tool — Block Tool\n   */\n  assignBlockTunesToBlockTool(e) {\n    if (e.enabledBlockTunes !== !1) {\n      if (Array.isArray(e.enabledBlockTunes)) {\n        const t = new U(\n          e.enabledBlockTunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new U([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      if (Array.isArray(this.config.tunes)) {\n        const t = new U(\n          this.config.tunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new U([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      e.tunes = this.blockTunes.internalTools;\n    }\n  }\n  /**\n   * Validate Tools configuration objects and throw Error for user if it is invalid\n   */\n  validateTools() {\n    for (const e in this.config.tools)\n      if (Object.prototype.hasOwnProperty.call(this.config.tools, e)) {\n        if (e in this.internalTools)\n          return;\n        const t = this.config.tools[e];\n        if (!D(t) && !D(t.class))\n          throw Error(\n            `Tool «${e}» must be a constructor function or an object with function in the «class» property`\n          );\n      }\n  }\n  /**\n   * Unify tools config\n   */\n  prepareConfig() {\n    const e = {};\n    for (const t in this.config.tools)\n      j(this.config.tools[t]) ? e[t] = this.config.tools[t] : e[t] = { class: this.config.tools[t] };\n    return e;\n  }\n}\nci([\n  ae\n], St.prototype, \"getAllInlineToolsSanitizeConfig\", 1);\nconst di = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide,.codex-editor__redactor--hidden{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:\"\\\\feff\"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor__loader{position:relative;height:30vh}.codex-editor__loader:before{content:\"\";position:absolute;left:50%;top:50%;width:30px;height:30px;margin-top:-15px;margin-left:-15px;border-radius:50%;border:2px solid rgba(201,201,204,.48);border-top-color:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-animation:editor-loader-spin .8s infinite linear;animation:editor-loader-spin .8s infinite linear;will-change:transform}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}::-moz-selection{background-color:#d4ecff}::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}@-webkit-keyframes editor-loader-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes editor-loader-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;-webkit-transform:translateX(-50%) translateY(8px) scale(.94);transform:translate(-50%) translateY(8px) scale(.94);opacity:0;visibility:hidden;-webkit-transition:opacity .25s ease,-webkit-transform .15s ease;transition:opacity .25s ease,-webkit-transform .15s ease;transition:transform .15s ease,opacity .25s ease;transition:transform .15s ease,opacity .25s ease,-webkit-transform .15s ease;will-change:transform,opacity;top:0;left:0;z-index:3}.ce-inline-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-inline-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-inline-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:translateX(-50%);transform:translate(-50%)}.ce-inline-toolbar--left-oriented{-webkit-transform:translateX(-23px) translateY(8px) scale(.94);transform:translate(-23px) translateY(8px) scale(.94)}.ce-inline-toolbar--left-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-23px);transform:translate(-23px)}.ce-inline-toolbar--right-oriented{-webkit-transform:translateX(-100%) translateY(8px) scale(.94);transform:translate(-100%) translateY(8px) scale(.94);margin-left:23px}.ce-inline-toolbar--right-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-100%);transform:translate(-100%)}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;border-radius:0;line-height:normal}.ce-inline-tool svg{width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#eff2f5}}.ce-inline-tool--active{color:#388ae5}.ce-inline-tool--focused{background:rgba(34,186,255,.08)!important}.ce-inline-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-inline-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{outline:none;border:0;border-radius:0 0 4px 4px;margin:0;font-size:13px;padding:10px;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;border-top:1px solid rgba(201,201,204,.48);-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-conversion-toolbar{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;opacity:0;visibility:hidden;will-change:transform,opacity;-webkit-transition:opacity .1s ease,-webkit-transform .1s ease;transition:opacity .1s ease,-webkit-transform .1s ease;transition:transform .1s ease,opacity .1s ease;transition:transform .1s ease,opacity .1s ease,-webkit-transform .1s ease;-webkit-transform:translateY(-8px);transform:translateY(-8px);left:-1px;width:150px;margin-top:5px;-webkit-box-sizing:content-box;box-sizing:content-box}.ce-conversion-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-conversion-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-conversion-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:none;transform:none}.ce-conversion-toolbar [hidden]{display:none!important}.ce-conversion-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-conversion-toolbar__label{color:#707684;font-size:11px;font-weight:500;letter-spacing:.33px;padding:10px 10px 5px;text-transform:uppercase}.ce-conversion-tool{display:-webkit-box;display:-ms-flexbox;display:flex;padding:5px 10px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-conversion-tool--hidden{display:none}.ce-conversion-tool--focused{background:rgba(34,186,255,.08)!important}.ce-conversion-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-conversion-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-conversion-tool:hover{background:#eff2f5}.ce-conversion-tool__icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px rgba(201,201,204,.48);box-shadow:0 0 0 1px #c9c9cc7a;border-radius:5px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;background:#fff;-webkit-box-sizing:content-box;box-sizing:content-box;-ms-flex-negative:0;flex-shrink:0;margin-right:10px}.ce-conversion-tool__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-conversion-tool__icon{width:36px;height:36px;border-radius:8px}.ce-conversion-tool__icon svg{width:28px;height:28px}}.ce-conversion-tool--last{margin-right:0!important}.ce-conversion-tool--active{color:#388ae5!important}.ce-conversion-tool--active{-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-settings__button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;line-height:32px}.ce-settings__button svg{width:20px;height:20px}@media (max-width: 650px){.ce-settings__button svg{width:28px;height:28px}}@media (hover: hover){.ce-settings__button:hover{background-color:#eff2f5}}.ce-settings__button--active{color:#388ae5}.ce-settings__button--focused{background:rgba(34,186,255,.08)!important}.ce-settings__button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-settings__button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-settings__button:not(:nth-child(3n+3)){margin-right:3px}.ce-settings__button:nth-child(n+4){margin-top:3px}.ce-settings__button--disabled{cursor:not-allowed!important}.ce-settings__button--disabled{opacity:.3}.ce-settings__button--selected{color:#388ae5}@media (min-width: 651px){.codex-editor--narrow .ce-settings .ce-popover{right:0;left:auto;left:initial}}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:\"\";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:\"\";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@media (min-width: 651px){.codex-editor--narrow .ce-block--focused{margin-right:-50px;padding-right:50px}}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button svg{width:20px;height:20px}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:\"\";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;padding:3.5em 0;margin:17px 0;border-radius:3px;background:#fcf7f7;color:#b46262}.ce-stub__info{margin-left:20px}.ce-stub__title{margin-bottom:3px;font-weight:600;font-size:18px;text-transform:capitalize}.ce-stub__subtitle{font-size:16px}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0px;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:rgba(232,232,235,.49);border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #e8e8eb;--color-shadow: rgba(13,20,33,.13);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #eff2f5;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:0;top:calc(100% + var(--offset-from-target));background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}.ce-popover--open-top{top:calc(-1 * (var(--offset-from-target) + var(--popover-height)))}@media (max-width: 650px){.ce-popover{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}.ce-popover .ce-popover__search{display:none}}.ce-popover__search,.ce-popover__custom-content:not(:empty){margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover__custom-content:not(:empty){padding:4px}@media (min-width: 651px){.ce-popover__custom-content:not(:empty){padding:0}}.ce-popover__custom-content--hidden{display:none}.ce-popover-item{--border-radius: 6px;--icon-size: 20px;--icon-size-mobile: 28px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:3px;color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{border-radius:5px;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px var(--color-border-icon);box-shadow:0 0 0 1px var(--color-border-icon);background:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:10px}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:var(--icon-size-mobile);height:var(--icon-size-mobile)}}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--active .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--disabled .ce-popover-item__icon{-webkit-box-shadow:0 0 0 1px var(--color-border-icon-disabled);box-shadow:0 0 0 1px var(--color-border-icon-disabled)}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--focused:not(.ce-popover-item--no-focus){-webkit-box-shadow:inset 0 0 0px 1px var(--color-shadow-item-focus);box-shadow:inset 0 0 0 1px var(--color-shadow-item-focus)}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}.ce-popover-item:hover .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__icon{color:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}.ce-popover-item--confirmation .ce-popover-item__icon,.ce-popover-item--active .ce-popover-item__icon,.ce-popover-item--focused .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}\n`;\nclass hi extends S {\n  constructor() {\n    super(...arguments), this.isMobile = !1, this.contentRectCache = void 0, this.resizeDebouncer = Pt(() => {\n      this.windowResize();\n    }, 200);\n  }\n  /**\n   * Editor.js UI CSS class names\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorWrapperNarrow: \"codex-editor--narrow\",\n      editorZone: \"codex-editor__redactor\",\n      editorZoneHidden: \"codex-editor__redactor--hidden\",\n      editorLoader: \"codex-editor__loader\",\n      editorEmpty: \"codex-editor--empty\",\n      editorRtlFix: \"codex-editor--rtl\"\n    };\n  }\n  /**\n   * Return Width of center column of Editor\n   *\n   * @returns {DOMRect}\n   */\n  get contentRect() {\n    if (this.contentRectCache)\n      return this.contentRectCache;\n    const e = this.nodes.wrapper.querySelector(`.${F.CSS.content}`);\n    return e ? (this.contentRectCache = e.getBoundingClientRect(), this.contentRectCache) : {\n      width: 650,\n      left: 0,\n      right: 0\n    };\n  }\n  /**\n   * Adds loader to editor while content is not ready\n   */\n  addLoader() {\n    this.nodes.loader = d.make(\"div\", this.CSS.editorLoader), this.nodes.wrapper.prepend(this.nodes.loader), this.nodes.redactor.classList.add(this.CSS.editorZoneHidden);\n  }\n  /**\n   * Removes loader when content has loaded\n   */\n  removeLoader() {\n    this.nodes.loader.remove(), this.nodes.redactor.classList.remove(this.CSS.editorZoneHidden);\n  }\n  /**\n   * Making main interface\n   */\n  async prepare() {\n    this.checkIsMobile(), this.make(), this.addLoader(), this.loadStyles();\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - removes all listeners from main UI module elements\n   *\n   * if readOnly is false:\n   *  - enables all listeners to UI module elements\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Check if Editor is empty and set CSS class to wrapper\n   */\n  checkEmptiness() {\n    const { BlockManager: e } = this.Editor;\n    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e.isEditorEmpty);\n  }\n  /**\n   * Check if one of Toolbar is opened\n   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar\n   *\n   * @returns {boolean}\n   */\n  get someToolbarOpened() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o, ConversionToolbar: i } = this.Editor;\n    return t.opened || o.opened || i.opened || e.toolbox.opened;\n  }\n  /**\n   * Check for some Flipper-buttons is under focus\n   */\n  get someFlipperButtonFocused() {\n    return this.Editor.Toolbar.toolbox.hasFocus() ? !0 : Object.entries(this.Editor).filter(([e, t]) => t.flipper instanceof G).some(([e, t]) => t.flipper.hasFocus());\n  }\n  /**\n   * Clean editor`s UI\n   */\n  destroy() {\n    this.nodes.holder.innerHTML = \"\";\n  }\n  /**\n   * Close all Editor's toolbars\n   */\n  closeAllToolbars() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o, ConversionToolbar: i } = this.Editor;\n    t.close(), o.close(), i.close(), e.toolbox.close();\n  }\n  /**\n   * Check for mobile mode and cache a result\n   */\n  checkIsMobile() {\n    this.isMobile = window.innerWidth < st;\n  }\n  /**\n   * Makes Editor.js interface\n   */\n  make() {\n    this.nodes.holder = d.getHolder(this.config.holder), this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.editorWrapper,\n      ...this.isRtl ? [this.CSS.editorRtlFix] : []\n    ]), this.nodes.redactor = d.make(\"div\", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + \"px\", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper);\n  }\n  /**\n   * Appends CSS\n   */\n  loadStyles() {\n    const e = \"editor-js-styles\";\n    if (d.get(e))\n      return;\n    const t = d.make(\"style\", null, {\n      id: e,\n      textContent: di.toString()\n    });\n    d.prepend(document.head, t);\n  }\n  /**\n   * Bind events on the Editor.js interface\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"click\", (e) => {\n      this.redactorClicked(e);\n    }, !1), this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousedown\", (e) => {\n      this.documentTouched(e);\n    }, !0), this.readOnlyMutableListeners.on(this.nodes.redactor, \"touchstart\", (e) => {\n      this.documentTouched(e);\n    }, !0), this.readOnlyMutableListeners.on(document, \"keydown\", (e) => {\n      this.documentKeydown(e);\n    }, !0), this.readOnlyMutableListeners.on(document, \"mousedown\", (e) => {\n      this.documentClicked(e);\n    }, !0), this.readOnlyMutableListeners.on(document, \"selectionchange\", () => {\n      this.selectionChanged();\n    }, !0), this.readOnlyMutableListeners.on(window, \"resize\", () => {\n      this.resizeDebouncer();\n    }, {\n      passive: !0\n    }), this.watchBlockHoveredEvents();\n  }\n  /**\n   * Listen redactor mousemove to emit 'block-hovered' event\n   */\n  watchBlockHoveredEvents() {\n    let e;\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousemove\", Te((t) => {\n      const o = t.target.closest(\".ce-block\");\n      this.Editor.BlockSelection.anyBlockSelected || o && e !== o && (e = o, this.eventsDispatcher.emit(mt, {\n        block: this.Editor.BlockManager.getBlockByChildNode(o)\n      }));\n    }, 20), {\n      passive: !0\n    });\n  }\n  /**\n   * Unbind events on the Editor.js interface\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Resize window handler\n   */\n  windowResize() {\n    this.contentRectCache = null, this.checkIsMobile();\n  }\n  /**\n   * All keydowns on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  documentKeydown(e) {\n    switch (e.keyCode) {\n      case B.ENTER:\n        this.enterPressed(e);\n        break;\n      case B.BACKSPACE:\n        this.backspacePressed(e);\n        break;\n      case B.ESC:\n        this.escapePressed(e);\n        break;\n      default:\n        this.defaultBehaviour(e);\n        break;\n    }\n  }\n  /**\n   * Ignore all other document's keydown events\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  defaultBehaviour(e) {\n    const { currentBlock: t } = this.Editor.BlockManager, o = e.target.closest(`.${this.CSS.editorWrapper}`), i = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;\n    if (t !== void 0 && o === null) {\n      this.Editor.BlockEvents.keydown(e);\n      return;\n    }\n    o || t && i || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());\n  }\n  /**\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  backspacePressed(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor;\n    if (o.anyBlockSelected && !m.isSelectionExists) {\n      const n = t.removeSelectedBlocks();\n      i.setToBlock(t.insertDefaultBlockAtIndex(n, !0), i.positions.START), o.clearSelection(e), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation();\n    }\n  }\n  /**\n   * Escape pressed\n   * If some of Toolbar components are opened, then close it otherwise close Toolbar\n   *\n   * @param {Event} event - escape keydown event\n   */\n  escapePressed(e) {\n    this.Editor.BlockSelection.clearSelection(e), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.ConversionToolbar.opened ? this.Editor.ConversionToolbar.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();\n  }\n  /**\n   * Enter pressed on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  enterPressed(e) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor, i = t.currentBlockIndex >= 0;\n    if (o.anyBlockSelected && !m.isSelectionExists) {\n      o.clearSelection(e), e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();\n      return;\n    }\n    if (!this.someToolbarOpened && i && e.target.tagName === \"BODY\") {\n      const n = this.Editor.BlockManager.insert();\n      this.Editor.Caret.setToBlock(n), this.Editor.BlockManager.highlightCurrentNode(), this.Editor.Toolbar.moveAndOpen(n);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * All clicks on document\n   *\n   * @param {MouseEvent} event - Click event\n   */\n  documentClicked(e) {\n    if (!e.isTrusted)\n      return;\n    const t = e.target;\n    this.nodes.holder.contains(t) || m.isAtEditor || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());\n    const i = this.Editor.BlockSettings.nodes.wrapper.contains(t), n = this.Editor.Toolbar.nodes.settingsToggler.contains(t), r = i || n;\n    if (this.Editor.BlockSettings.opened && !r) {\n      this.Editor.BlockSettings.close();\n      const a = this.Editor.BlockManager.getBlockByChildNode(t);\n      this.Editor.Toolbar.moveAndOpen(a);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * First touch on editor\n   * Fired before click\n   *\n   * Used to change current block — we need to do it before 'selectionChange' event.\n   * Also:\n   * - Move and show the Toolbar\n   * - Set a Caret\n   *\n   * @param {MouseEvent | TouchEvent} event - touch or mouse event\n   */\n  documentTouched(e) {\n    let t = e.target;\n    if (t === this.nodes.redactor) {\n      const o = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, i = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;\n      t = document.elementFromPoint(o, i);\n    }\n    try {\n      this.Editor.BlockManager.setCurrentBlockByChildNode(t), this.Editor.BlockManager.highlightCurrentNode();\n    } catch {\n      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();\n    }\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * All clicks on the redactor zone\n   *\n   * @param {MouseEvent} event - click event\n   * @description\n   * - By clicks on the Editor's bottom zone:\n   *      - if last Block is empty, set a Caret to this\n   *      - otherwise, add a new empty Block and set a Caret to that\n   */\n  redactorClicked(e) {\n    const { BlockSelection: t } = this.Editor;\n    if (!m.isCollapsed)\n      return;\n    const o = () => {\n      e.stopImmediatePropagation(), e.stopPropagation();\n    }, i = e.target, n = e.metaKey || e.ctrlKey;\n    if (d.isAnchor(i) && n) {\n      o();\n      const u = i.getAttribute(\"href\"), h = Ht(u);\n      jt(h);\n      return;\n    }\n    const r = this.Editor.BlockManager.getBlockByIndex(-1), a = d.offset(r.holder).bottom, l = e.pageY;\n    if (e.target instanceof Element && e.target.isEqualNode(this.nodes.redactor) && /**\n    * If there is cross block selection started, target will be equal to redactor so we need additional check\n    */\n    !t.anyBlockSelected && /**\n    * Prevent caret jumping (to last block) when clicking between blocks\n    */\n    a < l) {\n      o();\n      const { BlockManager: u, Caret: h, Toolbar: f } = this.Editor;\n      (!u.lastBlock.tool.isDefault || !u.lastBlock.isEmpty) && u.insertAtEnd(), h.setToTheLastBlock(), f.moveAndOpen(u.lastBlock);\n    }\n  }\n  /**\n   * Handle selection changes on mobile devices\n   * Uses for showing the Inline Toolbar\n   */\n  selectionChanged() {\n    const { CrossBlockSelection: e, BlockSelection: t } = this.Editor, o = m.anchorElement;\n    if (e.isCrossBlockSelectionStarted && t.anyBlockSelected && m.get().removeAllRanges(), !o) {\n      m.range || this.Editor.InlineToolbar.close();\n      return;\n    }\n    const i = o.closest(`.${F.CSS.content}`) === null;\n    if (i && (this.Editor.InlineToolbar.containsNode(o) || this.Editor.InlineToolbar.close(), !(o.dataset.inlineToolbar === \"true\")))\n      return;\n    this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o);\n    const n = i !== !0;\n    this.Editor.InlineToolbar.tryToShow(!0, n);\n  }\n}\nconst ui = {\n  // API Modules\n  BlocksAPI: Zt,\n  CaretAPI: Gt,\n  EventsAPI: qt,\n  I18nAPI: De,\n  API: Jt,\n  InlineToolbarAPI: Qt,\n  ListenersAPI: eo,\n  NotifierAPI: no,\n  ReadOnlyAPI: so,\n  SanitizerAPI: po,\n  SaverAPI: fo,\n  SelectionAPI: go,\n  StylesAPI: bo,\n  ToolbarAPI: mo,\n  TooltipAPI: xo,\n  UiAPI: wo,\n  // Toolbar Modules\n  BlockSettings: Ro,\n  ConversionToolbar: Y,\n  Toolbar: jo,\n  InlineToolbar: Uo,\n  // Modules\n  BlockEvents: $o,\n  BlockManager: Ko,\n  BlockSelection: Xo,\n  Caret: ve,\n  CrossBlockSelection: Vo,\n  DragNDrop: Zo,\n  ModificationsObserver: Go,\n  Paste: wt,\n  ReadOnly: qo,\n  RectangleSelection: pe,\n  Renderer: Jo,\n  Saver: Qo,\n  Tools: St,\n  UI: hi\n};\nclass pi {\n  /**\n   * @param {EditorConfig} config - user configuration\n   */\n  constructor(e) {\n    this.moduleInstances = {}, this.eventsDispatcher = new we();\n    let t, o;\n    this.isReady = new Promise((i, n) => {\n      t = i, o = n;\n    }), Promise.resolve().then(async () => {\n      this.configuration = e, await this.validate(), await this.init(), await this.start(), K(\"I'm ready! (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧\", \"log\", \"\", \"color: #E24A75\"), setTimeout(async () => {\n        if (await this.render(), this.configuration.autofocus) {\n          const { BlockManager: i, Caret: n } = this.moduleInstances;\n          n.setToBlock(i.blocks[0], n.positions.START), i.highlightCurrentNode();\n        }\n        this.moduleInstances.UI.removeLoader(), t();\n      }, 500);\n    }).catch((i) => {\n      T(`Editor.js is not ready because of ${i}`, \"error\"), o(i);\n    });\n  }\n  /**\n   * Setting for configuration\n   *\n   * @param {EditorConfig|string} config - Editor's config to set\n   */\n  set configuration(e) {\n    var o, i;\n    j(e) ? this.config = {\n      ...e\n    } : this.config = {\n      holder: e\n    }, Ie(!!this.config.holderId, \"config.holderId\", \"config.holder\"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = \"editorjs\"), this.config.logLevel || (this.config.logLevel = et.VERBOSE), At(this.config.logLevel), Ie(!!this.config.initialBlock, \"config.initialBlock\", \"config.defaultBlock\"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || \"paragraph\", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;\n    const t = {\n      type: this.config.defaultBlock,\n      data: {}\n    };\n    this.config.placeholder = this.config.placeholder || !1, this.config.sanitizer = this.config.sanitizer || {\n      p: !0,\n      b: !0,\n      a: !0\n    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : !1, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {\n    }), this.config.onChange = this.config.onChange || (() => {\n    }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : !0, (V(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t] }), this.config.readOnly = this.config.readOnly || !1, (o = this.config.i18n) != null && o.messages && $.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i = this.config.i18n) == null ? void 0 : i.direction) || \"ltr\";\n  }\n  /**\n   * Returns private property\n   *\n   * @returns {EditorConfig}\n   */\n  get configuration() {\n    return this.config;\n  }\n  /**\n   * Checks for required fields in Editor's config\n   *\n   * @returns {Promise<void>}\n   */\n  async validate() {\n    const { holderId: e, holder: t } = this.config;\n    if (e && t)\n      throw Error(\"«holderId» and «holder» param can't assign at the same time.\");\n    if (J(t) && !d.get(t))\n      throw Error(`element with ID «${t}» is missing. Pass correct holder's ID.`);\n    if (t && j(t) && !d.isElement(t))\n      throw Error(\"«holder» value must be an Element node\");\n  }\n  /**\n   * Initializes modules:\n   *  - make and save instances\n   *  - configure\n   */\n  init() {\n    this.constructModules(), this.configureModules();\n  }\n  /**\n   * Start Editor!\n   *\n   * Get list of modules that needs to be prepared and return a sequence (Promise)\n   *\n   * @returns {Promise<void>}\n   */\n  async start() {\n    await [\n      \"Tools\",\n      \"UI\",\n      \"BlockManager\",\n      \"Paste\",\n      \"BlockSelection\",\n      \"RectangleSelection\",\n      \"CrossBlockSelection\",\n      \"ReadOnly\"\n    ].reduce(\n      (t, o) => t.then(async () => {\n        try {\n          await this.moduleInstances[o].prepare();\n        } catch (i) {\n          if (i instanceof at)\n            throw new Error(i.message);\n          T(`Module ${o} was skipped because of %o`, \"warn\", i);\n        }\n      }),\n      Promise.resolve()\n    );\n  }\n  /**\n   * Render initial data\n   */\n  render() {\n    return this.moduleInstances.Renderer.render(this.config.data.blocks);\n  }\n  /**\n   * Make modules instances and save it to the @property this.moduleInstances\n   */\n  constructModules() {\n    Object.entries(ui).forEach(([e, t]) => {\n      try {\n        this.moduleInstances[e] = new t({\n          config: this.configuration,\n          eventsDispatcher: this.eventsDispatcher\n        });\n      } catch (o) {\n        T(\"[constructModules]\", `Module ${e} skipped because`, \"error\", o);\n      }\n    });\n  }\n  /**\n   * Modules instances configuration:\n   *  - pass other modules to the 'state' property\n   *  - ...\n   */\n  configureModules() {\n    for (const e in this.moduleInstances)\n      Object.prototype.hasOwnProperty.call(this.moduleInstances, e) && (this.moduleInstances[e].state = this.getModulesDiff(e));\n  }\n  /**\n   * Return modules without passed name\n   *\n   * @param {string} name - module for witch modules difference should be calculated\n   */\n  getModulesDiff(e) {\n    const t = {};\n    for (const o in this.moduleInstances)\n      o !== e && (t[o] = this.moduleInstances[o]);\n    return t;\n  }\n}\n/**\n * Editor.js\n *\n * @license Apache-2.0\n * @see Editor.js <https://editorjs.io>\n * @author CodeX Team <https://codex.so>\n */\nclass fi {\n  /** Editor version */\n  static get version() {\n    return \"2.27.2\";\n  }\n  /**\n   * @param {EditorConfig|string|undefined} [configuration] - user configuration\n   */\n  constructor(e) {\n    let t = () => {\n    };\n    j(e) && D(e.onReady) && (t = e.onReady);\n    const o = new pi(e);\n    this.isReady = o.isReady.then(() => {\n      this.exportAPI(o), t();\n    });\n  }\n  /**\n   * Export external API methods\n   *\n   * @param {Core} editor — Editor's instance\n   */\n  exportAPI(e) {\n    const t = [\"configuration\"], o = () => {\n      Object.values(e.moduleInstances).forEach((n) => {\n        D(n.destroy) && n.destroy(), n.listeners.removeAll();\n      }), e = null;\n      for (const n in this)\n        Object.prototype.hasOwnProperty.call(this, n) && delete this[n];\n      Object.setPrototypeOf(this, null);\n    };\n    t.forEach((n) => {\n      this[n] = e[n];\n    }), this.destroy = o, Object.setPrototypeOf(this, e.moduleInstances.API.methods), delete this.exportAPI, Object.entries({\n      blocks: {\n        clear: \"clear\",\n        render: \"render\"\n      },\n      caret: {\n        focus: \"focus\"\n      },\n      events: {\n        on: \"on\",\n        off: \"off\",\n        emit: \"emit\"\n      },\n      saver: {\n        save: \"save\"\n      }\n    }).forEach(([n, r]) => {\n      Object.entries(r).forEach(([a, l]) => {\n        this[l] = e.moduleInstances.API.methods[n][a];\n      });\n    });\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9lZGl0b3Jqcy9kaXN0L2VkaXRvcmpzLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx1Q0FBdUMsRUFBRSxLQUFLLEVBQUUsY0FBYyxHQUFHLEdBQUcsRUFBRTtBQUN0RTtBQUNBLDBCQUEwQixHQUFHO0FBQzdCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtMQUFrTCxVQUFVO0FBQzVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxRQUFRO0FBQy9FO0FBQ0E7QUFDQSxDQUFDLCtEQUErRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0EscUZBQXFGLGNBQWM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyw2Q0FBNkMsVUFBVTtBQUM1RCxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILHlMQUF5TCxxR0FBcUcsdU9BQXVPLHlGQUF5RixrRUFBa0U7QUFDNXhCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SiwwQkFBMEI7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0IsaUJBQWlCLGtCQUFrQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLDhDQUE4QztBQUNuRSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFlBQVk7QUFDekIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLGtDQUFrQyxnQ0FBZ0M7QUFDbEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSxvQkFBb0IsdUJBQXVCLGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQixpQkFBaUIsMENBQTBDLE9BQU8sZUFBZTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsa0JBQWtCO0FBQy9CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQXlEO0FBQ3BFO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLHFDQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRCxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsbUJBQW1CLFNBQVMsT0FBTztBQUM3SDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixzQkFBc0IsK0NBQStDO0FBQzdKO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDJIQUEySCxRQUFRLHVCQUF1Qiw0Q0FBNEMsUUFBUTtBQUM5TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLGFBQWEsRUFBRSxrREFBa0QsNEJBQTRCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsVUFBVSw4QkFBOEI7QUFDeEMsaUdBQWlHLE9BQU8scUhBQXFILE9BQU8sb0dBQW9HLEVBQUUsYUFBYSxPQUFPO0FBQzlWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUcsT0FBTyxPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0EscUVBQXFFLDZCQUE2QjtBQUNsRztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxxQkFBcUIsVUFBVTtBQUN2RDtBQUNBO0FBQ0EsT0FBTyxTQUFTLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBLFlBQVksNEJBQTRCLGlCQUFpQixrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QixpQkFBaUIsYUFBYTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVMsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLG9EQUFvRCxVQUFVLGlDQUFpQztBQUMvRixTQUFTLFlBQVk7QUFDckI7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsaUJBQWlCLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSwwQ0FBMEM7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRDtBQUNBLFVBQVUsY0FBYztBQUN4QixVQUFVLGdDQUFnQztBQUMxQyxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFlBQVksUUFBUSxnSEFBZ0gsZ0RBQWdELG9DQUFvQztBQUN4TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUNBQWlDLDBDQUEwQyxpQ0FBaUMseURBQXlELGlDQUFpQyx3REFBd0QsaUNBQWlDO0FBQ3pVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsaUNBQWlDLHlEQUF5RCxpQ0FBaUMsNERBQTRELGlDQUFpQywwQ0FBMEMsaUNBQWlDLDBFQUEwRSxpQ0FBaUMsd0RBQXdELGlDQUFpQywyREFBMkQsaUNBQWlDLDJDQUEyQyxpQ0FBaUM7QUFDdHRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSCxLQUFLO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQSw4QkFBOEIscUNBQXFDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLG9DQUFvQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQ0FBbUMsRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx3REFBd0Q7QUFDNUgsdUJBQXVCLHVDQUF1QztBQUM5RDtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHdCQUF3QjtBQUMzRSxPQUFPO0FBQ1Asb0dBQW9HLGlCQUFpQiw0Q0FBNEMsV0FBVztBQUM1SyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDBCQUEwQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUIsY0FBYztBQUN0RDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHFFQUFxRSxnREFBZ0Q7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnRUFBZ0UsbUJBQW1CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1SSxjQUFjO0FBQ3JKO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixvREFBb0QsZUFBZTtBQUNuRSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUEyRCx1REFBdUQsdUpBQXVKO0FBQ3BSO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0EsV0FBVyxJQUFJO0FBQ2Ysb0JBQW9CO0FBQ3BCO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQSxXQUFXLElBQUk7QUFDZixtQkFBbUI7QUFDbkIsV0FBVyxJQUFJO0FBQ2Ysb0JBQW9CO0FBQ3BCO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUIsV0FBVyxNQUFNO0FBQ2pCLG1CQUFtQjtBQUNuQixXQUFXLElBQUk7QUFDZixtQkFBbUIsUUFBUTtBQUMzQixXQUFXLElBQUk7QUFDZjtBQUNBLFdBQVcsSUFBSTtBQUNmLG1CQUFtQjtBQUNuQixXQUFXLElBQUk7QUFDZixtQkFBbUI7QUFDbkIsV0FBVztBQUNYLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxzQkFBc0IsR0FBRztBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLDBDQUEwQyxHQUFHO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2VkaXRvcmpzL2Rpc3QvZWRpdG9yanMubWpzPzA3MGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEx0ID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24geGUocykge1xuICByZXR1cm4gcyAmJiBzLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIFwiZGVmYXVsdFwiKSA/IHMuZGVmYXVsdCA6IHM7XG59XG5mdW5jdGlvbiBCZSgpIHtcbn1cbk9iamVjdC5hc3NpZ24oQmUsIHtcbiAgZGVmYXVsdDogQmUsXG4gIHJlZ2lzdGVyOiBCZSxcbiAgcmV2ZXJ0OiBmdW5jdGlvbigpIHtcbiAgfSxcbiAgX19lc01vZHVsZTogITBcbn0pO1xuRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZnVuY3Rpb24ocykge1xuICBjb25zdCBlID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHMpO1xuICBsZXQgdCA9IGUubGVuZ3RoO1xuICBmb3IgKDsgLS10ID49IDAgJiYgZS5pdGVtKHQpICE9PSB0aGlzOyApXG4gICAgO1xuICByZXR1cm4gdCA+IC0xO1xufSk7XG5FbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0IHx8IChFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24ocykge1xuICBsZXQgZSA9IHRoaXM7XG4gIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGUpKVxuICAgIHJldHVybiBudWxsO1xuICBkbyB7XG4gICAgaWYgKGUubWF0Y2hlcyhzKSlcbiAgICAgIHJldHVybiBlO1xuICAgIGUgPSBlLnBhcmVudEVsZW1lbnQgfHwgZS5wYXJlbnROb2RlO1xuICB9IHdoaWxlIChlICE9PSBudWxsKTtcbiAgcmV0dXJuIG51bGw7XG59KTtcbkVsZW1lbnQucHJvdG90eXBlLnByZXBlbmQgfHwgKEVsZW1lbnQucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihlKSB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIEFycmF5LmlzQXJyYXkoZSkgfHwgKGUgPSBbZV0pLCBlLmZvckVhY2goKG8pID0+IHtcbiAgICBjb25zdCBpID0gbyBpbnN0YW5jZW9mIE5vZGU7XG4gICAgdC5hcHBlbmRDaGlsZChpID8gbyA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG8pKTtcbiAgfSksIHRoaXMuaW5zZXJ0QmVmb3JlKHQsIHRoaXMuZmlyc3RDaGlsZCk7XG59KTtcbkVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3SWZOZWVkZWQgfHwgKEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3SWZOZWVkZWQgPSBmdW5jdGlvbihzKSB7XG4gIHMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gITAgOiAhIXM7XG4gIGNvbnN0IGUgPSB0aGlzLnBhcmVudE5vZGUsIHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKSwgbyA9IHBhcnNlSW50KHQuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci10b3Atd2lkdGhcIikpLCBpID0gcGFyc2VJbnQodC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLWxlZnQtd2lkdGhcIikpLCBuID0gdGhpcy5vZmZzZXRUb3AgLSBlLm9mZnNldFRvcCA8IGUuc2Nyb2xsVG9wLCByID0gdGhpcy5vZmZzZXRUb3AgLSBlLm9mZnNldFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0IC0gbyA+IGUuc2Nyb2xsVG9wICsgZS5jbGllbnRIZWlnaHQsIGEgPSB0aGlzLm9mZnNldExlZnQgLSBlLm9mZnNldExlZnQgPCBlLnNjcm9sbExlZnQsIGwgPSB0aGlzLm9mZnNldExlZnQgLSBlLm9mZnNldExlZnQgKyB0aGlzLmNsaWVudFdpZHRoIC0gaSA+IGUuc2Nyb2xsTGVmdCArIGUuY2xpZW50V2lkdGgsIGMgPSBuICYmICFyO1xuICAobiB8fCByKSAmJiBzICYmIChlLnNjcm9sbFRvcCA9IHRoaXMub2Zmc2V0VG9wIC0gZS5vZmZzZXRUb3AgLSBlLmNsaWVudEhlaWdodCAvIDIgLSBvICsgdGhpcy5jbGllbnRIZWlnaHQgLyAyKSwgKGEgfHwgbCkgJiYgcyAmJiAoZS5zY3JvbGxMZWZ0ID0gdGhpcy5vZmZzZXRMZWZ0IC0gZS5vZmZzZXRMZWZ0IC0gZS5jbGllbnRXaWR0aCAvIDIgLSBpICsgdGhpcy5jbGllbnRXaWR0aCAvIDIpLCAobiB8fCByIHx8IGEgfHwgbCkgJiYgIXMgJiYgdGhpcy5zY3JvbGxJbnRvVmlldyhjKTtcbn0pO1xubGV0IE90ID0gKHMgPSAyMSkgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzKSkucmVkdWNlKChlLCB0KSA9PiAodCAmPSA2MywgdCA8IDM2ID8gZSArPSB0LnRvU3RyaW5nKDM2KSA6IHQgPCA2MiA/IGUgKz0gKHQgLSAyNikudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCkgOiB0ID4gNjIgPyBlICs9IFwiLVwiIDogZSArPSBcIl9cIiwgZSksIFwiXCIpO1xudmFyIGV0ID0gLyogQF9fUFVSRV9fICovICgocykgPT4gKHMuVkVSQk9TRSA9IFwiVkVSQk9TRVwiLCBzLklORk8gPSBcIklORk9cIiwgcy5XQVJOID0gXCJXQVJOXCIsIHMuRVJST1IgPSBcIkVSUk9SXCIsIHMpKShldCB8fCB7fSk7XG5jb25zdCBCID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBTSElGVDogMTYsXG4gIENUUkw6IDE3LFxuICBBTFQ6IDE4LFxuICBFU0M6IDI3LFxuICBTUEFDRTogMzIsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIERPV046IDQwLFxuICBSSUdIVDogMzksXG4gIERFTEVURTogNDYsXG4gIE1FVEE6IDkxXG59LCBfdCA9IHtcbiAgTEVGVDogMCxcbiAgV0hFRUw6IDEsXG4gIFJJR0hUOiAyLFxuICBCQUNLV0FSRDogMyxcbiAgRk9SV0FSRDogNFxufTtcbmZ1bmN0aW9uIGdlKHMsIGUsIHQgPSBcImxvZ1wiLCBvLCBpID0gXCJjb2xvcjogaW5oZXJpdFwiKSB7XG4gIGlmICghKFwiY29uc29sZVwiIGluIHdpbmRvdykgfHwgIXdpbmRvdy5jb25zb2xlW3RdKVxuICAgIHJldHVybjtcbiAgY29uc3QgbiA9IFtcImluZm9cIiwgXCJsb2dcIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl0uaW5jbHVkZXModCksIHIgPSBbXTtcbiAgc3dpdGNoIChnZS5sb2dMZXZlbCkge1xuICAgIGNhc2UgXCJFUlJPUlwiOlxuICAgICAgaWYgKHQgIT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIldBUk5cIjpcbiAgICAgIGlmICghW1wiZXJyb3JcIiwgXCJ3YXJuXCJdLmluY2x1ZGVzKHQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSU5GT1wiOlxuICAgICAgaWYgKCFuIHx8IHMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIG8gJiYgci5wdXNoKG8pO1xuICBjb25zdCBhID0gXCJFZGl0b3IuanMgMi4yNy4yXCIsIGwgPSBgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICAgICAgICAgIGNvbG9yOiAjMDA2RkVBO1xuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgICAgZm9udC1zaXplOiAxMXB4O1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgICAgICAgICBwYWRkaW5nOiA0cHggOXB4O1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMzBweDtcbiAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoNTYsIDEzOCwgMjI5LCAwLjE2KTtcbiAgICAgICAgICAgIG1hcmdpbjogNHB4IDVweCA0cHggMDtgO1xuICBzICYmIChuID8gKHIudW5zaGlmdChsLCBpKSwgZSA9IGAlYyR7YX0lYyAke2V9YCkgOiBlID0gYCggJHthfSApJHtlfWApO1xuICB0cnkge1xuICAgIG4gPyBvID8gY29uc29sZVt0XShgJHtlfSAlb2AsIC4uLnIpIDogY29uc29sZVt0XShlLCAuLi5yKSA6IGNvbnNvbGVbdF0oZSk7XG4gIH0gY2F0Y2gge1xuICB9XG59XG5nZS5sb2dMZXZlbCA9IFwiVkVSQk9TRVwiO1xuZnVuY3Rpb24gQXQocykge1xuICBnZS5sb2dMZXZlbCA9IHM7XG59XG5jb25zdCBUID0gZ2UuYmluZCh3aW5kb3csICExKSwgSyA9IGdlLmJpbmQod2luZG93LCAhMCk7XG5mdW5jdGlvbiB0ZShzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocykubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV0udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIEQocykge1xuICByZXR1cm4gdGUocykgPT09IFwiZnVuY3Rpb25cIiB8fCB0ZShzKSA9PT0gXCJhc3luY2Z1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBqKHMpIHtcbiAgcmV0dXJuIHRlKHMpID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gSihzKSB7XG4gIHJldHVybiB0ZShzKSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIE50KHMpIHtcbiAgcmV0dXJuIHRlKHMpID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIFZlKHMpIHtcbiAgcmV0dXJuIHRlKHMpID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gWmUocykge1xuICByZXR1cm4gdGUocykgPT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBWKHMpIHtcbiAgcmV0dXJuIHMgPyBPYmplY3Qua2V5cyhzKS5sZW5ndGggPT09IDAgJiYgcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IDogITA7XG59XG5mdW5jdGlvbiB0dChzKSB7XG4gIHJldHVybiBzID4gNDcgJiYgcyA8IDU4IHx8IC8vIG51bWJlciBrZXlzXG4gIHMgPT09IDMyIHx8IHMgPT09IDEzIHx8IC8vIFNwYWNlIGJhciAmIHJldHVybiBrZXkocylcbiAgcyA9PT0gMjI5IHx8IC8vIHByb2Nlc3Npbmcga2V5IGlucHV0IGZvciBjZXJ0YWluIGxhbmd1YWdlcyDigJQgQ2hpbmVzZSwgSmFwYW5lc2UsIGV0Yy5cbiAgcyA+IDY0ICYmIHMgPCA5MSB8fCAvLyBsZXR0ZXIga2V5c1xuICBzID4gOTUgJiYgcyA8IDExMiB8fCAvLyBOdW1wYWQga2V5c1xuICBzID4gMTg1ICYmIHMgPCAxOTMgfHwgLy8gOz0sLS4vYCAoaW4gb3JkZXIpXG4gIHMgPiAyMTggJiYgcyA8IDIyMztcbn1cbmFzeW5jIGZ1bmN0aW9uIG90KHMsIGUgPSAoKSA9PiB7XG59LCB0ID0gKCkgPT4ge1xufSkge1xuICBhc3luYyBmdW5jdGlvbiBvKGksIG4sIHIpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaS5mdW5jdGlvbihpLmRhdGEpLCBhd2FpdCBuKFplKGkuZGF0YSkgPyB7fSA6IGkuZGF0YSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByKFplKGkuZGF0YSkgPyB7fSA6IGkuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzLnJlZHVjZShhc3luYyAoaSwgbikgPT4gKGF3YWl0IGksIG8obiwgZSwgdCkpLCBQcm9taXNlLnJlc29sdmUoKSk7XG59XG5mdW5jdGlvbiBpdChzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzKTtcbn1cbmZ1bmN0aW9uIG9lKHMsIGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLCBvID0gYXJndW1lbnRzO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHMuYXBwbHkodCwgbyksIGUpO1xuICB9O1xufVxuZnVuY3Rpb24gUnQocykge1xuICByZXR1cm4gcy5uYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcbn1cbmZ1bmN0aW9uIER0KHMpIHtcbiAgcmV0dXJuIC9eWy1cXHddK1xcLyhbLStcXHddK3xcXCopJC8udGVzdChzKTtcbn1cbmZ1bmN0aW9uIFB0KHMsIGUsIHQpIHtcbiAgbGV0IG87XG4gIHJldHVybiAoLi4uaSkgPT4ge1xuICAgIGNvbnN0IG4gPSB0aGlzLCByID0gKCkgPT4ge1xuICAgICAgbyA9IG51bGwsIHQgfHwgcy5hcHBseShuLCBpKTtcbiAgICB9LCBhID0gdCAmJiAhbztcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG8pLCBvID0gd2luZG93LnNldFRpbWVvdXQociwgZSksIGEgJiYgcy5hcHBseShuLCBpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFRlKHMsIGUsIHQgPSB2b2lkIDApIHtcbiAgbGV0IG8sIGksIG4sIHIgPSBudWxsLCBhID0gMDtcbiAgdCB8fCAodCA9IHt9KTtcbiAgY29uc3QgbCA9IGZ1bmN0aW9uKCkge1xuICAgIGEgPSB0LmxlYWRpbmcgPT09ICExID8gMCA6IERhdGUubm93KCksIHIgPSBudWxsLCBuID0gcy5hcHBseShvLCBpKSwgciB8fCAobyA9IGkgPSBudWxsKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGMgPSBEYXRlLm5vdygpO1xuICAgICFhICYmIHQubGVhZGluZyA9PT0gITEgJiYgKGEgPSBjKTtcbiAgICBjb25zdCB1ID0gZSAtIChjIC0gYSk7XG4gICAgcmV0dXJuIG8gPSB0aGlzLCBpID0gYXJndW1lbnRzLCB1IDw9IDAgfHwgdSA+IGUgPyAociAmJiAoY2xlYXJUaW1lb3V0KHIpLCByID0gbnVsbCksIGEgPSBjLCBuID0gcy5hcHBseShvLCBpKSwgciB8fCAobyA9IGkgPSBudWxsKSkgOiAhciAmJiB0LnRyYWlsaW5nICE9PSAhMSAmJiAociA9IHNldFRpbWVvdXQobCwgdSkpLCBuO1xuICB9O1xufVxuZnVuY3Rpb24gRnQoKSB7XG4gIGNvbnN0IHMgPSB7XG4gICAgd2luOiAhMSxcbiAgICBtYWM6ICExLFxuICAgIHgxMTogITEsXG4gICAgbGludXg6ICExXG4gIH0sIGUgPSBPYmplY3Qua2V5cyhzKS5maW5kKCh0KSA9PiB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKHQpICE9PSAtMSk7XG4gIHJldHVybiBlICYmIChzW2VdID0gITApLCBzO1xufVxuZnVuY3Rpb24ga2Uocykge1xuICByZXR1cm4gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIFNlKHMsIC4uLmUpIHtcbiAgaWYgKCFlLmxlbmd0aClcbiAgICByZXR1cm4gcztcbiAgY29uc3QgdCA9IGUuc2hpZnQoKTtcbiAgaWYgKGoocykgJiYgaih0KSlcbiAgICBmb3IgKGNvbnN0IG8gaW4gdClcbiAgICAgIGoodFtvXSkgPyAoc1tvXSB8fCBPYmplY3QuYXNzaWduKHMsIHsgW29dOiB7fSB9KSwgU2Uoc1tvXSwgdFtvXSkpIDogT2JqZWN0LmFzc2lnbihzLCB7IFtvXTogdFtvXSB9KTtcbiAgcmV0dXJuIFNlKHMsIC4uLmUpO1xufVxuZnVuY3Rpb24gbnQocykge1xuICBjb25zdCBlID0gRnQoKTtcbiAgcmV0dXJuIHMgPSBzLnJlcGxhY2UoL3NoaWZ0L2dpLCBcIuKHp1wiKS5yZXBsYWNlKC9iYWNrc3BhY2UvZ2ksIFwi4oyrXCIpLnJlcGxhY2UoL2VudGVyL2dpLCBcIuKPjlwiKS5yZXBsYWNlKC91cC9naSwgXCLihpFcIikucmVwbGFjZSgvbGVmdC9naSwgXCLihpJcIikucmVwbGFjZSgvZG93bi9naSwgXCLihpNcIikucmVwbGFjZSgvcmlnaHQvZ2ksIFwi4oaQXCIpLnJlcGxhY2UoL2VzY2FwZS9naSwgXCLijotcIikucmVwbGFjZSgvaW5zZXJ0L2dpLCBcIkluc1wiKS5yZXBsYWNlKC9kZWxldGUvZ2ksIFwi4pChXCIpLnJlcGxhY2UoL1xcKy9naSwgXCIgKyBcIiksIGUubWFjID8gcyA9IHMucmVwbGFjZSgvY3RybHxjbWQvZ2ksIFwi4oyYXCIpLnJlcGxhY2UoL2FsdC9naSwgXCLijKVcIikgOiBzID0gcy5yZXBsYWNlKC9jbWQvZ2ksIFwiQ3RybFwiKS5yZXBsYWNlKC93aW5kb3dzL2dpLCBcIldJTlwiKSwgcztcbn1cbmZ1bmN0aW9uIEh0KHMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTChzKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gcy5zdWJzdHJpbmcoMCwgMikgPT09IFwiLy9cIiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIHMgOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgcztcbn1cbmZ1bmN0aW9uIHp0KCkge1xuICByZXR1cm4gT3QoMTApO1xufVxuZnVuY3Rpb24ganQocykge1xuICB3aW5kb3cub3BlbihzLCBcIl9ibGFua1wiKTtcbn1cbmZ1bmN0aW9uIFV0KHMgPSBcIlwiKSB7XG4gIHJldHVybiBgJHtzfSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU4KS50b1N0cmluZygxNil9YDtcbn1cbmZ1bmN0aW9uIEllKHMsIGUsIHQpIHtcbiAgY29uc3QgbyA9IGDCqyR7ZX3CuyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVzZSB0aGUgwqske3R9wrsgaW5zdGVhZC5gO1xuICBzICYmIEsobywgXCJ3YXJuXCIpO1xufVxuZnVuY3Rpb24gYWUocywgZSwgdCkge1xuICBjb25zdCBvID0gdC52YWx1ZSA/IFwidmFsdWVcIiA6IFwiZ2V0XCIsIGkgPSB0W29dLCBuID0gYCMke2V9Q2FjaGVgO1xuICBpZiAodFtvXSA9IGZ1bmN0aW9uKC4uLnIpIHtcbiAgICByZXR1cm4gdGhpc1tuXSA9PT0gdm9pZCAwICYmICh0aGlzW25dID0gaS5hcHBseSh0aGlzLCAuLi5yKSksIHRoaXNbbl07XG4gIH0sIG8gPT09IFwiZ2V0XCIgJiYgdC5zZXQpIHtcbiAgICBjb25zdCByID0gdC5zZXQ7XG4gICAgdC5zZXQgPSBmdW5jdGlvbihhKSB7XG4gICAgICBkZWxldGUgc1tuXSwgci5hcHBseSh0aGlzLCBhKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB0O1xufVxuY29uc3Qgc3QgPSA2NTA7XG5mdW5jdGlvbiBlZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKGAobWF4LXdpZHRoOiAke3N0fXB4KWApLm1hdGNoZXM7XG59XG5jb25zdCBHZSA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gJiYgKC9pUChhZHxob25lfG9kKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIk1hY0ludGVsXCIgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpO1xuZnVuY3Rpb24gJHQocywgZSkge1xuICBjb25zdCB0ID0gQXJyYXkuaXNBcnJheShzKSB8fCBqKHMpLCBvID0gQXJyYXkuaXNBcnJheShlKSB8fCBqKGUpO1xuICByZXR1cm4gdCB8fCBvID8gSlNPTi5zdHJpbmdpZnkocykgPT09IEpTT04uc3RyaW5naWZ5KGUpIDogcyA9PT0gZTtcbn1cbmNsYXNzIGQge1xuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIHRhZyBoYXMgbm8gY2xvc2VkIHRhZ1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWcgLSBlbGVtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzU2luZ2xlVGFnKGUpIHtcbiAgICByZXR1cm4gZS50YWdOYW1lICYmIFtcbiAgICAgIFwiQVJFQVwiLFxuICAgICAgXCJCQVNFXCIsXG4gICAgICBcIkJSXCIsXG4gICAgICBcIkNPTFwiLFxuICAgICAgXCJDT01NQU5EXCIsXG4gICAgICBcIkVNQkVEXCIsXG4gICAgICBcIkhSXCIsXG4gICAgICBcIklNR1wiLFxuICAgICAgXCJJTlBVVFwiLFxuICAgICAgXCJLRVlHRU5cIixcbiAgICAgIFwiTElOS1wiLFxuICAgICAgXCJNRVRBXCIsXG4gICAgICBcIlBBUkFNXCIsXG4gICAgICBcIlNPVVJDRVwiLFxuICAgICAgXCJUUkFDS1wiLFxuICAgICAgXCJXQlJcIlxuICAgIF0uaW5jbHVkZXMoZS50YWdOYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgZWxlbWVudCBpcyBCUiBvciBXQlJcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNMaW5lQnJlYWtUYWcoZSkge1xuICAgIHJldHVybiBlICYmIGUudGFnTmFtZSAmJiBbXG4gICAgICBcIkJSXCIsXG4gICAgICBcIldCUlwiXG4gICAgXS5pbmNsdWRlcyhlLnRhZ05hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIG1ha2luZyBFbGVtZW50cyB3aXRoIGNsYXNzIG5hbWUgYW5kIGF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lIC0gbmV3IEVsZW1lbnQgdGFnIG5hbWVcbiAgICogQHBhcmFtICB7c3RyaW5nW118c3RyaW5nfSBbY2xhc3NOYW1lc10gLSBsaXN0IG9yIG5hbWUgb2YgQ1NTIGNsYXNzIG5hbWUocylcbiAgICogQHBhcmFtICB7b2JqZWN0fSBbYXR0cmlidXRlc10gLSBhbnkgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgbWFrZShlLCB0ID0gbnVsbCwgbyA9IHt9KSB7XG4gICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSk7XG4gICAgQXJyYXkuaXNBcnJheSh0KSA/IGkuY2xhc3NMaXN0LmFkZCguLi50KSA6IHQgJiYgaS5jbGFzc0xpc3QuYWRkKHQpO1xuICAgIGZvciAoY29uc3QgbiBpbiBvKVxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIG4pICYmIChpW25dID0gb1tuXSk7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgVGV4dCBOb2RlIHdpdGggdGhlIHBhc3NlZCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gdGV4dCBjb250ZW50XG4gICAqIEByZXR1cm5zIHtUZXh0fVxuICAgKi9cbiAgc3RhdGljIHRleHQoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIG9uZSBvciBzZXZlcmFsIGVsZW1lbnRzIHRvIHRoZSBwYXJlbnRcbiAgICpcbiAgICogQHBhcmFtICB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBwYXJlbnQgLSB3aGVyZSB0byBhcHBlbmRcbiAgICogQHBhcmFtICB7RWxlbWVudHxFbGVtZW50W118RG9jdW1lbnRGcmFnbWVudHxUZXh0fFRleHRbXX0gZWxlbWVudHMgLSBlbGVtZW50IG9yIGVsZW1lbnRzIGxpc3RcbiAgICovXG4gIHN0YXRpYyBhcHBlbmQoZSwgdCkge1xuICAgIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goKG8pID0+IGUuYXBwZW5kQ2hpbGQobykpIDogZS5hcHBlbmRDaGlsZCh0KTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kIGVsZW1lbnQgb3IgYSBjb3VwbGUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgcGFyZW50IGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IC0gd2hlcmUgdG8gYXBwZW5kXG4gICAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IGVsZW1lbnRzIC0gZWxlbWVudCBvciBlbGVtZW50cyBsaXN0XG4gICAqL1xuICBzdGF0aWMgcHJlcGVuZChlLCB0KSB7XG4gICAgQXJyYXkuaXNBcnJheSh0KSA/ICh0ID0gdC5yZXZlcnNlKCksIHQuZm9yRWFjaCgobykgPT4gZS5wcmVwZW5kKG8pKSkgOiBlLnByZXBlbmQodCk7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXAgdHdvIGVsZW1lbnRzIGluIHBhcmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbDEgLSBmcm9tXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsMiAtIHRvXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzdGF0aWMgc3dhcChlLCB0KSB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGkgPSBlLnBhcmVudE5vZGU7XG4gICAgaS5pbnNlcnRCZWZvcmUobywgZSksIGkuaW5zZXJ0QmVmb3JlKGUsIHQpLCBpLmluc2VydEJlZm9yZSh0LCBvKSwgaS5yZW1vdmVDaGlsZChvKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0b3IgRGVjb3JhdG9yXG4gICAqXG4gICAqIFJldHVybnMgZmlyc3QgbWF0Y2hcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgd2Ugc2VhcmNoaW5nIGluc2lkZS4gRGVmYXVsdCAtIERPTSBEb2N1bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBzZWFyY2hpbmcgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgc3RhdGljIGZpbmQoZSA9IGRvY3VtZW50LCB0KSB7XG4gICAgcmV0dXJuIGUucXVlcnlTZWxlY3Rvcih0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IEVsZW1lbnQgYnkgSWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gaWQgdG8gZmluZFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3RvciBEZWNvcmF0b3IuXG4gICAqXG4gICAqIFJldHVybnMgYWxsIG1hdGNoZXNcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50fSBlbCAtIGVsZW1lbnQgd2Ugc2VhcmNoaW5nIGluc2lkZS4gRGVmYXVsdCAtIERPTSBEb2N1bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBzZWFyY2hpbmcgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtOb2RlTGlzdH1cbiAgICovXG4gIHN0YXRpYyBmaW5kQWxsKGUgPSBkb2N1bWVudCwgdCkge1xuICAgIHJldHVybiBlLnF1ZXJ5U2VsZWN0b3JBbGwodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQ1NTIHNlbGVjdG9yIGZvciBhbGwgdGV4dCBpbnB1dHNcbiAgICovXG4gIHN0YXRpYyBnZXQgYWxsSW5wdXRzU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIFwiW2NvbnRlbnRlZGl0YWJsZT10cnVlXSwgdGV4dGFyZWEsIGlucHV0Om5vdChbdHlwZV0pLCBcIiArIFtcInRleHRcIiwgXCJwYXNzd29yZFwiLCBcImVtYWlsXCIsIFwibnVtYmVyXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCJdLm1hcCgodCkgPT4gYGlucHV0W3R5cGU9XCIke3R9XCJdYCkuam9pbihcIiwgXCIpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFsbCBjb250ZW50ZWRpdGFibGUsIHRleHRhcmVhIGFuZCBlZGl0YWJsZSBpbnB1dCBlbGVtZW50cyBwYXNzZWQgaG9sZGVyIGNvbnRhaW5zXG4gICAqXG4gICAqIEBwYXJhbSBob2xkZXIgLSBlbGVtZW50IHdoZXJlIHRvIGZpbmQgaW5wdXRzXG4gICAqL1xuICBzdGF0aWMgZmluZEFsbElucHV0cyhlKSB7XG4gICAgcmV0dXJuIGl0KGUucXVlcnlTZWxlY3RvckFsbChkLmFsbElucHV0c1NlbGVjdG9yKSkucmVkdWNlKCh0LCBvKSA9PiBkLmlzTmF0aXZlSW5wdXQobykgfHwgZC5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cyhvKSA/IFsuLi50LCBvXSA6IFsuLi50LCAuLi5kLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzKG8pXSwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIGRlZXBlc3Qgbm9kZSB3aGljaCBpcyBMZWFmLlxuICAgKiBMZWFmIGlzIHRoZSB2ZXJ0ZXggdGhhdCBkb2Vzbid0IGhhdmUgYW55IGNoaWxkIG5vZGVzXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmVjdXJzaXZlbHkgZ29lcyB0aHJvdyB0aGUgYWxsIE5vZGUgdW50aWwgaXQgZmluZHMgdGhlIExlYWZcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gcm9vdCBOb2RlLiBGcm9tIHRoaXMgdmVydGV4IHdlIHN0YXJ0IERlZXAtZmlyc3Qgc2VhcmNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZXB0aC1maXJzdF9zZWFyY2h9XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2F0TGFzdF0gLSBmaW5kIGxhc3QgdGV4dCBub2RlXG4gICAqIEByZXR1cm5zIHtOb2RlfSAtIGl0IGNhbiBiZSB0ZXh0IE5vZGUgb3IgRWxlbWVudCBOb2RlLCBzbyB0aGF0IGNhcmV0IHdpbGwgYWJsZSB0byB3b3JrIHdpdGggaXRcbiAgICovXG4gIHN0YXRpYyBnZXREZWVwZXN0Tm9kZShlLCB0ID0gITEpIHtcbiAgICBjb25zdCBvID0gdCA/IFwibGFzdENoaWxkXCIgOiBcImZpcnN0Q2hpbGRcIiwgaSA9IHQgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICAgIGlmIChlICYmIGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVbb10pIHtcbiAgICAgIGxldCBuID0gZVtvXTtcbiAgICAgIGlmIChkLmlzU2luZ2xlVGFnKG4pICYmICFkLmlzTmF0aXZlSW5wdXQobikgJiYgIWQuaXNMaW5lQnJlYWtUYWcobikpXG4gICAgICAgIGlmIChuW2ldKVxuICAgICAgICAgIG4gPSBuW2ldO1xuICAgICAgICBlbHNlIGlmIChuLnBhcmVudE5vZGVbaV0pXG4gICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZVtpXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBuLnBhcmVudE5vZGU7XG4gICAgICByZXR1cm4gdGhpcy5nZXREZWVwZXN0Tm9kZShuLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9iamVjdCBpcyBET00gbm9kZVxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGUgLSBvYmplY3QgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzdGF0aWMgaXNFbGVtZW50KGUpIHtcbiAgICByZXR1cm4gVmUoZSkgPyAhMSA6IGUgJiYgZS5ub2RlVHlwZSAmJiBlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqZWN0IGlzIERvY3VtZW50RnJhZ21lbnQgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbm9kZSAtIG9iamVjdCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHN0YXRpYyBpc0ZyYWdtZW50KGUpIHtcbiAgICByZXR1cm4gVmUoZSkgPyAhMSA6IGUgJiYgZS5ub2RlVHlwZSAmJiBlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBlbGVtZW50IGlzIGNvbnRlbnRlZGl0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzQ29udGVudEVkaXRhYmxlKGUpIHtcbiAgICByZXR1cm4gZS5jb250ZW50RWRpdGFibGUgPT09IFwidHJ1ZVwiO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdGFyZ2V0IGlmIGl0IGlzIG5hdGl2ZSBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCAtIEhUTUwgZWxlbWVudCBvciBzdHJpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzdGF0aWMgaXNOYXRpdmVJbnB1dChlKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIFwiSU5QVVRcIixcbiAgICAgIFwiVEVYVEFSRUFcIlxuICAgIF07XG4gICAgcmV0dXJuIGUgJiYgZS50YWdOYW1lID8gdC5pbmNsdWRlcyhlLnRhZ05hbWUpIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB3ZSBjYW4gc2V0IGNhcmV0XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIHRhcmdldCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBjYW5TZXRDYXJldChlKSB7XG4gICAgbGV0IHQgPSAhMDtcbiAgICBpZiAoZC5pc05hdGl2ZUlucHV0KGUpKVxuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxuICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcInJlc2V0XCI6XG4gICAgICAgICAgdCA9ICExO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHQgPSBkLmlzQ29udGVudEVkaXRhYmxlKGUpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgbm9kZSBpZiBpdCBpcyBlbXB0eVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIGNoZWNrcyBzaW1wbGUgTm9kZSB3aXRob3V0IGFueSBjaGlsZHMgZm9yIGVtcHRpbmVzc1xuICAgKiBJZiB5b3UgaGF2ZSBOb2RlIHdpdGggMiBvciBtb3JlIGNoaWxkcmVuIGlkIGRlcHRoLCB5b3UgYmV0dGVyIHVzZSB7QGxpbmsgRG9tI2lzRW1wdHl9IG1ldGhvZFxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGl0IGlzIGVtcHR5XG4gICAqL1xuICBzdGF0aWMgaXNOb2RlRW1wdHkoZSkge1xuICAgIGxldCB0O1xuICAgIHJldHVybiB0aGlzLmlzU2luZ2xlVGFnKGUpICYmICF0aGlzLmlzTGluZUJyZWFrVGFnKGUpID8gITEgOiAodGhpcy5pc0VsZW1lbnQoZSkgJiYgdGhpcy5pc05hdGl2ZUlucHV0KGUpID8gdCA9IGUudmFsdWUgOiB0ID0gZS50ZXh0Q29udGVudC5yZXBsYWNlKFwi4oCLXCIsIFwiXCIpLCB0LnRyaW0oKS5sZW5ndGggPT09IDApO1xuICB9XG4gIC8qKlxuICAgKiBjaGVja3Mgbm9kZSBpZiBpdCBpcyBkb2Vzbid0IGhhdmUgYW55IGNoaWxkIG5vZGVzXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNMZWFmKGUpIHtcbiAgICByZXR1cm4gZSA/IGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgOiAhMTtcbiAgfVxuICAvKipcbiAgICogYnJlYWR0aC1maXJzdCBzZWFyY2ggKEJGUylcbiAgICoge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZWFkdGgtZmlyc3Rfc2VhcmNofVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gUHVzaGVzIHRvIHN0YWNrIGFsbCBET00gbGVhZnMgYW5kIGNoZWNrcyBmb3IgZW1wdGluZXNzXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNFbXB0eShlKSB7XG4gICAgZS5ub3JtYWxpemUoKTtcbiAgICBjb25zdCB0ID0gW2VdO1xuICAgIGZvciAoOyB0Lmxlbmd0aCA+IDA7IClcbiAgICAgIGlmIChlID0gdC5zaGlmdCgpLCAhIWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMZWFmKGUpICYmICF0aGlzLmlzTm9kZUVtcHR5KGUpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgZS5jaGlsZE5vZGVzICYmIHQucHVzaCguLi5BcnJheS5mcm9tKGUuY2hpbGROb2RlcykpO1xuICAgICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgc3RyaW5nIGNvbnRhaW5zIGh0bWwgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHN0cmluZyB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0hUTUxTdHJpbmcoZSkge1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgcmV0dXJuIHQuaW5uZXJIVE1MID0gZSwgdC5jaGlsZEVsZW1lbnRDb3VudCA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBsZW5ndGggb2Ygbm9kZWBzIHRleHQgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBub2RlIHdpdGggY29udGVudFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldENvbnRlbnRMZW5ndGgoZSkge1xuICAgIHJldHVybiBkLmlzTmF0aXZlSW5wdXQoZSkgPyBlLnZhbHVlLmxlbmd0aCA6IGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gZS5sZW5ndGggOiBlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFycmF5IG9mIG5hbWVzIG9mIGJsb2NrIGh0bWwgZWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgc3RhdGljIGdldCBibG9ja0VsZW1lbnRzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBcImFkZHJlc3NcIixcbiAgICAgIFwiYXJ0aWNsZVwiLFxuICAgICAgXCJhc2lkZVwiLFxuICAgICAgXCJibG9ja3F1b3RlXCIsXG4gICAgICBcImNhbnZhc1wiLFxuICAgICAgXCJkaXZcIixcbiAgICAgIFwiZGxcIixcbiAgICAgIFwiZHRcIixcbiAgICAgIFwiZmllbGRzZXRcIixcbiAgICAgIFwiZmlnY2FwdGlvblwiLFxuICAgICAgXCJmaWd1cmVcIixcbiAgICAgIFwiZm9vdGVyXCIsXG4gICAgICBcImZvcm1cIixcbiAgICAgIFwiaDFcIixcbiAgICAgIFwiaDJcIixcbiAgICAgIFwiaDNcIixcbiAgICAgIFwiaDRcIixcbiAgICAgIFwiaDVcIixcbiAgICAgIFwiaDZcIixcbiAgICAgIFwiaGVhZGVyXCIsXG4gICAgICBcImhncm91cFwiLFxuICAgICAgXCJoclwiLFxuICAgICAgXCJsaVwiLFxuICAgICAgXCJtYWluXCIsXG4gICAgICBcIm5hdlwiLFxuICAgICAgXCJub3NjcmlwdFwiLFxuICAgICAgXCJvbFwiLFxuICAgICAgXCJvdXRwdXRcIixcbiAgICAgIFwicFwiLFxuICAgICAgXCJwcmVcIixcbiAgICAgIFwicnVieVwiLFxuICAgICAgXCJzZWN0aW9uXCIsXG4gICAgICBcInRhYmxlXCIsXG4gICAgICBcInRib2R5XCIsXG4gICAgICBcInRoZWFkXCIsXG4gICAgICBcInRyXCIsXG4gICAgICBcInRmb290XCIsXG4gICAgICBcInVsXCIsXG4gICAgICBcInZpZGVvXCJcbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgY29udGVudCBpbmNsdWRlcyBvbmx5IGlubGluZSBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudH0gZGF0YSAtIGVsZW1lbnQgb3IgaHRtbCBzdHJpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMoZSkge1xuICAgIGxldCB0O1xuICAgIEooZSkgPyAodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHQuaW5uZXJIVE1MID0gZSkgOiB0ID0gZTtcbiAgICBjb25zdCBvID0gKGkpID0+ICFkLmJsb2NrRWxlbWVudHMuaW5jbHVkZXMoaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIEFycmF5LmZyb20oaS5jaGlsZHJlbikuZXZlcnkobyk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odC5jaGlsZHJlbikuZXZlcnkobyk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHJldHVybiBhbGwgYmxvY2sgZWxlbWVudHMgaW4gdGhlIHBhc3NlZCBwYXJlbnQgKGluY2x1ZGluZyBzdWJ0cmVlKVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgLSByb290IGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBzdGF0aWMgZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMoZSkge1xuICAgIHJldHVybiBkLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKGUpID8gW2VdIDogQXJyYXkuZnJvbShlLmNoaWxkcmVuKS5yZWR1Y2UoKHQsIG8pID0+IFsuLi50LCAuLi5kLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzKG8pXSwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGdldCBob2xkZXIgZnJvbSB7c3RyaW5nfSBvciByZXR1cm4gSFRNTEVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBIVE1MRWxlbWVudH0gZWxlbWVudCAtIGhvbGRlcidzIGlkIG9yIGhvbGRlcidzIEhUTUwgRWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgZ2V0SG9sZGVyKGUpIHtcbiAgICByZXR1cm4gSihlKSA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpIDogZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgaXMgYW5jaG9yIChpcyBBIHRhZylcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0FuY2hvcihlKSB7XG4gICAgcmV0dXJuIGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImFcIjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGVsZW1lbnQncyBvZmZzZXQgcmVsYXRlZCB0byB0aGUgZG9jdW1lbnRcbiAgICpcbiAgICogQHRvZG8gaGFuZGxlIGNhc2Ugd2hlbiBlZGl0b3IgaW5pdGlhbGl6ZWQgaW4gc2Nyb2xsYWJsZSBwb3B1cFxuICAgKiBAcGFyYW0gZWwgLSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0XG4gICAqL1xuICBzdGF0aWMgb2Zmc2V0KGUpIHtcbiAgICBjb25zdCB0ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgaSA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLCBuID0gdC50b3AgKyBpLCByID0gdC5sZWZ0ICsgbztcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBuLFxuICAgICAgbGVmdDogcixcbiAgICAgIGJvdHRvbTogbiArIHQuaGVpZ2h0LFxuICAgICAgcmlnaHQ6IHIgKyB0LndpZHRoXG4gICAgfTtcbiAgfVxufVxuY29uc3QgV3QgPSB7XG4gIGJsb2NrVHVuZXM6IHtcbiAgICB0b2dnbGVyOiB7XG4gICAgICBcIkNsaWNrIHRvIHR1bmVcIjogXCJcIixcbiAgICAgIFwib3IgZHJhZyB0byBtb3ZlXCI6IFwiXCJcbiAgICB9XG4gIH0sXG4gIGlubGluZVRvb2xiYXI6IHtcbiAgICBjb252ZXJ0ZXI6IHtcbiAgICAgIFwiQ29udmVydCB0b1wiOiBcIlwiXG4gICAgfVxuICB9LFxuICB0b29sYmFyOiB7XG4gICAgdG9vbGJveDoge1xuICAgICAgQWRkOiBcIlwiXG4gICAgfVxuICB9LFxuICBwb3BvdmVyOiB7XG4gICAgRmlsdGVyOiBcIlwiLFxuICAgIFwiTm90aGluZyBmb3VuZFwiOiBcIlwiXG4gIH1cbn0sIFl0ID0ge1xuICBUZXh0OiBcIlwiLFxuICBMaW5rOiBcIlwiLFxuICBCb2xkOiBcIlwiLFxuICBJdGFsaWM6IFwiXCJcbn0sIEt0ID0ge1xuICBsaW5rOiB7XG4gICAgXCJBZGQgYSBsaW5rXCI6IFwiXCJcbiAgfSxcbiAgc3R1Yjoge1xuICAgIFwiVGhlIGJsb2NrIGNhbiBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS5cIjogXCJcIlxuICB9XG59LCBYdCA9IHtcbiAgZGVsZXRlOiB7XG4gICAgRGVsZXRlOiBcIlwiLFxuICAgIFwiQ2xpY2sgdG8gZGVsZXRlXCI6IFwiXCJcbiAgfSxcbiAgbW92ZVVwOiB7XG4gICAgXCJNb3ZlIHVwXCI6IFwiXCJcbiAgfSxcbiAgbW92ZURvd246IHtcbiAgICBcIk1vdmUgZG93blwiOiBcIlwiXG4gIH1cbn0sIHJ0ID0ge1xuICB1aTogV3QsXG4gIHRvb2xOYW1lczogWXQsXG4gIHRvb2xzOiBLdCxcbiAgYmxvY2tUdW5lczogWHRcbn0sIGllID0gY2xhc3Mge1xuICAvKipcbiAgICogVHlwZS1zYWZlIHRyYW5zbGF0aW9uIGZvciBpbnRlcm5hbCBVSSB0ZXh0czpcbiAgICogUGVyZm9ybSB0cmFuc2xhdGlvbiBvZiB0aGUgc3RyaW5nIGJ5IG5hbWVzcGFjZSBhbmQgYSBrZXlcbiAgICpcbiAgICogQGV4YW1wbGUgSTE4bi51aShJMThuSW50ZXJuYWxOUy51aS5ibG9ja1R1bmVzLnRvZ2dsZXIsICdDbGljayB0byB0dW5lJylcbiAgICogQHBhcmFtIGludGVybmFsTmFtZXNwYWNlIC0gcGF0aCB0byB0cmFuc2xhdGVkIHN0cmluZyBpbiBkaWN0aW9uYXJ5XG4gICAqIEBwYXJhbSBkaWN0S2V5IC0gZGljdGlvbmFyeSBrZXkuIEJldHRlciB0byB1c2UgZGVmYXVsdCBsb2NhbGUgb3JpZ2luYWwgdGV4dFxuICAgKi9cbiAgc3RhdGljIHVpKHMsIGUpIHtcbiAgICByZXR1cm4gaWUuX3QocywgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBmb3IgZXh0ZXJuYWwgc3RyaW5ncyB0aGF0IGlzIG5vdCBwcmVzZW50ZWQgaW4gZGVmYXVsdCBkaWN0aW9uYXJ5LlxuICAgKiBGb3IgZXhhbXBsZSwgZm9yIHVzZXItc3BlY2lmaWVkIHRvb2wgbmFtZXNcbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIHBhdGggdG8gdHJhbnNsYXRlZCBzdHJpbmcgaW4gZGljdGlvbmFyeVxuICAgKiBAcGFyYW0gZGljdEtleSAtIGRpY3Rpb25hcnkga2V5LiBCZXR0ZXIgdG8gdXNlIGRlZmF1bHQgbG9jYWxlIG9yaWdpbmFsIHRleHRcbiAgICovXG4gIHN0YXRpYyB0KHMsIGUpIHtcbiAgICByZXR1cm4gaWUuX3QocywgZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkanVzdCBtb2R1bGUgZm9yIHVzaW5nIGV4dGVybmFsIGRpY3Rpb25hcnlcbiAgICpcbiAgICogQHBhcmFtIGRpY3Rpb25hcnkgLSBuZXcgbWVzc2FnZXMgbGlzdCB0byBvdmVycmlkZSBkZWZhdWx0XG4gICAqL1xuICBzdGF0aWMgc2V0RGljdGlvbmFyeShzKSB7XG4gICAgaWUuY3VycmVudERpY3Rpb25hcnkgPSBzO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIHRyYW5zbGF0aW9uIGJvdGggZm9yIGludGVybmFsIGFuZCBleHRlcm5hbCBuYW1lc3BhY2VzXG4gICAqIElmIHRoZXJlIGlzIG5vIHRyYW5zbGF0aW9uIGZvdW5kLCByZXR1cm5zIHBhc3NlZCBrZXkgYXMgYSB0cmFuc2xhdGVkIG1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIHBhdGggdG8gdHJhbnNsYXRlZCBzdHJpbmcgaW4gZGljdGlvbmFyeVxuICAgKiBAcGFyYW0gZGljdEtleSAtIGRpY3Rpb25hcnkga2V5LiBCZXR0ZXIgdG8gdXNlIGRlZmF1bHQgbG9jYWxlIG9yaWdpbmFsIHRleHRcbiAgICovXG4gIHN0YXRpYyBfdChzLCBlKSB7XG4gICAgY29uc3QgdCA9IGllLmdldE5hbWVzcGFjZShzKTtcbiAgICByZXR1cm4gIXQgfHwgIXRbZV0gPyBlIDogdFtlXTtcbiAgfVxuICAvKipcbiAgICogRmluZCBtZXNzYWdlcyBzZWN0aW9uIGJ5IG5hbWVzcGFjZSBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBwYXRoIHRvIHNlY3Rpb25cbiAgICovXG4gIHN0YXRpYyBnZXROYW1lc3BhY2Uocykge1xuICAgIHJldHVybiBzLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKHQsIG8pID0+ICF0IHx8ICFPYmplY3Qua2V5cyh0KS5sZW5ndGggPyB7fSA6IHRbb10sIGllLmN1cnJlbnREaWN0aW9uYXJ5KTtcbiAgfVxufTtcbmxldCAkID0gaWU7XG4kLmN1cnJlbnREaWN0aW9uYXJ5ID0gcnQ7XG5jbGFzcyBhdCBleHRlbmRzIEVycm9yIHtcbn1cbmNsYXNzIHdlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgYW55IGV2ZW50IG9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHN1YnNjcmliZXJcbiAgICovXG4gIG9uKGUsIHQpIHtcbiAgICBlIGluIHRoaXMuc3Vic2NyaWJlcnMgfHwgKHRoaXMuc3Vic2NyaWJlcnNbZV0gPSBbXSksIHRoaXMuc3Vic2NyaWJlcnNbZV0ucHVzaCh0KTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIGFueSBldmVudCBvbiBjYWxsYmFjay4gQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBhbmQgYmUgcmVtb3ZlZCBmcm9tIHN1YnNjcmliZXJzIGFycmF5IGFmdGVyIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIHN1YnNjcmliZXJcbiAgICovXG4gIG9uY2UoZSwgdCkge1xuICAgIGUgaW4gdGhpcy5zdWJzY3JpYmVycyB8fCAodGhpcy5zdWJzY3JpYmVyc1tlXSA9IFtdKTtcbiAgICBjb25zdCBvID0gKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0KGkpLCByID0gdGhpcy5zdWJzY3JpYmVyc1tlXS5pbmRleE9mKG8pO1xuICAgICAgcmV0dXJuIHIgIT09IC0xICYmIHRoaXMuc3Vic2NyaWJlcnNbZV0uc3BsaWNlKHIsIDEpLCBuO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyc1tlXS5wdXNoKG8pO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IGNhbGxiYWNrcyB3aXRoIHBhc3NlZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBkYXRhIC0gc3Vic2NyaWJlcnMgZ2V0IHRoaXMgZGF0YSB3aGVuIHRoZXkgd2VyZSBmaXJlZFxuICAgKi9cbiAgZW1pdChlLCB0KSB7XG4gICAgVih0aGlzLnN1YnNjcmliZXJzKSB8fCAhdGhpcy5zdWJzY3JpYmVyc1tlXSB8fCB0aGlzLnN1YnNjcmliZXJzW2VdLnJlZHVjZSgobywgaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IGkobyk7XG4gICAgICByZXR1cm4gbiAhPT0gdm9pZCAwID8gbiA6IG87XG4gICAgfSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGNhbGxiYWNrIGZyb20gZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50TmFtZSAtIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb2ZmKGUsIHQpIHtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHRoaXMuc3Vic2NyaWJlcnNbZV0ubGVuZ3RoOyBvKyspXG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVyc1tlXVtvXSA9PT0gdCkge1xuICAgICAgICBkZWxldGUgdGhpcy5zdWJzY3JpYmVyc1tlXVtvXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3llclxuICAgKiBjbGVhcnMgc3Vic2NyaWJlcnMgbGlzdFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaGUocykge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgIHJldHVybiBzLmlkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVG9vbCBuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHMubmFtZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRvb2wgY29uZmlnIHBhc3NlZCBvbiBFZGl0b3IncyBpbml0aWFsaXphdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1Rvb2xDb25maWd9XG4gICAgICovXG4gICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgIHJldHVybiBzLmNvbmZpZztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIC5jZS1ibG9jayBlbGVtZW50LCB0aGF0IHdyYXBzIHBsdWdpbiBjb250ZW50c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBob2xkZXIoKSB7XG4gICAgICByZXR1cm4gcy5ob2xkZXI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGNvbnRlbnQgaXMgZW1wdHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHMuaXNFbXB0eTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgQmxvY2sgaXMgc2VsZWN0ZWQgd2l0aCBDcm9zcy1CbG9jayBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiBzLnNlbGVjdGVkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0IEJsb2NrJ3Mgc3RyZXRjaCBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSDigJQgc3RhdGUgdG8gc2V0XG4gICAgICovXG4gICAgc2V0IHN0cmV0Y2hlZCh0KSB7XG4gICAgICBzLnN0cmV0Y2hlZCA9IHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIEJsb2NrIGlzIHN0cmV0Y2hlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHN0cmV0Y2hlZCgpIHtcbiAgICAgIHJldHVybiBzLnN0cmV0Y2hlZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGwgVG9vbCBtZXRob2Qgd2l0aCBlcnJvcnMgaGFuZGxlciB1bmRlci10aGUtaG9vZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgLSBtZXRob2QgdG8gY2FsbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbSAtIG9iamVjdCB3aXRoIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7dW5rbm93bn1cbiAgICAgKi9cbiAgICBjYWxsKHQsIG8pIHtcbiAgICAgIHJldHVybiBzLmNhbGwodCwgbyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYXZlIEJsb2NrIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWR8U2F2ZWREYXRhPn1cbiAgICAgKi9cbiAgICBzYXZlKCkge1xuICAgICAgcmV0dXJuIHMuc2F2ZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgQmxvY2sgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBkYXRhIC0gZGF0YSB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHZhbGlkYXRlKHQpIHtcbiAgICAgIHJldHVybiBzLnZhbGlkYXRlKHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIHNheSBFZGl0b3IgdGhhdCBCbG9jayB3YXMgY2hhbmdlZC4gVXNlZCB0byBtYW51YWxseSB0cmlnZ2VyIEVkaXRvcidzICdvbkNoYW5nZScgY2FsbGJhY2tcbiAgICAgKiBDYW4gYmUgdXNlZnVsIGZvciBibG9jayBjaGFuZ2VzIGludmlzaWJsZSBmb3IgZWRpdG9yIGNvcmUuXG4gICAgICovXG4gICAgZGlzcGF0Y2hDaGFuZ2UoKSB7XG4gICAgICBzLmRpc3BhdGNoQ2hhbmdlKCk7XG4gICAgfVxuICB9KTtcbn1cbmNsYXNzIFJlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hbGxMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBldmVudCBsaXN0ZW5lciBvbiBlbGVtZW50IGFuZCByZXR1cm5zIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBET00gZWxlbWVudCB0aGF0IG5lZWRzIHRvIGJlIGxpc3RlbmVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBtZXRob2QgdGhhdCB3aWxsIGJlIGZpcmVkIG9uIGV2ZW50XG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gb3B0aW9ucyAtIHVzZUNhcHR1cmUgb3Ige2NhcHR1cmUsIHBhc3NpdmUsIG9uY2V9XG4gICAqL1xuICBvbihlLCB0LCBvLCBpID0gITEpIHtcbiAgICBjb25zdCBuID0gVXQoXCJsXCIpLCByID0ge1xuICAgICAgaWQ6IG4sXG4gICAgICBlbGVtZW50OiBlLFxuICAgICAgZXZlbnRUeXBlOiB0LFxuICAgICAgaGFuZGxlcjogbyxcbiAgICAgIG9wdGlvbnM6IGlcbiAgICB9O1xuICAgIGlmICghdGhpcy5maW5kT25lKGUsIHQsIG8pKVxuICAgICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLnB1c2gociksIGUuYWRkRXZlbnRMaXN0ZW5lcih0LCBvLCBpKSwgbjtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lciBmcm9tIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIERPTSBlbGVtZW50IHRoYXQgd2UgcmVtb3ZpbmcgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIHJlbW92ZSBoYW5kbGVyLCBpZiBlbGVtZW50IGxpc3RlbnMgc2V2ZXJhbCBoYW5kbGVycyBvbiB0aGUgc2FtZSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gb3B0aW9ucyAtIHVzZUNhcHR1cmUgb3Ige2NhcHR1cmUsIHBhc3NpdmUsIG9uY2V9XG4gICAqL1xuICBvZmYoZSwgdCwgbywgaSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmZpbmRBbGwoZSwgdCwgbyk7XG4gICAgbi5mb3JFYWNoKChyLCBhKSA9PiB7XG4gICAgICBjb25zdCBsID0gdGhpcy5hbGxMaXN0ZW5lcnMuaW5kZXhPZihuW2FdKTtcbiAgICAgIGwgPiAtMSAmJiAodGhpcy5hbGxMaXN0ZW5lcnMuc3BsaWNlKGwsIDEpLCByLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihyLmV2ZW50VHlwZSwgci5oYW5kbGVyLCByLm9wdGlvbnMpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBsaXN0ZW5lciBieSBpZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBsaXN0ZW5lciBpZGVudGlmaWVyXG4gICAqL1xuICBvZmZCeUlkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5maW5kQnlJZChlKTtcbiAgICB0ICYmIHQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQuZXZlbnRUeXBlLCB0LmhhbmRsZXIsIHQub3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIGFuZCByZXR1cm5zIGZpcnN0IGxpc3RlbmVyIGJ5IHBhc3NlZCBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIGV2ZW50IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V2ZW50VHlwZV0gLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YXxudWxsfVxuICAgKi9cbiAgZmluZE9uZShlLCB0LCBvKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZmluZEFsbChlLCB0LCBvKTtcbiAgICByZXR1cm4gaS5sZW5ndGggPiAwID8gaVswXSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgc3RvcmVkIGxpc3RlbmVycyBieSBwYXNzZWQgcGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBldmVudCB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YVtdfVxuICAgKi9cbiAgZmluZEFsbChlLCB0LCBvKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbiA9IGUgPyB0aGlzLmZpbmRCeUV2ZW50VGFyZ2V0KGUpIDogW107XG4gICAgcmV0dXJuIGUgJiYgdCAmJiBvID8gaSA9IG4uZmlsdGVyKChyKSA9PiByLmV2ZW50VHlwZSA9PT0gdCAmJiByLmhhbmRsZXIgPT09IG8pIDogZSAmJiB0ID8gaSA9IG4uZmlsdGVyKChyKSA9PiByLmV2ZW50VHlwZSA9PT0gdCkgOiBpID0gbiwgaTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzXG4gICAqL1xuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy5hbGxMaXN0ZW5lcnMubWFwKChlKSA9PiB7XG4gICAgICBlLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLmV2ZW50VHlwZSwgZS5oYW5kbGVyLCBlLm9wdGlvbnMpO1xuICAgIH0pLCB0aGlzLmFsbExpc3RlbmVycyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGUgY2xlYW51cCBvbiBkZXN0cnVjdGlvblxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggbWV0aG9kOiBsb29rcyBmb3IgbGlzdGVuZXIgYnkgcGFzc2VkIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIHNlYXJjaGluZyBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtBcnJheX0gbGlzdGVuZXJzIHRoYXQgZm91bmQgb24gZWxlbWVudFxuICAgKi9cbiAgZmluZEJ5RXZlbnRUYXJnZXQoZSkge1xuICAgIHJldHVybiB0aGlzLmFsbExpc3RlbmVycy5maWx0ZXIoKHQpID0+IHtcbiAgICAgIGlmICh0LmVsZW1lbnQgPT09IGUpXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggbWV0aG9kOiBsb29rcyBmb3IgbGlzdGVuZXIgYnkgcGFzc2VkIGV2ZW50IHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YVtdfSBsaXN0ZW5lcnMgdGhhdCBmb3VuZCBvbiBlbGVtZW50XG4gICAqL1xuICBmaW5kQnlUeXBlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICBpZiAodC5ldmVudFR5cGUgPT09IGUpXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2ggbWV0aG9kOiBsb29rcyBmb3IgbGlzdGVuZXIgYnkgcGFzc2VkIGhhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YVtdfSBsaXN0ZW5lcnMgdGhhdCBmb3VuZCBvbiBlbGVtZW50XG4gICAqL1xuICBmaW5kQnlIYW5kbGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICBpZiAodC5oYW5kbGVyID09PSBlKVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0ZW5lciBkYXRhIGZvdW5kIGJ5IGlkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGxpc3RlbmVyIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMge0xpc3RlbmVyRGF0YX1cbiAgICovXG4gIGZpbmRCeUlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMuZmluZCgodCkgPT4gdC5pZCA9PT0gZSk7XG4gIH1cbn1cbmNsYXNzIFMge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTW9kdWxlIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gTW9kdWxlIGNvbmZpZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy5ldmVudHNEaXNwYXRjaGVyIC0gQ29tbW9uIGV2ZW50IGJ1c1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIGlmICh0aGlzLm5vZGVzID0ge30sIHRoaXMubGlzdGVuZXJzID0gbmV3IFJlKCksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBBc3NpZ25zIGV2ZW50IGxpc3RlbmVyIG9uIERPTSBlbGVtZW50IGFuZCBwdXNoZXMgaW50byBzcGVjaWFsIGFycmF5IHRoYXQgbWlnaHQgYmUgcmVtb3ZlZFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBET00gRWxlbWVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIEV2ZW50IG5hbWVcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgLSBFdmVudCBoYW5kbGVyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW58QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IG9wdGlvbnMgLSBMaXN0ZW5pbmcgb3B0aW9uc1xuICAgICAgICovXG4gICAgICBvbjogKG8sIGksIG4sIHIgPSAhMSkgPT4ge1xuICAgICAgICB0aGlzLm11dGFibGVMaXN0ZW5lcklkcy5wdXNoKFxuICAgICAgICAgIHRoaXMubGlzdGVuZXJzLm9uKG8sIGksIG4sIHIpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhcnMgYWxsIG11dGFibGUgbGlzdGVuZXJzXG4gICAgICAgKi9cbiAgICAgIGNsZWFyQWxsOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLm11dGFibGVMaXN0ZW5lcklkcylcbiAgICAgICAgICB0aGlzLmxpc3RlbmVycy5vZmZCeUlkKG8pO1xuICAgICAgICB0aGlzLm11dGFibGVMaXN0ZW5lcklkcyA9IFtdO1xuICAgICAgfVxuICAgIH0sIHRoaXMubXV0YWJsZUxpc3RlbmVySWRzID0gW10sIG5ldy50YXJnZXQgPT09IFMpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3JzIGZvciBhYnN0cmFjdCBjbGFzcyBNb2R1bGUgYXJlIG5vdCBhbGxvd2VkLlwiKTtcbiAgICB0aGlzLmNvbmZpZyA9IGUsIHRoaXMuZXZlbnRzRGlzcGF0Y2hlciA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRvciBtb2R1bGVzIHNldHRlclxuICAgKlxuICAgKiBAcGFyYW0ge0VkaXRvck1vZHVsZXN9IEVkaXRvciAtIEVkaXRvcidzIE1vZHVsZXNcbiAgICovXG4gIHNldCBzdGF0ZShlKSB7XG4gICAgdGhpcy5FZGl0b3IgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgbWVtb3JpemVkIG5vZGVzXG4gICAqL1xuICByZW1vdmVBbGxOb2RlcygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgY29uc3QgdCA9IHRoaXMubm9kZXNbZV07XG4gICAgICB0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjdXJyZW50IGRpcmVjdGlvbiBpcyBSVEwgKFJpZ2h0LVRvLUxlZnQpXG4gICAqL1xuICBnZXQgaXNSdGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmkxOG4uZGlyZWN0aW9uID09PSBcInJ0bFwiO1xuICB9XG59XG5jbGFzcyBtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbnN0YW5jZSA9IG51bGwsIHRoaXMuc2VsZWN0aW9uID0gbnVsbCwgdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlID0gbnVsbCwgdGhpcy5pc0Zha2VCYWNrZ3JvdW5kRW5hYmxlZCA9ICExLCB0aGlzLmNvbW1hbmRCYWNrZ3JvdW5kID0gXCJiYWNrQ29sb3JcIiwgdGhpcy5jb21tYW5kUmVtb3ZlRm9ybWF0ID0gXCJyZW1vdmVGb3JtYXRcIjtcbiAgfVxuICAvKipcbiAgICogRWRpdG9yIHN0eWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7e2VkaXRvcldyYXBwZXI6IHN0cmluZywgZWRpdG9yWm9uZTogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JXcmFwcGVyOiBcImNvZGV4LWVkaXRvclwiLFxuICAgICAgZWRpdG9yWm9uZTogXCJjb2RleC1lZGl0b3JfX3JlZGFjdG9yXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlbGVjdGVkIGFuY2hvclxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvQVBJL1NlbGVjdGlvbi9hbmNob3JOb2RlfVxuICAgKlxuICAgKiBAcmV0dXJucyB7Tm9kZXxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBhbmNob3JOb2RlKCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGUgPyBlLmFuY2hvck5vZGUgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlbGVjdGVkIGFuY2hvciBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGFuY2hvckVsZW1lbnQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB0ID0gZS5hbmNob3JOb2RlO1xuICAgIHJldHVybiB0ID8gZC5pc0VsZW1lbnQodCkgPyB0IDogdC5wYXJlbnRFbGVtZW50IDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3Rpb24gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgYW5jaG9yIG5vZGVcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9TZWxlY3Rpb24vYW5jaG9yT2Zmc2V0fVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGFuY2hvck9mZnNldCgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBlID8gZS5hbmNob3JPZmZzZXQgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBJcyBjdXJyZW50IHNlbGVjdGlvbiByYW5nZSBjb2xsYXBzZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNDb2xsYXBzZWQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZSA/IGUuaXNDb2xsYXBzZWQgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBjdXJyZW50IHNlbGVjdGlvbiBpZiBpdCBpcyBhdCBFZGl0b3IncyB6b25lXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc0F0RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLmlzU2VsZWN0aW9uQXRFZGl0b3IobS5nZXQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBzZWxlY3Rpb24gaXMgYXQgRWRpdG9yJ3Mgem9uZVxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gU2VsZWN0aW9uIG9iamVjdCB0byBjaGVja1xuICAgKi9cbiAgc3RhdGljIGlzU2VsZWN0aW9uQXRFZGl0b3IoZSkge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgdCA9IGUuYW5jaG9yTm9kZSB8fCBlLmZvY3VzTm9kZTtcbiAgICB0ICYmIHQubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmICh0ID0gdC5wYXJlbnROb2RlKTtcbiAgICBsZXQgbyA9IG51bGw7XG4gICAgcmV0dXJuIHQgJiYgdCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKG8gPSB0LmNsb3Nlc3QoYC4ke20uQ1NTLmVkaXRvclpvbmV9YCkpLCBvID8gby5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgOiAhMTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIHJhbmdlIGF0IEVkaXRvciB6b25lXG4gICAqXG4gICAqIEBwYXJhbSByYW5nZSAtIHJhbmdlIHRvIGNoZWNrXG4gICAqL1xuICBzdGF0aWMgaXNSYW5nZUF0RWRpdG9yKGUpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHQgPSBlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHQgJiYgdC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgKHQgPSB0LnBhcmVudE5vZGUpO1xuICAgIGxldCBvID0gbnVsbDtcbiAgICByZXR1cm4gdCAmJiB0IGluc3RhbmNlb2YgRWxlbWVudCAmJiAobyA9IHQuY2xvc2VzdChgLiR7bS5DU1MuZWRpdG9yWm9uZX1gKSksIG8gPyBvLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2RzIHJldHVybiBib29sZWFuIHRoYXQgdHJ1ZSBpZiBzZWxlY3Rpb24gZXhpc3RzIG9uIHRoZSBwYWdlXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzU2VsZWN0aW9uRXhpc3RzKCkge1xuICAgIHJldHVybiAhIW0uZ2V0KCkuYW5jaG9yTm9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IHJhbmdlXG4gICAqXG4gICAqIEByZXR1cm5zIHtSYW5nZXxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCByYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSYW5nZUZyb21TZWxlY3Rpb24odGhpcy5nZXQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcmFuZ2UgZnJvbSBwYXNzZWQgU2VsZWN0aW9uIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gU2VsZWN0aW9uIG9iamVjdCB0byBnZXQgUmFuZ2UgZnJvbVxuICAgKi9cbiAgc3RhdGljIGdldFJhbmdlRnJvbVNlbGVjdGlvbihlKSB7XG4gICAgcmV0dXJuIGUgJiYgZS5yYW5nZUNvdW50ID8gZS5nZXRSYW5nZUF0KDApIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBwb3NpdGlvbiBhbmQgc2l6ZSBvZiBzZWxlY3RlZCB0ZXh0XG4gICAqXG4gICAqIEByZXR1cm5zIHtET01SZWN0IHwgQ2xpZW50UmVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgcmVjdCgpIHtcbiAgICBsZXQgZSA9IGRvY3VtZW50LnNlbGVjdGlvbiwgdCwgbyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGlmIChlICYmIGUudHlwZSAhPT0gXCJDb250cm9sXCIpXG4gICAgICByZXR1cm4gZSA9IGUsIHQgPSBlLmNyZWF0ZVJhbmdlKCksIG8ueCA9IHQuYm91bmRpbmdMZWZ0LCBvLnkgPSB0LmJvdW5kaW5nVG9wLCBvLndpZHRoID0gdC5ib3VuZGluZ1dpZHRoLCBvLmhlaWdodCA9IHQuYm91bmRpbmdIZWlnaHQsIG87XG4gICAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKVxuICAgICAgcmV0dXJuIFQoXCJNZXRob2Qgd2luZG93LmdldFNlbGVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIsIFwid2FyblwiKSwgbztcbiAgICBpZiAoZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgZS5yYW5nZUNvdW50ID09PSBudWxsIHx8IGlzTmFOKGUucmFuZ2VDb3VudCkpXG4gICAgICByZXR1cm4gVChcIk1ldGhvZCBTZWxlY3Rpb25VdGlscy5yYW5nZUNvdW50IGlzIG5vdCBzdXBwb3J0ZWRcIiwgXCJ3YXJuXCIpLCBvO1xuICAgIGlmIChlLnJhbmdlQ291bnQgPT09IDApXG4gICAgICByZXR1cm4gbztcbiAgICBpZiAodCA9IGUuZ2V0UmFuZ2VBdCgwKS5jbG9uZVJhbmdlKCksIHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIChvID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksIG8ueCA9PT0gMCAmJiBvLnkgPT09IDApIHtcbiAgICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIGlmIChpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICBpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwi4oCLXCIpKSwgdC5pbnNlcnROb2RlKGkpLCBvID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgbiA9IGkucGFyZW50Tm9kZTtcbiAgICAgICAgbi5yZW1vdmVDaGlsZChpKSwgbi5ub3JtYWxpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VsZWN0ZWQgdGV4dCBhcyBTdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbiA/IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpIDogXCJcIjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aW5kb3cgU2VsZWN0aW9uVXRpbHNcbiAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9XaW5kb3cvZ2V0U2VsZWN0aW9ufVxuICAgKlxuICAgKiBAcmV0dXJucyB7U2VsZWN0aW9ufVxuICAgKi9cbiAgc3RhdGljIGdldCgpIHtcbiAgICByZXR1cm4gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgZm9jdXMgdG8gY29udGVudGVkaXRhYmxlIG9yIG5hdGl2ZSBpbnB1dCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gZWxlbWVudCB3aGVyZSB0byBzZXQgZm9jdXNcbiAgICogQHBhcmFtIG9mZnNldCAtIG9mZnNldCBvZiBjdXJzb3JcbiAgICovXG4gIHN0YXRpYyBzZXRDdXJzb3IoZSwgdCA9IDApIHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgaSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZC5pc05hdGl2ZUlucHV0KGUpID8gZC5jYW5TZXRDYXJldChlKSA/IChlLmZvY3VzKCksIGUuc2VsZWN0aW9uU3RhcnQgPSBlLnNlbGVjdGlvbkVuZCA9IHQsIGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIDogdm9pZCAwIDogKG8uc2V0U3RhcnQoZSwgdCksIG8uc2V0RW5kKGUsIHQpLCBpLnJlbW92ZUFsbFJhbmdlcygpLCBpLmFkZFJhbmdlKG8pLCBvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudCByYW5nZSBleGlzdHMgYW5kIGJlbG9uZ3MgdG8gY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSB3aGVyZSByYW5nZSBzaG91bGQgYmVcbiAgICovXG4gIHN0YXRpYyBpc1JhbmdlSW5zaWRlQ29udGFpbmVyKGUpIHtcbiAgICBjb25zdCB0ID0gbS5yYW5nZTtcbiAgICByZXR1cm4gdCA9PT0gbnVsbCA/ICExIDogZS5jb250YWlucyh0LnN0YXJ0Q29udGFpbmVyKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBmYWtlIGN1cnNvciB0byB0aGUgY3VycmVudCByYW5nZVxuICAgKi9cbiAgc3RhdGljIGFkZEZha2VDdXJzb3IoKSB7XG4gICAgY29uc3QgZSA9IG0ucmFuZ2U7XG4gICAgaWYgKGUgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGQubWFrZShcInNwYW5cIiwgXCJjb2RleC1lZGl0b3JfX2Zha2UtY3Vyc29yXCIpO1xuICAgIHQuZGF0YXNldC5tdXRhdGlvbkZyZWUgPSBcInRydWVcIiwgZS5jb2xsYXBzZSgpLCBlLmluc2VydE5vZGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBlbGVtZW50IGNvbnRhaW5zIGEgZmFrZSBjdXJzb3JcbiAgICpcbiAgICogQHBhcmFtIGVsIC0gd2hlcmUgdG8gY2hlY2tcbiAgICovXG4gIHN0YXRpYyBpc0Zha2VDdXJzb3JJbnNpZGVDb250YWluZXIoZSkge1xuICAgIHJldHVybiBkLmZpbmQoZSwgXCIuY29kZXgtZWRpdG9yX19mYWtlLWN1cnNvclwiKSAhPT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBmYWtlIGN1cnNvciBmcm9tIGEgY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSBjb250YWluZXIgLSBjb250YWluZXIgdG8gbG9vayBmb3JcbiAgICovXG4gIHN0YXRpYyByZW1vdmVGYWtlQ3Vyc29yKGUgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChlLCBcIi5jb2RleC1lZGl0b3JfX2Zha2UtY3Vyc29yXCIpO1xuICAgIHQgJiYgdC5yZW1vdmUoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBmYWtlIGJhY2tncm91bmRcbiAgICovXG4gIHJlbW92ZUZha2VCYWNrZ3JvdW5kKCkge1xuICAgIHRoaXMuaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQgJiYgKHRoaXMuaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQgPSAhMSwgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kUmVtb3ZlRm9ybWF0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgZmFrZSBiYWNrZ3JvdW5kXG4gICAqL1xuICBzZXRGYWtlQmFja2dyb3VuZCgpIHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmRCYWNrZ3JvdW5kLCAhMSwgXCIjYThkNmZmXCIpLCB0aGlzLmlzRmFrZUJhY2tncm91bmRFbmFibGVkID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFNhdmUgU2VsZWN0aW9uVXRpbHMncyByYW5nZVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICB0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UgPSBtLnJhbmdlO1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlIHNhdmVkIFNlbGVjdGlvblV0aWxzJ3MgcmFuZ2VcbiAgICovXG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKCF0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBlLnJlbW92ZUFsbFJhbmdlcygpLCBlLmFkZFJhbmdlKHRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBzYXZlZCBzZWxlY3Rpb25cbiAgICovXG4gIGNsZWFyU2F2ZWQoKSB7XG4gICAgdGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ29sbGFwc2UgY3VycmVudCBzZWxlY3Rpb25cbiAgICovXG4gIGNvbGxhcHNlVG9FbmQoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgdCA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgdC5zZWxlY3ROb2RlQ29udGVudHMoZS5mb2N1c05vZGUpLCB0LmNvbGxhcHNlKCExKSwgZS5yZW1vdmVBbGxSYW5nZXMoKSwgZS5hZGRSYW5nZSh0KTtcbiAgfVxuICAvKipcbiAgICogTG9va3MgYWhlYWQgdG8gZmluZCBwYXNzZWQgdGFnIGZyb20gY3VycmVudCBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdOYW1lICAgICAgIC0gdGFnIHRvIGZvdW5kXG4gICAqIEBwYXJhbSAge3N0cmluZ30gW2NsYXNzTmFtZV0gICAtIHRhZydzIGNsYXNzIG5hbWVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbc2VhcmNoRGVwdGhdIC0gY291bnQgb2YgdGFncyB0aGF0IGNhbiBiZSBpbmNsdWRlZC4gRm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmaW5kUGFyZW50VGFnKGUsIHQsIG8gPSAxMCkge1xuICAgIGNvbnN0IGkgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgbGV0IG4gPSBudWxsO1xuICAgIHJldHVybiAhaSB8fCAhaS5hbmNob3JOb2RlIHx8ICFpLmZvY3VzTm9kZSA/IG51bGwgOiAoW1xuICAgICAgLyoqIHRoZSBOb2RlIGluIHdoaWNoIHRoZSBzZWxlY3Rpb24gYmVnaW5zICovXG4gICAgICBpLmFuY2hvck5vZGUsXG4gICAgICAvKiogdGhlIE5vZGUgaW4gd2hpY2ggdGhlIHNlbGVjdGlvbiBlbmRzICovXG4gICAgICBpLmZvY3VzTm9kZVxuICAgIF0uZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbGV0IGwgPSBvO1xuICAgICAgZm9yICg7IGwgPiAwICYmIGEucGFyZW50Tm9kZSAmJiAhKGEudGFnTmFtZSA9PT0gZSAmJiAobiA9IGEsIHQgJiYgYS5jbGFzc0xpc3QgJiYgIWEuY2xhc3NMaXN0LmNvbnRhaW5zKHQpICYmIChuID0gbnVsbCksIG4pKTsgKVxuICAgICAgICBhID0gYS5wYXJlbnROb2RlLCBsLS07XG4gICAgfSksIG4pO1xuICB9XG4gIC8qKlxuICAgKiBFeHBhbmRzIHNlbGVjdGlvbiByYW5nZSB0byB0aGUgcGFzc2VkIHBhcmVudCBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHdoaWNoIGNvbnRlbnRzIHNob3VsZCBiZSBzZWxlY3RlZFxuICAgKi9cbiAgZXhwYW5kVG9UYWcoZSkge1xuICAgIGNvbnN0IHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBvLnNlbGVjdE5vZGVDb250ZW50cyhlKSwgdC5hZGRSYW5nZShvKTtcbiAgfVxufVxuZnVuY3Rpb24gVnQocywgZSkge1xuICBjb25zdCB7IHR5cGU6IHQsIHRhcmdldDogbywgYWRkZWROb2RlczogaSwgcmVtb3ZlZE5vZGVzOiBuIH0gPSBzO1xuICBpZiAobyA9PT0gZSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChbXCJjaGFyYWN0ZXJEYXRhXCIsIFwiYXR0cmlidXRlc1wiXS5pbmNsdWRlcyh0KSkge1xuICAgIGNvbnN0IGwgPSBvLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG8ucGFyZW50Tm9kZSA6IG87XG4gICAgcmV0dXJuIGUuY29udGFpbnMobCk7XG4gIH1cbiAgY29uc3QgciA9IEFycmF5LmZyb20oaSkuc29tZSgobCkgPT4gZS5jb250YWlucyhsKSksIGEgPSBBcnJheS5mcm9tKG4pLnNvbWUoKGwpID0+IGUuY29udGFpbnMobCkpO1xuICByZXR1cm4gciB8fCBhO1xufVxuY29uc3QgTWUgPSBcInJlZGFjdG9yIGRvbSBjaGFuZ2VkXCIsIGx0ID0gXCJibG9jayBjaGFuZ2VkXCIsIGN0ID0gXCJmYWtlIGN1cnNvciBpcyBhYm91dCB0byBiZSB0b2dnbGVkXCIsIGR0ID0gXCJmYWtlIGN1cnNvciBoYXZlIGJlZW4gc2V0XCI7XG52YXIgcSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLkFQUEVORF9DQUxMQkFDSyA9IFwiYXBwZW5kQ2FsbGJhY2tcIiwgcy5SRU5ERVJFRCA9IFwicmVuZGVyZWRcIiwgcy5NT1ZFRCA9IFwibW92ZWRcIiwgcy5VUERBVEVEID0gXCJ1cGRhdGVkXCIsIHMuUkVNT1ZFRCA9IFwicmVtb3ZlZFwiLCBzLk9OX1BBU1RFID0gXCJvblBhc3RlXCIsIHMpKShxIHx8IHt9KTtcbmNsYXNzIEYgZXh0ZW5kcyB3ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGJsb2NrIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIFtvcHRpb25zLmlkXSAtIGJsb2NrJ3MgaWQuIFdpbGwgYmUgZ2VuZXJhdGVkIGlmIG9taXR0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUb29sJ3MgaW5pdGlhbCBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvb2wg4oCUIGJsb2NrJ3MgdG9vbFxuICAgKiBAcGFyYW0gb3B0aW9ucy5hcGkgLSBFZGl0b3IgQVBJIG1vZHVsZSBmb3IgcGFzcyBpdCB0byB0aGUgQmxvY2sgVHVuZXNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVhZE9ubHkgLSBSZWFkLU9ubHkgZmxhZ1xuICAgKiBAcGFyYW0gW2V2ZW50QnVzXSAtIEVkaXRvciBjb21tb24gZXZlbnQgYnVzLiBBbGxvd3MgdG8gc3Vic2NyaWJlIG9uIHNvbWUgRWRpdG9yIGV2ZW50cy4gQ291bGQgYmUgb21pdHRlZCB3aGVuIFwidmlydHVhbFwiIEJsb2NrIGlzIGNyZWF0ZWQuIFNlZSBCbG9ja3NBUElAY29tcG9zZUJsb2NrRGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpZDogZSA9IHp0KCksXG4gICAgZGF0YTogdCxcbiAgICB0b29sOiBvLFxuICAgIGFwaTogaSxcbiAgICByZWFkT25seTogbixcbiAgICB0dW5lc0RhdGE6IHJcbiAgfSwgYSkge1xuICAgIHN1cGVyKCksIHRoaXMuY2FjaGVkSW5wdXRzID0gW10sIHRoaXMudG9vbFJlbmRlcmVkRWxlbWVudCA9IG51bGwsIHRoaXMudHVuZXNJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMudW5hdmFpbGFibGVUdW5lc0RhdGEgPSB7fSwgdGhpcy5pbnB1dEluZGV4ID0gMCwgdGhpcy5lZGl0b3JFdmVudEJ1cyA9IG51bGwsIHRoaXMuaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRyb3BJbnB1dHNDYWNoZSgpLCB0aGlzLnVwZGF0ZUN1cnJlbnRJbnB1dCgpO1xuICAgIH0sIHRoaXMuZGlkTXV0YXRlZCA9IChsID0gdm9pZCAwKSA9PiB7XG4gICAgICBjb25zdCBjID0gbCA9PT0gdm9pZCAwLCB1ID0gbCBpbnN0YW5jZW9mIElucHV0RXZlbnQ7XG4gICAgICAhYyAmJiAhdSAmJiB0aGlzLmRldGVjdFRvb2xSb290Q2hhbmdlKGwpO1xuICAgICAgbGV0IGg7XG4gICAgICBjIHx8IHUgPyBoID0gITAgOiBoID0gIShsLmxlbmd0aCA+IDAgJiYgbC5ldmVyeSgodikgPT4ge1xuICAgICAgICBjb25zdCB7IGFkZGVkTm9kZXM6IHAsIHJlbW92ZWROb2RlczogaywgdGFyZ2V0OiBfIH0gPSB2O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIC4uLkFycmF5LmZyb20ocCksXG4gICAgICAgICAgLi4uQXJyYXkuZnJvbShrKSxcbiAgICAgICAgICBfXG4gICAgICAgIF0uc29tZSgoQSkgPT4gZC5pc0VsZW1lbnQoQSkgPyBBLmRhdGFzZXQubXV0YXRpb25GcmVlID09PSBcInRydWVcIiA6ICExKTtcbiAgICAgIH0pKSwgaCAmJiAodGhpcy5kcm9wSW5wdXRzQ2FjaGUoKSwgdGhpcy51cGRhdGVDdXJyZW50SW5wdXQoKSwgdGhpcy5jYWxsKFxuICAgICAgICBcInVwZGF0ZWRcIlxuICAgICAgICAvKiBVUERBVEVEICovXG4gICAgICApLCB0aGlzLmVtaXQoXCJkaWRNdXRhdGVkXCIsIHRoaXMpKTtcbiAgICB9LCB0aGlzLm5hbWUgPSBvLm5hbWUsIHRoaXMuaWQgPSBlLCB0aGlzLnNldHRpbmdzID0gby5zZXR0aW5ncywgdGhpcy5jb25maWcgPSBvLnNldHRpbmdzLmNvbmZpZyB8fCB7fSwgdGhpcy5hcGkgPSBpLCB0aGlzLmVkaXRvckV2ZW50QnVzID0gYSB8fCBudWxsLCB0aGlzLmJsb2NrQVBJID0gbmV3IGhlKHRoaXMpLCB0aGlzLnRvb2wgPSBvLCB0aGlzLnRvb2xJbnN0YW5jZSA9IG8uY3JlYXRlKHQsIHRoaXMuYmxvY2tBUEksIG4pLCB0aGlzLnR1bmVzID0gby50dW5lcywgdGhpcy5jb21wb3NlVHVuZXMociksIHRoaXMuaG9sZGVyID0gdGhpcy5jb21wb3NlKCksIHRoaXMud2F0Y2hCbG9ja011dGF0aW9ucygpLCB0aGlzLmFkZElucHV0RXZlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENTUyBjbGFzc2VzIGZvciB0aGUgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge3t3cmFwcGVyOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JhcHBlcjogXCJjZS1ibG9ja1wiLFxuICAgICAgd3JhcHBlclN0cmV0Y2hlZDogXCJjZS1ibG9jay0tc3RyZXRjaGVkXCIsXG4gICAgICBjb250ZW50OiBcImNlLWJsb2NrX19jb250ZW50XCIsXG4gICAgICBmb2N1c2VkOiBcImNlLWJsb2NrLS1mb2N1c2VkXCIsXG4gICAgICBzZWxlY3RlZDogXCJjZS1ibG9jay0tc2VsZWN0ZWRcIixcbiAgICAgIGRyb3BUYXJnZXQ6IFwiY2UtYmxvY2stLWRyb3AtdGFyZ2V0XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuZCByZXR1cm4gYWxsIGVkaXRhYmxlIGVsZW1lbnRzIChjb250ZW50ZWRpdGFibGUgYW5kIG5hdGl2ZSBpbnB1dHMpIGluIHRoZSBUb29sIEhUTUxcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBnZXQgaW5wdXRzKCkge1xuICAgIGlmICh0aGlzLmNhY2hlZElucHV0cy5sZW5ndGggIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRJbnB1dHM7XG4gICAgY29uc3QgZSA9IGQuZmluZEFsbElucHV0cyh0aGlzLmhvbGRlcik7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmRleCA+IGUubGVuZ3RoIC0gMSAmJiAodGhpcy5pbnB1dEluZGV4ID0gZS5sZW5ndGggLSAxKSwgdGhpcy5jYWNoZWRJbnB1dHMgPSBlLCBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gY3VycmVudCBUb29sYHMgaW5wdXRcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbdGhpcy5pbnB1dEluZGV4XTtcbiAgfVxuICAvKipcbiAgICogU2V0IGlucHV0IGluZGV4IHRvIHRoZSBwYXNzZWQgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgTm9kZX0gZWxlbWVudCAtIEhUTUwgRWxlbWVudCB0byBzZXQgYXMgY3VycmVudCBpbnB1dFxuICAgKi9cbiAgc2V0IGN1cnJlbnRJbnB1dChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXRzLmZpbmRJbmRleCgobykgPT4gbyA9PT0gZSB8fCBvLmNvbnRhaW5zKGUpKTtcbiAgICB0ICE9PSAtMSAmJiAodGhpcy5pbnB1dEluZGV4ID0gdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBmaXJzdCBUb29sYHMgaW5wdXRcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IGZpcnN0SW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzWzBdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgVG9vbGBzIGlucHV0XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBsYXN0SW5wdXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaW5wdXRzO1xuICAgIHJldHVybiBlW2UubGVuZ3RoIC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBuZXh0IFRvb2xgcyBpbnB1dCBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXQgbmV4dElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0c1t0aGlzLmlucHV0SW5kZXggKyAxXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHByZXZpb3VzIFRvb2xgcyBpbnB1dCBvciB1bmRlZmluZWQgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXQgcHJldmlvdXNJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbdGhpcy5pbnB1dEluZGV4IC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBCbG9jaydzIEpTT04gZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F2ZSgpLnRoZW4oKGUpID0+IGUgJiYgIVYoZS5kYXRhKSA/IGUuZGF0YSA6IHt9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0b29sJ3Mgc2FuaXRpemVyIGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2wuc2FuaXRpemVDb25maWc7XG4gIH1cbiAgLyoqXG4gICAqIGlzIGJsb2NrIG1lcmdlYWJsZVxuICAgKiBXZSBwbHVnaW4gaGF2ZSBtZXJnZSBmdW5jdGlvbiB0aGVuIHdlIGNhbGwgaXQgbWVyZ2VhYmxlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IG1lcmdlYWJsZSgpIHtcbiAgICByZXR1cm4gRCh0aGlzLnRvb2xJbnN0YW5jZS5tZXJnZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGJsb2NrIGZvciBlbXB0aW5lc3NcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNFbXB0eSgpIHtcbiAgICBjb25zdCBlID0gZC5pc0VtcHR5KHRoaXMucGx1Z2luc0NvbnRlbnQpLCB0ID0gIXRoaXMuaGFzTWVkaWE7XG4gICAgcmV0dXJuIGUgJiYgdDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYmxvY2sgaGFzIGEgbWVkaWEgY29udGVudCBzdWNoIGFzIGltYWdlcywgaWZyYW1lIGFuZCBvdGhlclxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBoYXNNZWRpYSgpIHtcbiAgICBjb25zdCBlID0gW1xuICAgICAgXCJpbWdcIixcbiAgICAgIFwiaWZyYW1lXCIsXG4gICAgICBcInZpZGVvXCIsXG4gICAgICBcImF1ZGlvXCIsXG4gICAgICBcInNvdXJjZVwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgXCJ0d2l0dGVyd2lkZ2V0XCJcbiAgICBdO1xuICAgIHJldHVybiAhIXRoaXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoZS5qb2luKFwiLFwiKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBmb2N1c2VkIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSAndHJ1ZScgdG8gc2VsZWN0LCAnZmFsc2UnIHRvIHJlbW92ZSBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBmb2N1c2VkKGUpIHtcbiAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QudG9nZ2xlKEYuQ1NTLmZvY3VzZWQsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sncyBmb2N1c2VkIHN0YXRlXG4gICAqL1xuICBnZXQgZm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmNvbnRhaW5zKEYuQ1NTLmZvY3VzZWQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgc3RhdGVcbiAgICogV2UgZG9uJ3QgbmVlZCB0byBtYXJrIEJsb2NrIGFzIFNlbGVjdGVkIHdoZW4gaXQgaXMgZW1wdHlcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtICd0cnVlJyB0byBzZWxlY3QsICdmYWxzZScgdG8gcmVtb3ZlIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IHNlbGVjdGVkKGUpIHtcbiAgICB2YXIgaSwgbjtcbiAgICB0aGlzLmhvbGRlci5jbGFzc0xpc3QudG9nZ2xlKEYuQ1NTLnNlbGVjdGVkLCBlKTtcbiAgICBjb25zdCB0ID0gZSA9PT0gITAgJiYgbS5pc1JhbmdlSW5zaWRlQ29udGFpbmVyKHRoaXMuaG9sZGVyKSwgbyA9IGUgPT09ICExICYmIG0uaXNGYWtlQ3Vyc29ySW5zaWRlQ29udGFpbmVyKHRoaXMuaG9sZGVyKTtcbiAgICAodCB8fCBvKSAmJiAoKGkgPSB0aGlzLmVkaXRvckV2ZW50QnVzKSA9PSBudWxsIHx8IGkuZW1pdChjdCwgeyBzdGF0ZTogZSB9KSwgdCA/IG0uYWRkRmFrZUN1cnNvcigpIDogbS5yZW1vdmVGYWtlQ3Vyc29yKHRoaXMuaG9sZGVyKSwgKG4gPSB0aGlzLmVkaXRvckV2ZW50QnVzKSA9PSBudWxsIHx8IG4uZW1pdChkdCwgeyBzdGF0ZTogZSB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVHJ1ZSBpZiBpdCBpcyBTZWxlY3RlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmNvbnRhaW5zKEYuQ1NTLnNlbGVjdGVkKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHN0cmV0Y2hlZCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gJ3RydWUnIHRvIGVuYWJsZSwgJ2ZhbHNlJyB0byBkaXNhYmxlIHN0cmV0Y2hlZCBzdGF0ZVxuICAgKi9cbiAgc2V0IHN0cmV0Y2hlZChlKSB7XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnRvZ2dsZShGLkNTUy53cmFwcGVyU3RyZXRjaGVkLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIEJsb2NrJ3Mgc3RyZXRjaGVkIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHN0cmV0Y2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob2xkZXIuY2xhc3NMaXN0LmNvbnRhaW5zKEYuQ1NTLndyYXBwZXJTdHJldGNoZWQpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgZHJvcCB0YXJnZXQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtICd0cnVlJyBpZiBibG9jayBpcyBkcm9wIHRhcmdldCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBzZXQgZHJvcFRhcmdldChlKSB7XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnRvZ2dsZShGLkNTUy5kcm9wVGFyZ2V0LCBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBQbHVnaW5zIGNvbnRlbnRcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0IHBsdWdpbnNDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxzIFRvb2wncyBtZXRob2RcbiAgICpcbiAgICogTWV0aG9kIGNoZWNrcyB0b29sIHByb3BlcnR5IHtNZXRob2ROYW1lfS4gRmlyZXMgbWV0aG9kIHdpdGggcGFzc2VzIHBhcmFtcyBJZiBpdCBpcyBpbnN0YW5jZSBvZiBGdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIG1ldGhvZCB0byBjYWxsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBtZXRob2QgYXJndW1lbnRcbiAgICovXG4gIGNhbGwoZSwgdCkge1xuICAgIGlmIChEKHRoaXMudG9vbEluc3RhbmNlW2VdKSkge1xuICAgICAgZSA9PT0gXCJhcHBlbmRDYWxsYmFja1wiICYmIFQoXG4gICAgICAgIFwiYGFwcGVuZENhbGxiYWNrYCBob29rIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBVc2UgYHJlbmRlcmVkYCBob29rIGluc3RlYWRcIixcbiAgICAgICAgXCJ3YXJuXCJcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnRvb2xJbnN0YW5jZVtlXS5jYWxsKHRoaXMudG9vbEluc3RhbmNlLCB0KTtcbiAgICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgICAgVChgRXJyb3IgZHVyaW5nICcke2V9JyBjYWxsOiAke28ubWVzc2FnZX1gLCBcImVycm9yXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBwbHVnaW5zIG1lcmdlIG1ldGhvZFxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrVG9vbERhdGF9IGRhdGEgLSBkYXRhIHRvIG1lcmdlXG4gICAqL1xuICBhc3luYyBtZXJnZVdpdGgoZSkge1xuICAgIGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLm1lcmdlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0cyBkYXRhIGZyb20gQmxvY2tcbiAgICogR3JvdXBzIFRvb2wncyBzYXZlIHByb2Nlc3NpbmcgdGltZVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgYXN5bmMgc2F2ZSgpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy50b29sSW5zdGFuY2Uuc2F2ZSh0aGlzLnBsdWdpbnNDb250ZW50KSwgdCA9IHRoaXMudW5hdmFpbGFibGVUdW5lc0RhdGE7XG4gICAgW1xuICAgICAgLi4udGhpcy50dW5lc0luc3RhbmNlcy5lbnRyaWVzKCksXG4gICAgICAuLi50aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcy5lbnRyaWVzKClcbiAgICBdLmZvckVhY2goKFtuLCByXSkgPT4ge1xuICAgICAgaWYgKEQoci5zYXZlKSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0W25dID0gci5zYXZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgICAgICBUKGBUdW5lICR7ci5jb25zdHJ1Y3Rvci5uYW1lfSBzYXZlIG1ldGhvZCB0aHJvd3MgYW4gRXJyb3IgJW9gLCBcIndhcm5cIiwgYSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGxldCBpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZSkudGhlbigobikgPT4gKGkgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIHtcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgdG9vbDogdGhpcy5uYW1lLFxuICAgICAgZGF0YTogbixcbiAgICAgIHR1bmVzOiB0LFxuICAgICAgdGltZTogaSAtIG9cbiAgICB9KSkuY2F0Y2goKG4pID0+IHtcbiAgICAgIFQoYFNhdmluZyBwcm9jZXNzIGZvciAke3RoaXMubmFtZX0gdG9vbCBmYWlsZWQgZHVlIHRvIHRoZSAke259YCwgXCJsb2dcIiwgXCJyZWRcIik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZXMgVG9vbCdzIHZhbGlkYXRpb24gbWV0aG9kIHRvIGNoZWNrIHRoZSBjb3JyZWN0bmVzcyBvZiBvdXRwdXQgZGF0YVxuICAgKiBUb29sJ3MgdmFsaWRhdGlvbiBtZXRob2QgaXMgb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCByZXR1cm5zIHRydWV8ZmFsc2Ugd2hldGhlciBkYXRhIHBhc3NlZCB0aGUgdmFsaWRhdGlvbiBvciBub3RcbiAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBkYXRhIC0gZGF0YSB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gdmFsaWRcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlKGUpIHtcbiAgICBsZXQgdCA9ICEwO1xuICAgIHJldHVybiB0aGlzLnRvb2xJbnN0YW5jZS52YWxpZGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmICh0ID0gYXdhaXQgdGhpcy50b29sSW5zdGFuY2UudmFsaWRhdGUoZSkpLCB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGRhdGEgdG8gcmVuZGVyIGluIHR1bmVzIG1lbnUuXG4gICAqIFNwbGl0cyBibG9jayB0dW5lcyBzZXR0aW5ncyBpbnRvIDIgZ3JvdXBzOiBwb3BvdmVyIGl0ZW1zIGFuZCBjdXN0b20gaHRtbC5cbiAgICovXG4gIGdldFR1bmVzKCkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0ID0gW10sIG8gPSB0eXBlb2YgdGhpcy50b29sSW5zdGFuY2UucmVuZGVyU2V0dGluZ3MgPT0gXCJmdW5jdGlvblwiID8gdGhpcy50b29sSW5zdGFuY2UucmVuZGVyU2V0dGluZ3MoKSA6IFtdLCBpID0gW1xuICAgICAgLi4udGhpcy50dW5lc0luc3RhbmNlcy52YWx1ZXMoKSxcbiAgICAgIC4uLnRoaXMuZGVmYXVsdFR1bmVzSW5zdGFuY2VzLnZhbHVlcygpXG4gICAgXS5tYXAoKG4pID0+IG4ucmVuZGVyKCkpO1xuICAgIHJldHVybiBbbywgaV0uZmxhdCgpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGQuaXNFbGVtZW50KG4pID8gZS5hcHBlbmRDaGlsZChuKSA6IEFycmF5LmlzQXJyYXkobikgPyB0LnB1c2goLi4ubikgOiB0LnB1c2gobik7XG4gICAgfSksIFt0LCBlXTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGN1cnJlbnQgaW5wdXQgaW5kZXggd2l0aCBzZWxlY3Rpb24gYW5jaG9yIG5vZGVcbiAgICovXG4gIHVwZGF0ZUN1cnJlbnRJbnB1dCgpIHtcbiAgICB0aGlzLmN1cnJlbnRJbnB1dCA9IGQuaXNOYXRpdmVJbnB1dChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB8fCAhbS5hbmNob3JOb2RlID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IG0uYW5jaG9yTm9kZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRvIHNheSBFZGl0b3IgdGhhdCBCbG9jayB3YXMgY2hhbmdlZC4gVXNlZCB0byBtYW51YWxseSB0cmlnZ2VyIEVkaXRvcidzICdvbkNoYW5nZScgY2FsbGJhY2tcbiAgICogQ2FuIGJlIHVzZWZ1bCBmb3IgYmxvY2sgY2hhbmdlcyBpbnZpc2libGUgZm9yIGVkaXRvciBjb3JlLlxuICAgKi9cbiAgZGlzcGF0Y2hDaGFuZ2UoKSB7XG4gICAgdGhpcy5kaWRNdXRhdGVkKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgVG9vbCBpbnN0YW5jZSBkZXN0cm95IG1ldGhvZFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVud2F0Y2hCbG9ja011dGF0aW9ucygpLCB0aGlzLnJlbW92ZUlucHV0RXZlbnRzKCksIHN1cGVyLmRlc3Ryb3koKSwgRCh0aGlzLnRvb2xJbnN0YW5jZS5kZXN0cm95KSAmJiB0aGlzLnRvb2xJbnN0YW5jZS5kZXN0cm95KCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvb2wgY291bGQgc3BlY2lmeSBzZXZlcmFsIGVudHJpZXMgdG8gYmUgZGlzcGxheWVkIGF0IHRoZSBUb29sYm94IChmb3IgZXhhbXBsZSwgXCJIZWFkaW5nIDFcIiwgXCJIZWFkaW5nIDJcIiwgXCJIZWFkaW5nIDNcIilcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZW50cnkgdGhhdCBpcyByZWxhdGVkIHRvIHRoZSBCbG9jayAoZGVwZW5kZWQgb24gdGhlIEJsb2NrIGRhdGEpXG4gICAqL1xuICBhc3luYyBnZXRBY3RpdmVUb29sYm94RW50cnkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMudG9vbC50b29sYm94O1xuICAgIGlmIChlLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50b29sLnRvb2xib3hbMF0pO1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLmRhdGE7XG4gICAgcmV0dXJuIGUuZmluZCgoaSkgPT4gT2JqZWN0LmVudHJpZXMoaS5kYXRhKS5zb21lKChbbiwgcl0pID0+IHRbbl0gJiYgJHQodFtuXSwgcikpKTtcbiAgfVxuICAvKipcbiAgICogTWFrZSBkZWZhdWx0IEJsb2NrIHdyYXBwZXJzIGFuZCBwdXQgVG9vbGBzIGNvbnRlbnQgdGhlcmVcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgY29tcG9zZSgpIHtcbiAgICBjb25zdCBlID0gZC5tYWtlKFwiZGl2XCIsIEYuQ1NTLndyYXBwZXIpLCB0ID0gZC5tYWtlKFwiZGl2XCIsIEYuQ1NTLmNvbnRlbnQpLCBvID0gdGhpcy50b29sSW5zdGFuY2UucmVuZGVyKCk7XG4gICAgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50ID0gbywgdC5hcHBlbmRDaGlsZCh0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQpO1xuICAgIGxldCBpID0gdDtcbiAgICByZXR1cm4gWy4uLnRoaXMudHVuZXNJbnN0YW5jZXMudmFsdWVzKCksIC4uLnRoaXMuZGVmYXVsdFR1bmVzSW5zdGFuY2VzLnZhbHVlcygpXS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBpZiAoRChuLndyYXApKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGkgPSBuLndyYXAoaSk7XG4gICAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgICBUKGBUdW5lICR7bi5jb25zdHJ1Y3Rvci5uYW1lfSB3cmFwIG1ldGhvZCB0aHJvd3MgYW4gRXJyb3IgJW9gLCBcIndhcm5cIiwgcik7XG4gICAgICAgIH1cbiAgICB9KSwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbiAgfVxuICAvKipcbiAgICogSW5zdGFudGlhdGUgQmxvY2sgVHVuZXNcbiAgICpcbiAgICogQHBhcmFtIHR1bmVzRGF0YSAtIGN1cnJlbnQgQmxvY2sgdHVuZXMgZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcG9zZVR1bmVzKGUpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMudHVuZXMudmFsdWVzKCkpLmZvckVhY2goKHQpID0+IHtcbiAgICAgICh0LmlzSW50ZXJuYWwgPyB0aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcyA6IHRoaXMudHVuZXNJbnN0YW5jZXMpLnNldCh0Lm5hbWUsIHQuY3JlYXRlKGVbdC5uYW1lXSwgdGhpcy5ibG9ja0FQSSkpO1xuICAgIH0pLCBPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbdCwgb10pID0+IHtcbiAgICAgIHRoaXMudHVuZXNJbnN0YW5jZXMuaGFzKHQpIHx8ICh0aGlzLnVuYXZhaWxhYmxlVHVuZXNEYXRhW3RdID0gbyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIHRvIGFsbCBpbnB1dHMgYW5kIGNvbnRlbnRlZGl0YWJsZVxuICAgKi9cbiAgYWRkSW5wdXRFdmVudHMoKSB7XG4gICAgdGhpcy5pbnB1dHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5oYW5kbGVGb2N1cyksIGQuaXNOYXRpdmVJbnB1dChlKSAmJiBlLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmRpZE11dGF0ZWQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZW1vdmVzIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFsbCBpbnB1dHMgYW5kIGNvbnRlbnRlZGl0YWJsZVxuICAgKi9cbiAgcmVtb3ZlSW5wdXRFdmVudHMoKSB7XG4gICAgdGhpcy5pbnB1dHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5oYW5kbGVGb2N1cyksIGQuaXNOYXRpdmVJbnB1dChlKSAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmRpZE11dGF0ZWQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0ZW4gY29tbW9uIGVkaXRvciBEb20gQ2hhbmdlZCBldmVudCBhbmQgZGV0ZWN0IG11dGF0aW9ucyByZWxhdGVkIHRvIHRoZSAgQmxvY2tcbiAgICovXG4gIHdhdGNoQmxvY2tNdXRhdGlvbnMoKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5yZWRhY3RvckRvbUNoYW5nZWRDYWxsYmFjayA9ICh0KSA9PiB7XG4gICAgICBjb25zdCB7IG11dGF0aW9uczogbyB9ID0gdDtcbiAgICAgIG8uc29tZSgobikgPT4gVnQobiwgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50KSkgJiYgdGhpcy5kaWRNdXRhdGVkKG8pO1xuICAgIH0sIChlID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBlLm9uKE1lLCB0aGlzLnJlZGFjdG9yRG9tQ2hhbmdlZENhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHJlZGFjdG9yIGRvbSBjaGFuZ2UgZXZlbnQgbGlzdGVuZXJcbiAgICovXG4gIHVud2F0Y2hCbG9ja011dGF0aW9ucygpIHtcbiAgICB2YXIgZTtcbiAgICAoZSA9IHRoaXMuZWRpdG9yRXZlbnRCdXMpID09IG51bGwgfHwgZS5vZmYoTWUsIHRoaXMucmVkYWN0b3JEb21DaGFuZ2VkQ2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBTb21ldGltZXMgVG9vbCBjYW4gcmVwbGFjZSBvd24gbWFpbiBlbGVtZW50LCBmb3IgZXhhbXBsZSBIMiAtPiBINCBvciBVTCAtPiBPTFxuICAgKiBXZSBuZWVkIHRvIGRldGVjdCBzdWNoIGNoYW5nZXMgYW5kIHVwZGF0ZSBhIGxpbmsgdG8gdG9vbHMgbWFpbiBlbGVtZW50IHdpdGggdGhlIG5ldyBvbmVcbiAgICpcbiAgICogQHBhcmFtIG11dGF0aW9ucyAtIHJlY29yZHMgb2YgYmxvY2sgY29udGVudCBtdXRhdGlvbnNcbiAgICovXG4gIGRldGVjdFRvb2xSb290Q2hhbmdlKGUpIHtcbiAgICBlLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGlmIChBcnJheS5mcm9tKHQucmVtb3ZlZE5vZGVzKS5pbmNsdWRlcyh0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0LmFkZGVkTm9kZXNbdC5hZGRlZE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLnRvb2xSZW5kZXJlZEVsZW1lbnQgPSBpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgaW5wdXRzIGNhY2hlZCB2YWx1ZVxuICAgKi9cbiAgZHJvcElucHV0c0NhY2hlKCkge1xuICAgIHRoaXMuY2FjaGVkSW5wdXRzID0gW107XG4gIH1cbn1cbmNsYXNzIFp0IGV4dGVuZHMgUyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuaW5zZXJ0ID0gKGUgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2ssIHQgPSB7fSwgbyA9IHt9LCBpLCBuLCByLCBhKSA9PiB7XG4gICAgICBjb25zdCBsID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydCh7XG4gICAgICAgIGlkOiBhLFxuICAgICAgICB0b29sOiBlLFxuICAgICAgICBkYXRhOiB0LFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgbmVlZFRvRm9jdXM6IG4sXG4gICAgICAgIHJlcGxhY2U6IHJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBoZShsKTtcbiAgICB9LCB0aGlzLmNvbXBvc2VCbG9ja0RhdGEgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMuZ2V0KGUpO1xuICAgICAgcmV0dXJuIG5ldyBGKHtcbiAgICAgICAgdG9vbDogdCxcbiAgICAgICAgYXBpOiB0aGlzLkVkaXRvci5BUEksXG4gICAgICAgIHJlYWRPbmx5OiAhMCxcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIHR1bmVzRGF0YToge31cbiAgICAgIH0pLmRhdGE7XG4gICAgfSwgdGhpcy51cGRhdGUgPSAoZSwgdCkgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8gfSA9IHRoaXMuRWRpdG9yLCBpID0gby5nZXRCbG9ja0J5SWQoZSk7XG4gICAgICBpZiAoIWkpIHtcbiAgICAgICAgVChcImJsb2Nrcy51cGRhdGUoKTogQmxvY2sgd2l0aCBwYXNzZWQgaWQgd2FzIG5vdCBmb3VuZFwiLCBcIndhcm5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSBvLmdldEJsb2NrSW5kZXgoaSk7XG4gICAgICBvLmluc2VydCh7XG4gICAgICAgIGlkOiBpLmlkLFxuICAgICAgICB0b29sOiBpLm5hbWUsXG4gICAgICAgIGRhdGE6IHQsXG4gICAgICAgIGluZGV4OiBuLFxuICAgICAgICByZXBsYWNlOiAhMCxcbiAgICAgICAgdHVuZXM6IGkudHVuZXNcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja3N9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xlYXI6ICgpID0+IHRoaXMuY2xlYXIoKSxcbiAgICAgIHJlbmRlcjogKGUpID0+IHRoaXMucmVuZGVyKGUpLFxuICAgICAgcmVuZGVyRnJvbUhUTUw6IChlKSA9PiB0aGlzLnJlbmRlckZyb21IVE1MKGUpLFxuICAgICAgZGVsZXRlOiAoZSkgPT4gdGhpcy5kZWxldGUoZSksXG4gICAgICBzd2FwOiAoZSwgdCkgPT4gdGhpcy5zd2FwKGUsIHQpLFxuICAgICAgbW92ZTogKGUsIHQpID0+IHRoaXMubW92ZShlLCB0KSxcbiAgICAgIGdldEJsb2NrQnlJbmRleDogKGUpID0+IHRoaXMuZ2V0QmxvY2tCeUluZGV4KGUpLFxuICAgICAgZ2V0QnlJZDogKGUpID0+IHRoaXMuZ2V0QnlJZChlKSxcbiAgICAgIGdldEN1cnJlbnRCbG9ja0luZGV4OiAoKSA9PiB0aGlzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksXG4gICAgICBnZXRCbG9ja0luZGV4OiAoZSkgPT4gdGhpcy5nZXRCbG9ja0luZGV4KGUpLFxuICAgICAgZ2V0QmxvY2tzQ291bnQ6ICgpID0+IHRoaXMuZ2V0QmxvY2tzQ291bnQoKSxcbiAgICAgIHN0cmV0Y2hCbG9jazogKGUsIHQgPSAhMCkgPT4gdGhpcy5zdHJldGNoQmxvY2soZSwgdCksXG4gICAgICBpbnNlcnROZXdCbG9jazogKCkgPT4gdGhpcy5pbnNlcnROZXdCbG9jaygpLFxuICAgICAgaW5zZXJ0OiB0aGlzLmluc2VydCxcbiAgICAgIHVwZGF0ZTogdGhpcy51cGRhdGUsXG4gICAgICBjb21wb3NlQmxvY2tEYXRhOiB0aGlzLmNvbXBvc2VCbG9ja0RhdGFcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrcyBjb3VudFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmxvY2tzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgYmxvY2sgaW5kZXhcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldEN1cnJlbnRCbG9ja0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIEJsb2NrIGJ5IGlkO1xuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBibG9jayBpZFxuICAgKi9cbiAgZ2V0QmxvY2tJbmRleChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SWQoZSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICBLKFwiVGhlcmUgaXMgbm8gYmxvY2sgd2l0aCBpZCBgXCIgKyBlICsgXCJgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0luZGV4KHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrQVBJIG9iamVjdCBieSBCbG9jayBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCB0byBnZXRcbiAgICovXG4gIGdldEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgaWYgKHQgPT09IHZvaWQgMCkge1xuICAgICAgSyhcIlRoZXJlIGlzIG5vIGJsb2NrIGF0IGluZGV4IGBcIiArIGUgKyBcImBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGhlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrQVBJIG9iamVjdCBieSBCbG9jayBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiBibG9jayB0byBnZXRcbiAgICovXG4gIGdldEJ5SWQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUlkKGUpO1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgPyAoSyhcIlRoZXJlIGlzIG5vIGJsb2NrIHdpdGggaWQgYFwiICsgZSArIFwiYFwiLCBcIndhcm5cIiksIG51bGwpIDogbmV3IGhlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIEJsb2NrIE1hbmFnZXIgbWV0aG9kIHRoYXQgc3dhcCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIHBvc2l0aW9uIG9mIGZpcnN0IEJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gcG9zaXRpb24gb2Ygc2Vjb25kIEJsb2NrXG4gICAqIEBkZXByZWNhdGVkIOKAlCB1c2UgJ21vdmUnIGluc3RlYWRcbiAgICovXG4gIHN3YXAoZSwgdCkge1xuICAgIFQoXG4gICAgICBcImBibG9ja3Muc3dhcCgpYCBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFVzZSBgYmxvY2subW92ZSgpYCBtZXRob2QgaW5zdGVhZFwiLFxuICAgICAgXCJpbmZvXCJcbiAgICApLCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc3dhcChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBibG9jayBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gaW5kZXggdG8gbW92ZSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggdG8gbW92ZSBmcm9tXG4gICAqL1xuICBtb3ZlKGUsIHQpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubW92ZShlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tJbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLnJlbW92ZUJsb2NrKGUpO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIEsodCwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0KCksIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgJiYgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLCB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuRU5EKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBFZGl0b3IncyBhcmVhXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoITApLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbGxzIEVkaXRvciB3aXRoIEJsb2NrcyBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T3V0cHV0RGF0YX0gZGF0YSDigJQgU2F2ZWQgRWRpdG9yIGRhdGFcbiAgICovXG4gIHJlbmRlcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcigpLCB0aGlzLkVkaXRvci5SZW5kZXJlci5yZW5kZXIoZS5ibG9ja3MpO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGFzc2VkIEhUTUwgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gSFRNTCBzdHJpbmcgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgcmVuZGVyRnJvbUhUTUwoZSkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgdGhpcy5FZGl0b3IuUGFzdGUucHJvY2Vzc1RleHQoZSwgITApO1xuICB9XG4gIC8qKlxuICAgKiBTdHJldGNoIEJsb2NrJ3MgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBzdHJldGNoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzIC0gdHJ1ZSB0byBlbmFibGUsIGZhbHNlIHRvIGRpc2FibGVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIEJsb2NrQVBJIGludGVyZmFjZSB0byBzdHJldGNoIEJsb2Nrc1xuICAgKi9cbiAgc3RyZXRjaEJsb2NrKGUsIHQgPSAhMCkge1xuICAgIEllKFxuICAgICAgITAsXG4gICAgICBcImJsb2Nrcy5zdHJldGNoQmxvY2soKVwiLFxuICAgICAgXCJCbG9ja0FQSVwiXG4gICAgKTtcbiAgICBjb25zdCBvID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleChlKTtcbiAgICBvICYmIChvLnN0cmV0Y2hlZCA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IEJsb2NrXG4gICAqIEFmdGVyIHNldCBjYXJldCB0byB0aGlzIEJsb2NrXG4gICAqXG4gICAqIEB0b2RvIHJlbW92ZSBpbiAzLjAuMFxuICAgKiBAZGVwcmVjYXRlZCB3aXRoIGluc2VydCgpIG1ldGhvZFxuICAgKi9cbiAgaW5zZXJ0TmV3QmxvY2soKSB7XG4gICAgVChcIk1ldGhvZCBibG9ja3MuaW5zZXJ0TmV3QmxvY2soKSBpcyBkZXByZWNhdGVkIGFuZCBpdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGJsb2Nrcy5pbnNlcnQoKSBpbnN0ZWFkLlwiLCBcIndhcm5cIiksIHRoaXMuaW5zZXJ0KCk7XG4gIH1cbn1cbmNsYXNzIEd0IGV4dGVuZHMgUyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc2V0VG9GaXJzdEJsb2NrID0gKGUgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgdCA9IDApID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5maXJzdEJsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmZpcnN0QmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb0xhc3RCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubGFzdEJsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmxhc3RCbG9jaywgZSwgdCksICEwKSA6ICExLCB0aGlzLnNldFRvUHJldmlvdXNCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucHJldmlvdXNCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5wcmV2aW91c0Jsb2NrLCBlLCB0KSwgITApIDogITEsIHRoaXMuc2V0VG9OZXh0QmxvY2sgPSAoZSA9IHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5ERUZBVUxULCB0ID0gMCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLm5leHRCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5uZXh0QmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb0Jsb2NrID0gKGUsIHQgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgbyA9IDApID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3NbZV0gPyAodGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzW2VdLCB0LCBvKSwgITApIDogITEsIHRoaXMuZm9jdXMgPSAoZSA9ICExKSA9PiBlID8gdGhpcy5zZXRUb0xhc3RCbG9jayh0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuRU5EKSA6IHRoaXMuc2V0VG9GaXJzdEJsb2NrKHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5TVEFSVCk7XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtDYXJldH1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRUb0ZpcnN0QmxvY2s6IHRoaXMuc2V0VG9GaXJzdEJsb2NrLFxuICAgICAgc2V0VG9MYXN0QmxvY2s6IHRoaXMuc2V0VG9MYXN0QmxvY2ssXG4gICAgICBzZXRUb1ByZXZpb3VzQmxvY2s6IHRoaXMuc2V0VG9QcmV2aW91c0Jsb2NrLFxuICAgICAgc2V0VG9OZXh0QmxvY2s6IHRoaXMuc2V0VG9OZXh0QmxvY2ssXG4gICAgICBzZXRUb0Jsb2NrOiB0aGlzLnNldFRvQmxvY2ssXG4gICAgICBmb2N1czogdGhpcy5mb2N1c1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIHF0IGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7RXZlbnRzfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVtaXQ6IChlLCB0KSA9PiB0aGlzLmVtaXQoZSwgdCksXG4gICAgICBvZmY6IChlLCB0KSA9PiB0aGlzLm9mZihlLCB0KSxcbiAgICAgIG9uOiAoZSwgdCkgPT4gdGhpcy5vbihlLCB0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBvbiBFdmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIGV2ZW50IG5hbWUgdG8gc3Vic2NyaWJlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRW1pdCBldmVudCB3aXRoIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIGV2ZW50IHRvIGVtaXRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBldmVudCdzIGRhdGFcbiAgICovXG4gIGVtaXQoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIEV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBldmVudCB0byB1bnN1YnNjcmliZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9mZihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9mZihlLCB0KTtcbiAgfVxufVxuY2xhc3MgRGUgZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIFJldHVybiBuYW1lc3BhY2Ugc2VjdGlvbiBmb3IgdG9vbCBvciBibG9jayB0dW5lXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gdG9vbCBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBnZXROYW1lc3BhY2UoZSkge1xuICAgIHJldHVybiBlLmlzVHVuZSgpID8gYGJsb2NrVHVuZXMuJHtlLm5hbWV9YCA6IGB0b29scy4ke2UubmFtZX1gO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gSTE4biBBUEkgbWV0aG9kcyB3aXRoIGdsb2JhbCBkaWN0aW9uYXJ5IGFjY2Vzc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHQ6ICgpID0+IHtcbiAgICAgICAgSyhcIkkxOG4udCgpIG1ldGhvZCBjYW4gYmUgYWNjZXNzZWQgb25seSBmcm9tIFRvb2xzXCIsIFwid2FyblwiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gSTE4biBBUEkgbWV0aG9kcyB3aXRoIHRvb2wgbmFtZXNwYWNlZCBkaWN0aW9uYXJ5XG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gVG9vbCBvYmplY3RcbiAgICovXG4gIGdldE1ldGhvZHNGb3JUb29sKGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHRoaXMubWV0aG9kcyxcbiAgICAgIHtcbiAgICAgICAgdDogKHQpID0+ICQudChEZS5nZXROYW1lc3BhY2UoZSksIHQpXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuY2xhc3MgSnQgZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEVkaXRvci5qcyBDb3JlIEFQSSBtb2R1bGVzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2tzOiB0aGlzLkVkaXRvci5CbG9ja3NBUEkubWV0aG9kcyxcbiAgICAgIGNhcmV0OiB0aGlzLkVkaXRvci5DYXJldEFQSS5tZXRob2RzLFxuICAgICAgZXZlbnRzOiB0aGlzLkVkaXRvci5FdmVudHNBUEkubWV0aG9kcyxcbiAgICAgIGxpc3RlbmVyczogdGhpcy5FZGl0b3IuTGlzdGVuZXJzQVBJLm1ldGhvZHMsXG4gICAgICBub3RpZmllcjogdGhpcy5FZGl0b3IuTm90aWZpZXJBUEkubWV0aG9kcyxcbiAgICAgIHNhbml0aXplcjogdGhpcy5FZGl0b3IuU2FuaXRpemVyQVBJLm1ldGhvZHMsXG4gICAgICBzYXZlcjogdGhpcy5FZGl0b3IuU2F2ZXJBUEkubWV0aG9kcyxcbiAgICAgIHNlbGVjdGlvbjogdGhpcy5FZGl0b3IuU2VsZWN0aW9uQVBJLm1ldGhvZHMsXG4gICAgICBzdHlsZXM6IHRoaXMuRWRpdG9yLlN0eWxlc0FQSS5jbGFzc2VzLFxuICAgICAgdG9vbGJhcjogdGhpcy5FZGl0b3IuVG9vbGJhckFQSS5tZXRob2RzLFxuICAgICAgaW5saW5lVG9vbGJhcjogdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhckFQSS5tZXRob2RzLFxuICAgICAgdG9vbHRpcDogdGhpcy5FZGl0b3IuVG9vbHRpcEFQSS5tZXRob2RzLFxuICAgICAgaTE4bjogdGhpcy5FZGl0b3IuSTE4bkFQSS5tZXRob2RzLFxuICAgICAgcmVhZE9ubHk6IHRoaXMuRWRpdG9yLlJlYWRPbmx5QVBJLm1ldGhvZHMsXG4gICAgICB1aTogdGhpcy5FZGl0b3IuVWlBUEkubWV0aG9kc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgRWRpdG9yLmpzIENvcmUgQVBJIG1ldGhvZHMgZm9yIHBhc3NlZCB0b29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gdG9vbCBvYmplY3RcbiAgICovXG4gIGdldE1ldGhvZHNGb3JUb29sKGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgIHRoaXMubWV0aG9kcyxcbiAgICAgIHtcbiAgICAgICAgaTE4bjogdGhpcy5FZGl0b3IuSTE4bkFQSS5nZXRNZXRob2RzRm9yVG9vbChlKVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIFF0IGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7SW5saW5lVG9vbGJhcn1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbG9zZTogKCkgPT4gdGhpcy5jbG9zZSgpLFxuICAgICAgb3BlbjogKCkgPT4gdGhpcy5vcGVuKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIElubGluZSBUb29sYmFyXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIudHJ5VG9TaG93KCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIElubGluZSBUb29sYmFyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbn1cbmNsYXNzIGVvIGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7TGlzdGVuZXJzfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uOiAoZSwgdCwgbywgaSkgPT4gdGhpcy5vbihlLCB0LCBvLCBpKSxcbiAgICAgIG9mZjogKGUsIHQsIG8sIGkpID0+IHRoaXMub2ZmKGUsIHQsIG8sIGkpLFxuICAgICAgb2ZmQnlJZDogKGUpID0+IHRoaXMub2ZmQnlJZChlKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFkcyBhIERPTSBldmVudCBsaXN0ZW5lci4gUmV0dXJuIGl0J3MgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHNldCBoYW5kbGVyIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VDYXB0dXJlIC0gY2FwdHVyZSBldmVudCBvciBub3RcbiAgICovXG4gIG9uKGUsIHQsIG8sIGkpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMub24oZSwgdCwgbywgaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVyIGZyb20gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIHJlbW92ZSBoYW5kbGVyIGZyb21cbiAgICogQHBhcmFtIGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZSAtIGNhcHR1cmUgZXZlbnQgb3Igbm90XG4gICAqL1xuICBvZmYoZSwgdCwgbywgaSkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZihlLCB0LCBvLCBpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBET00gbGlzdGVuZXIgYnkgdGhlIGxpc3RlbmVyIGlkXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIGlkIG9mIHRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIG9mZkJ5SWQoZSkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZkJ5SWQoZSk7XG4gIH1cbn1cbnZhciBMZSA9IHt9LCB0byA9IHtcbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIExlO1xuICB9LFxuICBzZXQgZXhwb3J0cyhzKSB7XG4gICAgTGUgPSBzO1xuICB9XG59O1xuKGZ1bmN0aW9uKHMsIGUpIHtcbiAgKGZ1bmN0aW9uKHQsIG8pIHtcbiAgICBzLmV4cG9ydHMgPSBvKCk7XG4gIH0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICBmdW5jdGlvbiBpKG4pIHtcbiAgICAgICAgaWYgKG9bbl0pXG4gICAgICAgICAgcmV0dXJuIG9bbl0uZXhwb3J0cztcbiAgICAgICAgdmFyIHIgPSBvW25dID0geyBpOiBuLCBsOiAhMSwgZXhwb3J0czoge30gfTtcbiAgICAgICAgcmV0dXJuIHRbbl0uY2FsbChyLmV4cG9ydHMsIHIsIHIuZXhwb3J0cywgaSksIHIubCA9ICEwLCByLmV4cG9ydHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaS5tID0gdCwgaS5jID0gbywgaS5kID0gZnVuY3Rpb24obiwgciwgYSkge1xuICAgICAgICBpLm8obiwgcikgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHIsIHsgZW51bWVyYWJsZTogITAsIGdldDogYSB9KTtcbiAgICAgIH0sIGkuciA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgICAgfSwgaS50ID0gZnVuY3Rpb24obiwgcikge1xuICAgICAgICBpZiAoMSAmIHIgJiYgKG4gPSBpKG4pKSwgOCAmIHIgfHwgNCAmIHIgJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiBuICYmIG4uX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdmFyIGEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKGkucihhKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6ICEwLCB2YWx1ZTogbiB9KSwgMiAmIHIgJiYgdHlwZW9mIG4gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBmb3IgKHZhciBsIGluIG4pXG4gICAgICAgICAgICBpLmQoYSwgbCwgZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICByZXR1cm4gbltjXTtcbiAgICAgICAgICAgIH0uYmluZChudWxsLCBsKSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSwgaS5uID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgciA9IG4gJiYgbi5fX2VzTW9kdWxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG4uZGVmYXVsdDtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaS5kKHIsIFwiYVwiLCByKSwgcjtcbiAgICAgIH0sIGkubyA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKTtcbiAgICAgIH0sIGkucCA9IFwiL1wiLCBpKGkucyA9IDApO1xuICAgIH0oW2Z1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIGkoMSksIC8qIVxuICAgICAgICogQ29kZXggSmF2YVNjcmlwdCBOb3RpZmljYXRpb24gbW9kdWxlXG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vY29kZXgtdGVhbS9qcy1ub3RpZmllclxuICAgICAgICovXG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG4gPSBpKDYpLCByID0gXCJjZHgtbm90aWZ5LS1ib3VuY2UtaW5cIiwgYSA9IG51bGw7XG4gICAgICAgIHJldHVybiB7IHNob3c6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICBpZiAobC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgYSA9IG4uZ2V0V3JhcHBlcigpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHZhciBjID0gbnVsbCwgdSA9IGwudGltZSB8fCA4ZTM7XG4gICAgICAgICAgICBzd2l0Y2ggKGwudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiY29uZmlybVwiOlxuICAgICAgICAgICAgICAgIGMgPSBuLmNvbmZpcm0obCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJwcm9tcHRcIjpcbiAgICAgICAgICAgICAgICBjID0gbi5wcm9tcHQobCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYyA9IG4uYWxlcnQobCksIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgYy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9LCB1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEuYXBwZW5kQ2hpbGQoYyksIGMuY2xhc3NMaXN0LmFkZChyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfTtcbiAgICAgIH0oKTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgbiA9IGkoMik7XG4gICAgICB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIChuID0gW1t0LmksIG4sIFwiXCJdXSk7XG4gICAgICB2YXIgciA9IHsgaG1yOiAhMCwgdHJhbnNmb3JtOiB2b2lkIDAsIGluc2VydEludG86IHZvaWQgMCB9O1xuICAgICAgaSg0KShuLCByKSwgbi5sb2NhbHMgJiYgKHQuZXhwb3J0cyA9IG4ubG9jYWxzKTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICAodC5leHBvcnRzID0gaSgzKSghMSkpLnB1c2goW3QuaSwgYC5jZHgtbm90aWZ5LS1lcnJvcntiYWNrZ3JvdW5kOiNmZmZiZmIhaW1wb3J0YW50fS5jZHgtbm90aWZ5LS1lcnJvcjo6YmVmb3Jle2JhY2tncm91bmQ6I2ZiNWQ1ZCFpbXBvcnRhbnR9LmNkeC1ub3RpZnlfX2lucHV0e21heC13aWR0aDoxMzBweDtwYWRkaW5nOjVweCAxMHB4O2JhY2tncm91bmQ6I2Y3ZjdmNztib3JkZXI6MDtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6MTNweDtjb2xvcjojNjU2YjdjO291dGxpbmU6MH0uY2R4LW5vdGlmeV9faW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM2NTZiN2N9LmNkeC1ub3RpZnlfX2lucHV0OjpwbGFjZWhvbGRlcntjb2xvcjojNjU2YjdjfS5jZHgtbm90aWZ5X19pbnB1dDpmb2N1czotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6cmdiYSgxMDEsMTA3LDEyNCwuMyl9LmNkeC1ub3RpZnlfX2lucHV0OmZvY3VzOjpwbGFjZWhvbGRlcntjb2xvcjpyZ2JhKDEwMSwxMDcsMTI0LC4zKX0uY2R4LW5vdGlmeV9fYnV0dG9ue2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6M3B4O2ZvbnQtc2l6ZToxM3B4O3BhZGRpbmc6NXB4IDEwcHg7Y3Vyc29yOnBvaW50ZXJ9LmNkeC1ub3RpZnlfX2J1dHRvbjpsYXN0LWNoaWxke21hcmdpbi1sZWZ0OjEwcHh9LmNkeC1ub3RpZnlfX2J1dHRvbi0tY2FuY2Vse2JhY2tncm91bmQ6I2YyZjVmNztib3gtc2hhZG93OjAgMnB4IDFweCAwIHJnYmEoMTYsMTksMjksMCk7Y29sb3I6IzY1NmI3Y30uY2R4LW5vdGlmeV9fYnV0dG9uLS1jYW5jZWw6aG92ZXJ7YmFja2dyb3VuZDojZWVlfS5jZHgtbm90aWZ5X19idXR0b24tLWNvbmZpcm17YmFja2dyb3VuZDojMzRjOTkyO2JveC1zaGFkb3c6MCAxcHggMXB4IDAgcmdiYSgxOCw0OSwzNSwuMDUpO2NvbG9yOiNmZmZ9LmNkeC1ub3RpZnlfX2J1dHRvbi0tY29uZmlybTpob3ZlcntiYWNrZ3JvdW5kOiMzM2IwODJ9LmNkeC1ub3RpZnlfX2J0bnMtd3JhcHBlcntkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstbXMtZmxleC1mbG93OnJvdyBub3dyYXA7ZmxleC1mbG93OnJvdyBub3dyYXA7bWFyZ2luLXRvcDo1cHh9LmNkeC1ub3RpZnlfX2Nyb3Nze3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1cHg7cmlnaHQ6NXB4O3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHg7cGFkZGluZzo1cHg7b3BhY2l0eTouNTQ7Y3Vyc29yOnBvaW50ZXJ9LmNkeC1ub3RpZnlfX2Nyb3NzOjphZnRlciwuY2R4LW5vdGlmeV9fY3Jvc3M6OmJlZm9yZXtjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6OXB4O3RvcDo1cHg7aGVpZ2h0OjEycHg7d2lkdGg6MnB4O2JhY2tncm91bmQ6IzU3NWQ2N30uY2R4LW5vdGlmeV9fY3Jvc3M6OmJlZm9yZXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LmNkeC1ub3RpZnlfX2Nyb3NzOjphZnRlcnt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0uY2R4LW5vdGlmeV9fY3Jvc3M6aG92ZXJ7b3BhY2l0eToxfS5jZHgtbm90aWZpZXN7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoyO2JvdHRvbToyMHB4O2xlZnQ6MjBweDtmb250LWZhbWlseTotYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxcIlNlZ29lIFVJXCIsUm9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLFwiRmlyYSBTYW5zXCIsXCJEcm9pZCBTYW5zXCIsXCJIZWx2ZXRpY2EgTmV1ZVwiLHNhbnMtc2VyaWZ9LmNkeC1ub3RpZnl7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MjIwcHg7bWFyZ2luLXRvcDoxNXB4O3BhZGRpbmc6MTNweCAxNnB4O2JhY2tncm91bmQ6I2ZmZjtib3gtc2hhZG93OjAgMTFweCAxN3B4IDAgcmdiYSgyMywzMiw2MSwuMTMpO2JvcmRlci1yYWRpdXM6NXB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuNGVtO3dvcmQtd3JhcDpicmVhay13b3JkfS5jZHgtbm90aWZ5OjpiZWZvcmV7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3RvcDowO2xlZnQ6MDt3aWR0aDozcHg7aGVpZ2h0OmNhbGMoMTAwJSAtIDZweCk7bWFyZ2luOjNweDtib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOjAgMH1Aa2V5ZnJhbWVzIGJvdW5jZUluezAle29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUoLjMpfTUwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlKDEuMDUpfTcwJXt0cmFuc2Zvcm06c2NhbGUoLjkpfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDEpfX0uY2R4LW5vdGlmeS0tYm91bmNlLWlue2FuaW1hdGlvbi1uYW1lOmJvdW5jZUluO2FuaW1hdGlvbi1kdXJhdGlvbjouNnM7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDoxfS5jZHgtbm90aWZ5LS1zdWNjZXNze2JhY2tncm91bmQ6I2ZhZmZmZSFpbXBvcnRhbnR9LmNkeC1ub3RpZnktLXN1Y2Nlc3M6OmJlZm9yZXtiYWNrZ3JvdW5kOiM0MWZmYjEhaW1wb3J0YW50fWAsIFwiXCJdKTtcbiAgICB9LCBmdW5jdGlvbih0LCBvKSB7XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBuID0gW107XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHZhciBhID0gZnVuY3Rpb24obCwgYykge1xuICAgICAgICAgICAgICB2YXIgdSA9IGxbMV0gfHwgXCJcIiwgaCA9IGxbM107XG4gICAgICAgICAgICAgIGlmICghaClcbiAgICAgICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICAgICAgaWYgKGMgJiYgdHlwZW9mIGJ0b2EgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAocCA9IGgsIFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocCkpKSkgKyBcIiAqL1wiKSwgdiA9IGguc291cmNlcy5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIiArIGguc291cmNlUm9vdCArIGsgKyBcIiAqL1wiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdV0uY29uY2F0KHYpLmNvbmNhdChbZl0pLmpvaW4oYFxuYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICAgIHJldHVybiBbdV0uam9pbihgXG5gKTtcbiAgICAgICAgICAgIH0ociwgaSk7XG4gICAgICAgICAgICByZXR1cm4gclsyXSA/IFwiQG1lZGlhIFwiICsgclsyXSArIFwie1wiICsgYSArIFwifVwiIDogYTtcbiAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB9LCBuLmkgPSBmdW5jdGlvbihyLCBhKSB7XG4gICAgICAgICAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAociA9IFtbbnVsbCwgciwgXCJcIl1dKTtcbiAgICAgICAgICBmb3IgKHZhciBsID0ge30sIGMgPSAwOyBjIDwgdGhpcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgdmFyIHUgPSB0aGlzW2NdWzBdO1xuICAgICAgICAgICAgdHlwZW9mIHUgPT0gXCJudW1iZXJcIiAmJiAobFt1XSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gMDsgYyA8IHIubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBoID0gcltjXTtcbiAgICAgICAgICAgIHR5cGVvZiBoWzBdID09IFwibnVtYmVyXCIgJiYgbFtoWzBdXSB8fCAoYSAmJiAhaFsyXSA/IGhbMl0gPSBhIDogYSAmJiAoaFsyXSA9IFwiKFwiICsgaFsyXSArIFwiKSBhbmQgKFwiICsgYSArIFwiKVwiKSwgbi5wdXNoKGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG47XG4gICAgICB9O1xuICAgIH0sIGZ1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIHZhciBuLCByLCBhID0ge30sIGwgPSAobiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG4gICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHIgPT09IHZvaWQgMCAmJiAociA9IG4uYXBwbHkodGhpcywgYXJndW1lbnRzKSksIHI7XG4gICAgICB9KSwgYyA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgdmFyIGcgPSB7fTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKEUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIEUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgcmV0dXJuIEUoKTtcbiAgICAgICAgICBpZiAoZ1tFXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgQyA9IGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoTyk7XG4gICAgICAgICAgICB9LmNhbGwodGhpcywgRSk7XG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIEMgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgQyA9IEMuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIEMgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBnW0VdID0gQztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdbRV07XG4gICAgICAgIH07XG4gICAgICB9KCksIHUgPSBudWxsLCBoID0gMCwgZiA9IFtdLCB2ID0gaSg1KTtcbiAgICAgIGZ1bmN0aW9uIHAoYiwgZykge1xuICAgICAgICBmb3IgKHZhciBFID0gMDsgRSA8IGIubGVuZ3RoOyBFKyspIHtcbiAgICAgICAgICB2YXIgQyA9IGJbRV0sIE8gPSBhW0MuaWRdO1xuICAgICAgICAgIGlmIChPKSB7XG4gICAgICAgICAgICBPLnJlZnMrKztcbiAgICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgTy5wYXJ0cy5sZW5ndGg7IEkrKylcbiAgICAgICAgICAgICAgTy5wYXJ0c1tJXShDLnBhcnRzW0ldKTtcbiAgICAgICAgICAgIGZvciAoOyBJIDwgQy5wYXJ0cy5sZW5ndGg7IEkrKylcbiAgICAgICAgICAgICAgTy5wYXJ0cy5wdXNoKHgoQy5wYXJ0c1tJXSwgZykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgSCA9IFtdO1xuICAgICAgICAgICAgZm9yIChJID0gMDsgSSA8IEMucGFydHMubGVuZ3RoOyBJKyspXG4gICAgICAgICAgICAgIEgucHVzaCh4KEMucGFydHNbSV0sIGcpKTtcbiAgICAgICAgICAgIGFbQy5pZF0gPSB7IGlkOiBDLmlkLCByZWZzOiAxLCBwYXJ0czogSCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gayhiLCBnKSB7XG4gICAgICAgIGZvciAodmFyIEUgPSBbXSwgQyA9IHt9LCBPID0gMDsgTyA8IGIubGVuZ3RoOyBPKyspIHtcbiAgICAgICAgICB2YXIgSSA9IGJbT10sIEggPSBnLmJhc2UgPyBJWzBdICsgZy5iYXNlIDogSVswXSwgTCA9IHsgY3NzOiBJWzFdLCBtZWRpYTogSVsyXSwgc291cmNlTWFwOiBJWzNdIH07XG4gICAgICAgICAgQ1tIXSA/IENbSF0ucGFydHMucHVzaChMKSA6IEUucHVzaChDW0hdID0geyBpZDogSCwgcGFydHM6IFtMXSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF8oYiwgZykge1xuICAgICAgICB2YXIgRSA9IGMoYi5pbnNlcnRJbnRvKTtcbiAgICAgICAgaWYgKCFFKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICB2YXIgQyA9IGZbZi5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGIuaW5zZXJ0QXQgPT09IFwidG9wXCIpXG4gICAgICAgICAgQyA/IEMubmV4dFNpYmxpbmcgPyBFLmluc2VydEJlZm9yZShnLCBDLm5leHRTaWJsaW5nKSA6IEUuYXBwZW5kQ2hpbGQoZykgOiBFLmluc2VydEJlZm9yZShnLCBFLmZpcnN0Q2hpbGQpLCBmLnB1c2goZyk7XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpXG4gICAgICAgICAgRS5hcHBlbmRDaGlsZChnKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBiLmluc2VydEF0ICE9IFwib2JqZWN0XCIgfHwgIWIuaW5zZXJ0QXQuYmVmb3JlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbU3R5bGUgTG9hZGVyXVxuXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXG5gKTtcbiAgICAgICAgICB2YXIgTyA9IGMoYi5pbnNlcnRJbnRvICsgXCIgXCIgKyBiLmluc2VydEF0LmJlZm9yZSk7XG4gICAgICAgICAgRS5pbnNlcnRCZWZvcmUoZywgTyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE4oYikge1xuICAgICAgICBpZiAoYi5wYXJlbnROb2RlID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpO1xuICAgICAgICB2YXIgZyA9IGYuaW5kZXhPZihiKTtcbiAgICAgICAgZyA+PSAwICYmIGYuc3BsaWNlKGcsIDEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gQShiKSB7XG4gICAgICAgIHZhciBnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICByZXR1cm4gYi5hdHRycy50eXBlID09PSB2b2lkIDAgJiYgKGIuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIiksIHkoZywgYi5hdHRycyksIF8oYiwgZyksIGc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB5KGIsIGcpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZykuZm9yRWFjaChmdW5jdGlvbihFKSB7XG4gICAgICAgICAgYi5zZXRBdHRyaWJ1dGUoRSwgZ1tFXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geChiLCBnKSB7XG4gICAgICAgIHZhciBFLCBDLCBPLCBJO1xuICAgICAgICBpZiAoZy50cmFuc2Zvcm0gJiYgYi5jc3MpIHtcbiAgICAgICAgICBpZiAoIShJID0gZy50cmFuc2Zvcm0oYi5jc3MpKSlcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgYi5jc3MgPSBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnLnNpbmdsZXRvbikge1xuICAgICAgICAgIHZhciBIID0gaCsrO1xuICAgICAgICAgIEUgPSB1IHx8ICh1ID0gQShnKSksIEMgPSBSLmJpbmQobnVsbCwgRSwgSCwgITEpLCBPID0gUi5iaW5kKG51bGwsIEUsIEgsICEwKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgYi5zb3VyY2VNYXAgJiYgdHlwZW9mIFVSTCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgQmxvYiA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGJ0b2EgPT0gXCJmdW5jdGlvblwiID8gKEUgPSBmdW5jdGlvbihMKSB7XG4gICAgICAgICAgICB2YXIgVyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgICAgICAgcmV0dXJuIEwuYXR0cnMudHlwZSA9PT0gdm9pZCAwICYmIChMLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCIpLCBMLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiLCB5KFcsIEwuYXR0cnMpLCBfKEwsIFcpLCBXO1xuICAgICAgICAgIH0oZyksIEMgPSBmdW5jdGlvbihMLCBXLCBsZSkge1xuICAgICAgICAgICAgdmFyIFEgPSBsZS5jc3MsIEVlID0gbGUuc291cmNlTWFwLCBJdCA9IFcuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB2b2lkIDAgJiYgRWU7XG4gICAgICAgICAgICAoVy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgSXQpICYmIChRID0gdihRKSksIEVlICYmIChRICs9IGBcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsYCArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KEVlKSkpKSArIFwiICovXCIpO1xuICAgICAgICAgICAgdmFyIE10ID0gbmV3IEJsb2IoW1FdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KSwgWGUgPSBMLmhyZWY7XG4gICAgICAgICAgICBMLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKE10KSwgWGUgJiYgVVJMLnJldm9rZU9iamVjdFVSTChYZSk7XG4gICAgICAgICAgfS5iaW5kKG51bGwsIEUsIGcpLCBPID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBOKEUpLCBFLmhyZWYgJiYgVVJMLnJldm9rZU9iamVjdFVSTChFLmhyZWYpO1xuICAgICAgICAgIH0pIDogKEUgPSBBKGcpLCBDID0gZnVuY3Rpb24oTCwgVykge1xuICAgICAgICAgICAgdmFyIGxlID0gVy5jc3MsIFEgPSBXLm1lZGlhO1xuICAgICAgICAgICAgaWYgKFEgJiYgTC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBRKSwgTC5zdHlsZVNoZWV0KVxuICAgICAgICAgICAgICBMLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGxlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoOyBMLmZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICAgICAgICBMLnJlbW92ZUNoaWxkKEwuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgIEwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQobnVsbCwgRSksIE8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE4oRSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDKGIpLCBmdW5jdGlvbihMKSB7XG4gICAgICAgICAgaWYgKEwpIHtcbiAgICAgICAgICAgIGlmIChMLmNzcyA9PT0gYi5jc3MgJiYgTC5tZWRpYSA9PT0gYi5tZWRpYSAmJiBMLnNvdXJjZU1hcCA9PT0gYi5zb3VyY2VNYXApXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIEMoYiA9IEwpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgTygpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oYiwgZykge1xuICAgICAgICBpZiAodHlwZW9mIERFQlVHIDwgXCJ1XCIgJiYgREVCVUcgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICAgICAgICAoZyA9IGcgfHwge30pLmF0dHJzID0gdHlwZW9mIGcuYXR0cnMgPT0gXCJvYmplY3RcIiA/IGcuYXR0cnMgOiB7fSwgZy5zaW5nbGV0b24gfHwgdHlwZW9mIGcuc2luZ2xldG9uID09IFwiYm9vbGVhblwiIHx8IChnLnNpbmdsZXRvbiA9IGwoKSksIGcuaW5zZXJ0SW50byB8fCAoZy5pbnNlcnRJbnRvID0gXCJoZWFkXCIpLCBnLmluc2VydEF0IHx8IChnLmluc2VydEF0ID0gXCJib3R0b21cIik7XG4gICAgICAgIHZhciBFID0gayhiLCBnKTtcbiAgICAgICAgcmV0dXJuIHAoRSwgZyksIGZ1bmN0aW9uKEMpIHtcbiAgICAgICAgICBmb3IgKHZhciBPID0gW10sIEkgPSAwOyBJIDwgRS5sZW5ndGg7IEkrKykge1xuICAgICAgICAgICAgdmFyIEggPSBFW0ldO1xuICAgICAgICAgICAgKEwgPSBhW0guaWRdKS5yZWZzLS0sIE8ucHVzaChMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChDICYmIHAoayhDLCBnKSwgZyksIEkgPSAwOyBJIDwgTy5sZW5ndGg7IEkrKykge1xuICAgICAgICAgICAgdmFyIEw7XG4gICAgICAgICAgICBpZiAoKEwgPSBPW0ldKS5yZWZzID09PSAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIFcgPSAwOyBXIDwgTC5wYXJ0cy5sZW5ndGg7IFcrKylcbiAgICAgICAgICAgICAgICBMLnBhcnRzW1ddKCk7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhW0wuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgdywgTSA9ICh3ID0gW10sIGZ1bmN0aW9uKGIsIGcpIHtcbiAgICAgICAgcmV0dXJuIHdbYl0gPSBnLCB3LmZpbHRlcihCb29sZWFuKS5qb2luKGBcbmApO1xuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiBSKGIsIGcsIEUsIEMpIHtcbiAgICAgICAgdmFyIE8gPSBFID8gXCJcIiA6IEMuY3NzO1xuICAgICAgICBpZiAoYi5zdHlsZVNoZWV0KVxuICAgICAgICAgIGIuc3R5bGVTaGVldC5jc3NUZXh0ID0gTShnLCBPKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIEkgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShPKSwgSCA9IGIuY2hpbGROb2RlcztcbiAgICAgICAgICBIW2ddICYmIGIucmVtb3ZlQ2hpbGQoSFtnXSksIEgubGVuZ3RoID8gYi5pbnNlcnRCZWZvcmUoSSwgSFtnXSkgOiBiLmFwcGVuZENoaWxkKEkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24odCwgbykge1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgbiA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubG9jYXRpb247XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgICAgICAgaWYgKCFpIHx8IHR5cGVvZiBpICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHZhciByID0gbi5wcm90b2NvbCArIFwiLy9cIiArIG4uaG9zdCwgYSA9IHIgKyBuLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuICAgICAgICByZXR1cm4gaS5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24obCwgYykge1xuICAgICAgICAgIHZhciB1LCBoID0gYy50cmltKCkucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKGYsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIH0pLnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24oZiwgdikge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QoaCkgPyBsIDogKHUgPSBoLmluZGV4T2YoXCIvL1wiKSA9PT0gMCA/IGggOiBoLmluZGV4T2YoXCIvXCIpID09PSAwID8gciArIGggOiBhICsgaC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIiksIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkodSkgKyBcIilcIik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgbiwgciwgYSwgbCwgYywgdSwgaCwgZiwgdjtcbiAgICAgIHQuZXhwb3J0cyA9IChuID0gXCJjZHgtbm90aWZpZXNcIiwgciA9IFwiY2R4LW5vdGlmeVwiLCBhID0gXCJjZHgtbm90aWZ5X19jcm9zc1wiLCBsID0gXCJjZHgtbm90aWZ5X19idXR0b24tLWNvbmZpcm1cIiwgYyA9IFwiY2R4LW5vdGlmeV9fYnV0dG9uLS1jYW5jZWxcIiwgdSA9IFwiY2R4LW5vdGlmeV9faW5wdXRcIiwgaCA9IFwiY2R4LW5vdGlmeV9fYnV0dG9uXCIsIGYgPSBcImNkeC1ub3RpZnlfX2J0bnMtd3JhcHBlclwiLCB7IGFsZXJ0OiB2ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLCBOID0gcC5tZXNzYWdlLCBBID0gcC5zdHlsZTtcbiAgICAgICAgcmV0dXJuIGsuY2xhc3NMaXN0LmFkZChyKSwgQSAmJiBrLmNsYXNzTGlzdC5hZGQociArIFwiLS1cIiArIEEpLCBrLmlubmVySFRNTCA9IE4sIF8uY2xhc3NMaXN0LmFkZChhKSwgXy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgay5yZW1vdmUuYmluZChrKSksIGsuYXBwZW5kQ2hpbGQoXyksIGs7XG4gICAgICB9LCBjb25maXJtOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBrID0gdihwKSwgXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIE4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgeSA9IGsucXVlcnlTZWxlY3RvcihcIi5cIiArIGEpLCB4ID0gcC5jYW5jZWxIYW5kbGVyLCB3ID0gcC5va0hhbmRsZXI7XG4gICAgICAgIHJldHVybiBfLmNsYXNzTGlzdC5hZGQoZiksIE4uaW5uZXJIVE1MID0gcC5va1RleHQgfHwgXCJDb25maXJtXCIsIEEuaW5uZXJIVE1MID0gcC5jYW5jZWxUZXh0IHx8IFwiQ2FuY2VsXCIsIE4uY2xhc3NMaXN0LmFkZChoKSwgQS5jbGFzc0xpc3QuYWRkKGgpLCBOLmNsYXNzTGlzdC5hZGQobCksIEEuY2xhc3NMaXN0LmFkZChjKSwgeCAmJiB0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIgJiYgKEEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHgpLCB5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB4KSksIHcgJiYgdHlwZW9mIHcgPT0gXCJmdW5jdGlvblwiICYmIE4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHcpLCBOLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBrLnJlbW92ZS5iaW5kKGspKSwgQS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgay5yZW1vdmUuYmluZChrKSksIF8uYXBwZW5kQ2hpbGQoTiksIF8uYXBwZW5kQ2hpbGQoQSksIGsuYXBwZW5kQ2hpbGQoXyksIGs7XG4gICAgICB9LCBwcm9tcHQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdmFyIGsgPSB2KHApLCBfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgTiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIEEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksIHkgPSBrLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBhKSwgeCA9IHAuY2FuY2VsSGFuZGxlciwgdyA9IHAub2tIYW5kbGVyO1xuICAgICAgICByZXR1cm4gXy5jbGFzc0xpc3QuYWRkKGYpLCBOLmlubmVySFRNTCA9IHAub2tUZXh0IHx8IFwiT2tcIiwgTi5jbGFzc0xpc3QuYWRkKGgpLCBOLmNsYXNzTGlzdC5hZGQobCksIEEuY2xhc3NMaXN0LmFkZCh1KSwgcC5wbGFjZWhvbGRlciAmJiBBLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIHAucGxhY2Vob2xkZXIpLCBwLmRlZmF1bHQgJiYgKEEudmFsdWUgPSBwLmRlZmF1bHQpLCBwLmlucHV0VHlwZSAmJiAoQS50eXBlID0gcC5pbnB1dFR5cGUpLCB4ICYmIHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIiAmJiB5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB4KSwgdyAmJiB0eXBlb2YgdyA9PSBcImZ1bmN0aW9uXCIgJiYgTi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdyhBLnZhbHVlKTtcbiAgICAgICAgfSksIE4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGsucmVtb3ZlLmJpbmQoaykpLCBfLmFwcGVuZENoaWxkKEEpLCBfLmFwcGVuZENoaWxkKE4pLCBrLmFwcGVuZENoaWxkKF8pLCBrO1xuICAgICAgfSwgZ2V0V3JhcHBlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgICAgcmV0dXJuIHAuY2xhc3NMaXN0LmFkZChuKSwgcDtcbiAgICAgIH0gfSk7XG4gICAgfV0pO1xuICB9KTtcbn0pKHRvKTtcbmNvbnN0IG9vID0gLyogQF9fUFVSRV9fICovIHhlKExlKTtcbmNsYXNzIGlvIHtcbiAgLyoqXG4gICAqIFNob3cgd2ViIG5vdGlmaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge05vdGlmaWVyT3B0aW9ucyB8IENvbmZpcm1Ob3RpZmllck9wdGlvbnMgfCBQcm9tcHROb3RpZmllck9wdGlvbnN9IG9wdGlvbnMgLSBub3RpZmljYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgc2hvdyhlKSB7XG4gICAgb28uc2hvdyhlKTtcbiAgfVxufVxuY2xhc3Mgbm8gZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uIC0gTW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmV2ZW50c0Rpc3BhdGNoZXIgLSBFZGl0b3IncyBldmVudCBkaXNwYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLm5vdGlmaWVyID0gbmV3IGlvKCk7XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvdzogKGUpID0+IHRoaXMuc2hvdyhlKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNob3cgbm90aWZpY2F0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Tm90aWZpZXJPcHRpb25zfSBvcHRpb25zIC0gbWVzc2FnZSBvcHRpb25cbiAgICovXG4gIHNob3coZSkge1xuICAgIHJldHVybiB0aGlzLm5vdGlmaWVyLnNob3coZSk7XG4gIH1cbn1cbmNsYXNzIHNvIGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgY29uc3QgZSA9ICgpID0+IHRoaXMuaXNFbmFibGVkO1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGU6ICh0KSA9PiB0aGlzLnRvZ2dsZSh0KSxcbiAgICAgIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiBlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9yIHRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gc3RhdGUgLSBzZXQgb3IgdG9nZ2xlIHN0YXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBjdXJyZW50IHZhbHVlXG4gICAqL1xuICB0b2dnbGUoZSkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5SZWFkT25seS50b2dnbGUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCByZWFkLW9ubHkgc3RhdGVcbiAgICovXG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZDtcbiAgfVxufVxudmFyIE9lID0ge30sIHJvID0ge1xuICBnZXQgZXhwb3J0cygpIHtcbiAgICByZXR1cm4gT2U7XG4gIH0sXG4gIHNldCBleHBvcnRzKHMpIHtcbiAgICBPZSA9IHM7XG4gIH1cbn07XG4oZnVuY3Rpb24ocywgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIHMuZXhwb3J0cyA9IG8oKTtcbiAgfSkoTHQsIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHQoaCkge1xuICAgICAgdmFyIGYgPSBoLnRhZ3MsIHYgPSBPYmplY3Qua2V5cyhmKSwgcCA9IHYubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmW2tdO1xuICAgICAgfSkuZXZlcnkoZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4gayA9PT0gXCJvYmplY3RcIiB8fCBrID09PSBcImJvb2xlYW5cIiB8fCBrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9KTtcbiAgICAgIGlmICghcClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbmZpZ3VyYXRpb24gd2FzIGludmFsaWRcIik7XG4gICAgICB0aGlzLmNvbmZpZyA9IGg7XG4gICAgfVxuICAgIHZhciBvID0gW1wiUFwiLCBcIkxJXCIsIFwiVERcIiwgXCJUSFwiLCBcIkRJVlwiLCBcIkgxXCIsIFwiSDJcIiwgXCJIM1wiLCBcIkg0XCIsIFwiSDVcIiwgXCJINlwiLCBcIlBSRVwiXTtcbiAgICBmdW5jdGlvbiBpKGgpIHtcbiAgICAgIHJldHVybiBvLmluZGV4T2YoaC5ub2RlTmFtZSkgIT09IC0xO1xuICAgIH1cbiAgICB2YXIgbiA9IFtcIkFcIiwgXCJCXCIsIFwiU1RST05HXCIsIFwiSVwiLCBcIkVNXCIsIFwiU1VCXCIsIFwiU1VQXCIsIFwiVVwiLCBcIlNUUklLRVwiXTtcbiAgICBmdW5jdGlvbiByKGgpIHtcbiAgICAgIHJldHVybiBuLmluZGV4T2YoaC5ub2RlTmFtZSkgIT09IC0xO1xuICAgIH1cbiAgICB0LnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgIGNvbnN0IGYgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKSwgdiA9IGYuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHJldHVybiB2LmlubmVySFRNTCA9IGgsIHRoaXMuX3Nhbml0aXplKGYsIHYpLCB2LmlubmVySFRNTDtcbiAgICB9LCB0LnByb3RvdHlwZS5fc2FuaXRpemUgPSBmdW5jdGlvbihoLCBmKSB7XG4gICAgICB2YXIgdiA9IGEoaCwgZiksIHAgPSB2LmZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChwKVxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHAubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKVxuICAgICAgICAgICAgaWYgKHAuZGF0YS50cmltKCkgPT09IFwiXCIgJiYgKHAucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBpKHAucHJldmlvdXNFbGVtZW50U2libGluZykgfHwgcC5uZXh0RWxlbWVudFNpYmxpbmcgJiYgaShwLm5leHRFbGVtZW50U2libGluZykpKSB7XG4gICAgICAgICAgICAgIGYucmVtb3ZlQ2hpbGQocCksIHRoaXMuX3Nhbml0aXplKGgsIGYpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAocC5ub2RlVHlwZSA9PT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgIGYucmVtb3ZlQ2hpbGQocCksIHRoaXMuX3Nhbml0aXplKGgsIGYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrID0gcihwKSwgXztcbiAgICAgICAgICBrICYmIChfID0gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChwLmNoaWxkTm9kZXMsIGkpKTtcbiAgICAgICAgICB2YXIgTiA9ICEhZi5wYXJlbnROb2RlLCBBID0gaShmKSAmJiBpKHApICYmIE4sIHkgPSBwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHggPSBsKHRoaXMuY29uZmlnLCB5LCBwKSwgdyA9IGsgJiYgXztcbiAgICAgICAgICBpZiAodyB8fCBjKHAsIHgpIHx8ICF0aGlzLmNvbmZpZy5rZWVwTmVzdGVkQmxvY2tFbGVtZW50cyAmJiBBKSB7XG4gICAgICAgICAgICBpZiAoIShwLm5vZGVOYW1lID09PSBcIlNDUklQVFwiIHx8IHAubm9kZU5hbWUgPT09IFwiU1RZTEVcIikpXG4gICAgICAgICAgICAgIGZvciAoOyBwLmNoaWxkTm9kZXMubGVuZ3RoID4gMDsgKVxuICAgICAgICAgICAgICAgIGYuaW5zZXJ0QmVmb3JlKHAuY2hpbGROb2Rlc1swXSwgcCk7XG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKHApLCB0aGlzLl9zYW5pdGl6ZShoLCBmKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBNID0gMDsgTSA8IHAuYXR0cmlidXRlcy5sZW5ndGg7IE0gKz0gMSkge1xuICAgICAgICAgICAgdmFyIFIgPSBwLmF0dHJpYnV0ZXNbTV07XG4gICAgICAgICAgICB1KFIsIHgsIHApICYmIChwLnJlbW92ZUF0dHJpYnV0ZShSLm5hbWUpLCBNID0gTSAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zYW5pdGl6ZShoLCBwKTtcbiAgICAgICAgfSB3aGlsZSAocCA9IHYubmV4dFNpYmxpbmcoKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhKGgsIGYpIHtcbiAgICAgIHJldHVybiBoLmNyZWF0ZVRyZWVXYWxrZXIoXG4gICAgICAgIGYsXG4gICAgICAgIE5vZGVGaWx0ZXIuU0hPV19URVhUIHwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGwoaCwgZiwgdikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBoLnRhZ3NbZl0gPT0gXCJmdW5jdGlvblwiID8gaC50YWdzW2ZdKHYpIDogaC50YWdzW2ZdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKGgsIGYpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZiA+IFwidVwiID8gITAgOiB0eXBlb2YgZiA9PSBcImJvb2xlYW5cIiA/ICFmIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHUoaCwgZiwgdikge1xuICAgICAgdmFyIHAgPSBoLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBmID09PSAhMCA/ICExIDogdHlwZW9mIGZbcF0gPT0gXCJmdW5jdGlvblwiID8gIWZbcF0oaC52YWx1ZSwgdikgOiB0eXBlb2YgZltwXSA+IFwidVwiIHx8IGZbcF0gPT09ICExID8gITAgOiB0eXBlb2YgZltwXSA9PSBcInN0cmluZ1wiID8gZltwXSAhPT0gaC52YWx1ZSA6ICExO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSk7XG59KShybyk7XG5jb25zdCBhbyA9IE9lO1xuZnVuY3Rpb24gaHQocywgZSkge1xuICByZXR1cm4gcy5tYXAoKHQpID0+IHtcbiAgICBjb25zdCBvID0gRChlKSA/IGUodC50b29sKSA6IGU7XG4gICAgcmV0dXJuIFYobykgfHwgKHQuZGF0YSA9IFBlKHQuZGF0YSwgbykpLCB0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIFoocywgZSA9IHt9KSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgdGFnczogZVxuICB9O1xuICByZXR1cm4gbmV3IGFvKHQpLmNsZWFuKHMpO1xufVxuZnVuY3Rpb24gUGUocywgZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzKSA/IGxvKHMsIGUpIDogaihzKSA/IGNvKHMsIGUpIDogSihzKSA/IGhvKHMsIGUpIDogcztcbn1cbmZ1bmN0aW9uIGxvKHMsIGUpIHtcbiAgcmV0dXJuIHMubWFwKCh0KSA9PiBQZSh0LCBlKSk7XG59XG5mdW5jdGlvbiBjbyhzLCBlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgZm9yIChjb25zdCBvIGluIHMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBvKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGkgPSBzW29dLCBuID0gdW8oZVtvXSkgPyBlW29dIDogZTtcbiAgICB0W29dID0gUGUoaSwgbik7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBobyhzLCBlKSB7XG4gIHJldHVybiBqKGUpID8gWihzLCBlKSA6IGUgPT09ICExID8gWihzLCB7fSkgOiBzO1xufVxuZnVuY3Rpb24gdW8ocykge1xuICByZXR1cm4gaihzKSB8fCBOdChzKSB8fCBEKHMpO1xufVxuY2xhc3MgcG8gZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xlYW46IChlLCB0KSA9PiB0aGlzLmNsZWFuKGUsIHQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBzYW5pdGl6aW5nIG9mIGEgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWludFN0cmluZyAtIHdoYXQgdG8gc2FuaXRpemVcbiAgICogQHBhcmFtIHtTYW5pdGl6ZXJDb25maWd9IGNvbmZpZyAtIHNhbml0aXplciBjb25maWdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNsZWFuKGUsIHQpIHtcbiAgICByZXR1cm4gWihlLCB0KTtcbiAgfVxufVxuY2xhc3MgZm8gZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYXZlcn1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzYXZlOiAoKSA9PiB0aGlzLnNhdmUoKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBFZGl0b3IncyBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtPdXRwdXREYXRhfVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBjb25zdCBlID0gXCJFZGl0b3IncyBjb250ZW50IGNhbiBub3QgYmUgc2F2ZWQgaW4gcmVhZC1vbmx5IG1vZGVcIjtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuUmVhZE9ubHkuaXNFbmFibGVkID8gKEsoZSwgXCJ3YXJuXCIpLCBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZSkpKSA6IHRoaXMuRWRpdG9yLlNhdmVyLnNhdmUoKTtcbiAgfVxufVxuY2xhc3MgZ28gZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZWxlY3Rpb25BUElJbnRlcmZhY2V9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmluZFBhcmVudFRhZzogKGUsIHQpID0+IHRoaXMuZmluZFBhcmVudFRhZyhlLCB0KSxcbiAgICAgIGV4cGFuZFRvVGFnOiAoZSkgPT4gdGhpcy5leHBhbmRUb1RhZyhlKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIExvb2tzIGFoZWFkIGZyb20gc2VsZWN0aW9uIGFuZCBmaW5kIHBhc3NlZCB0YWcgd2l0aCBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIC0gdGFnIHRvIGZpbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIHRhZydzIGNsYXNzIG5hbWVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmaW5kUGFyZW50VGFnKGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IG0oKS5maW5kUGFyZW50VGFnKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBFeHBhbmQgc2VsZWN0aW9uIHRvIHBhc3NlZCB0YWdcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhZyB0aGF0IHNob3VsZCBjb250YWluIHNlbGVjdGlvblxuICAgKi9cbiAgZXhwYW5kVG9UYWcoZSkge1xuICAgIG5ldyBtKCkuZXhwYW5kVG9UYWcoZSk7XG4gIH1cbn1cbmNsYXNzIGJvIGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBFeHBvcnRlZCBjbGFzc2VzXG4gICAqL1xuICBnZXQgY2xhc3NlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBCYXNlIEJsb2NrIHN0eWxlc1xuICAgICAgICovXG4gICAgICBibG9jazogXCJjZHgtYmxvY2tcIixcbiAgICAgIC8qKlxuICAgICAgICogSW5saW5lIFRvb2xzIHN0eWxlc1xuICAgICAgICovXG4gICAgICBpbmxpbmVUb29sQnV0dG9uOiBcImNlLWlubGluZS10b29sXCIsXG4gICAgICBpbmxpbmVUb29sQnV0dG9uQWN0aXZlOiBcImNlLWlubGluZS10b29sLS1hY3RpdmVcIixcbiAgICAgIC8qKlxuICAgICAgICogVUkgZWxlbWVudHNcbiAgICAgICAqL1xuICAgICAgaW5wdXQ6IFwiY2R4LWlucHV0XCIsXG4gICAgICBsb2FkZXI6IFwiY2R4LWxvYWRlclwiLFxuICAgICAgYnV0dG9uOiBcImNkeC1idXR0b25cIixcbiAgICAgIC8qKlxuICAgICAgICogU2V0dGluZ3Mgc3R5bGVzXG4gICAgICAgKi9cbiAgICAgIHNldHRpbmdzQnV0dG9uOiBcImNkeC1zZXR0aW5ncy1idXR0b25cIixcbiAgICAgIHNldHRpbmdzQnV0dG9uQWN0aXZlOiBcImNkeC1zZXR0aW5ncy1idXR0b24tLWFjdGl2ZVwiXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgbW8gZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtUb29sYmFyfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb3NlOiAoKSA9PiB0aGlzLmNsb3NlKCksXG4gICAgICBvcGVuOiAoKSA9PiB0aGlzLm9wZW4oKSxcbiAgICAgIHRvZ2dsZUJsb2NrU2V0dGluZ3M6IChlKSA9PiB0aGlzLnRvZ2dsZUJsb2NrU2V0dGluZ3MoZSksXG4gICAgICB0b2dnbGVUb29sYm94OiAoZSkgPT4gdGhpcy50b2dnbGVUb29sYm94KGUpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT3BlbiB0b29sYmFyXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgdG9vbGJhciBhbmQgYWxsIGluY2x1ZGVkIGVsZW1lbnRzXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgQmxvY2sgU2V0dGluZyBvZiB0aGUgY3VycmVudCBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5pbmdTdGF0ZSDigJQgIG9wZW5pbmcgc3RhdGUgb2YgQmxvY2sgU2V0dGluZ1xuICAgKi9cbiAgdG9nZ2xlQmxvY2tTZXR0aW5ncyhlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleCA9PT0gLTEpIHtcbiAgICAgIEsoXCJDb3VsZCd0IHRvZ2dsZSB0aGUgVG9vbGJhciBiZWNhdXNlIHRoZXJlIGlzIG5vIGJsb2NrIHNlbGVjdGVkIFwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPz8gIXRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkID8gKHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuKCkpIDogdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIHRvb2xib3hcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuaW5nU3RhdGUgLSBPcGVuaW5nIHN0YXRlIG9mIHRvb2xib3hcbiAgICovXG4gIHRvZ2dsZVRvb2xib3goZSkge1xuICAgIGlmICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXggPT09IC0xKSB7XG4gICAgICBLKFwiQ291bGQndCB0b2dnbGUgdGhlIFRvb2xib3ggYmVjYXVzZSB0aGVyZSBpcyBubyBibG9jayBzZWxlY3RlZCBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID8/ICF0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbmVkID8gKHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKSwgdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lm9wZW4oKSkgOiB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3guY2xvc2UoKTtcbiAgfVxufVxudmFyIF9lID0ge30sIGtvID0ge1xuICBnZXQgZXhwb3J0cygpIHtcbiAgICByZXR1cm4gX2U7XG4gIH0sXG4gIHNldCBleHBvcnRzKHMpIHtcbiAgICBfZSA9IHM7XG4gIH1cbn07XG4vKiFcbiAqIENvZGVYLlRvb2x0aXBzXG4gKiBcbiAqIEB2ZXJzaW9uIDEuMC41XG4gKiBcbiAqIEBsaWNlbmNlIE1JVFxuICogQGF1dGhvciBDb2RlWCA8aHR0cHM6Ly9jb2RleC5zbz5cbiAqIFxuICogXG4gKi9cbihmdW5jdGlvbihzLCBlKSB7XG4gIChmdW5jdGlvbih0LCBvKSB7XG4gICAgcy5leHBvcnRzID0gbygpO1xuICB9KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZnVuY3Rpb24gaShuKSB7XG4gICAgICAgIGlmIChvW25dKVxuICAgICAgICAgIHJldHVybiBvW25dLmV4cG9ydHM7XG4gICAgICAgIHZhciByID0gb1tuXSA9IHsgaTogbiwgbDogITEsIGV4cG9ydHM6IHt9IH07XG4gICAgICAgIHJldHVybiB0W25dLmNhbGwoci5leHBvcnRzLCByLCByLmV4cG9ydHMsIGkpLCByLmwgPSAhMCwgci5leHBvcnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGkubSA9IHQsIGkuYyA9IG8sIGkuZCA9IGZ1bmN0aW9uKG4sIHIsIGEpIHtcbiAgICAgICAgaS5vKG4sIHIpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCByLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGEgfSk7XG4gICAgICB9LCBpLnIgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICAgIH0sIGkudCA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgICAgaWYgKDEgJiByICYmIChuID0gaShuKSksIDggJiByIHx8IDQgJiByICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgbiAmJiBuLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIHZhciBhID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmIChpLnIoYSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgdmFsdWU6IG4gfSksIDIgJiByICYmIHR5cGVvZiBuICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgZm9yICh2YXIgbCBpbiBuKVxuICAgICAgICAgICAgaS5kKGEsIGwsIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5bY107XG4gICAgICAgICAgICB9LmJpbmQobnVsbCwgbCkpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIHIgPSBuICYmIG4uX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihuLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcik7XG4gICAgICB9LCBpLnAgPSBcIlwiLCBpKGkucyA9IDApO1xuICAgIH0oW2Z1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIHQuZXhwb3J0cyA9IGkoMSk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgaS5yKG8pLCBpLmQobywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0pO1xuICAgICAgY2xhc3MgbiB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSB7IHdyYXBwZXI6IG51bGwsIGNvbnRlbnQ6IG51bGwgfSwgdGhpcy5zaG93ZWQgPSAhMSwgdGhpcy5vZmZzZXRUb3AgPSAxMCwgdGhpcy5vZmZzZXRMZWZ0ID0gMTAsIHRoaXMub2Zmc2V0UmlnaHQgPSAxMCwgdGhpcy5oaWRpbmdEZWxheSA9IDAsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaG93ZWQgJiYgdGhpcy5oaWRlKCEwKTtcbiAgICAgICAgICB9LCB0aGlzLmxvYWRTdHlsZXMoKSwgdGhpcy5wcmVwYXJlKCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsLCB7IHBhc3NpdmU6ICEwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdldCBDU1MoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdG9vbHRpcDogXCJjdFwiLCB0b29sdGlwQ29udGVudDogXCJjdF9fY29udGVudFwiLCB0b29sdGlwU2hvd246IFwiY3QtLXNob3duXCIsIHBsYWNlbWVudDogeyBsZWZ0OiBcImN0LS1sZWZ0XCIsIGJvdHRvbTogXCJjdC0tYm90dG9tXCIsIHJpZ2h0OiBcImN0LS1yaWdodFwiLCB0b3A6IFwiY3QtLXRvcFwiIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBzaG93KGEsIGwsIGMpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIgfHwgdGhpcy5wcmVwYXJlKCksIHRoaXMuaGlkaW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5oaWRpbmdUaW1lb3V0KTtcbiAgICAgICAgICBjb25zdCB1ID0gT2JqZWN0LmFzc2lnbih7IHBsYWNlbWVudDogXCJib3R0b21cIiwgbWFyZ2luVG9wOiAwLCBtYXJnaW5MZWZ0OiAwLCBtYXJnaW5SaWdodDogMCwgbWFyZ2luQm90dG9tOiAwLCBkZWxheTogNzAsIGhpZGluZ0RlbGF5OiAwIH0sIGMpO1xuICAgICAgICAgIGlmICh1LmhpZGluZ0RlbGF5ICYmICh0aGlzLmhpZGluZ0RlbGF5ID0gdS5oaWRpbmdEZWxheSksIHRoaXMubm9kZXMuY29udGVudC5pbm5lckhUTUwgPSBcIlwiLCB0eXBlb2YgbCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwpKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGwgaW5zdGFuY2VvZiBOb2RlKSlcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbQ29kZVggVG9vbHRpcF0gV3JvbmcgdHlwZSBvZiDCq2NvbnRlbnTCuyBwYXNzZWQuIEl0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBOb2RlIG9yIFN0cmluZy4gQnV0IFwiICsgdHlwZW9mIGwgKyBcIiBnaXZlbi5cIik7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUoLi4uT2JqZWN0LnZhbHVlcyh0aGlzLkNTUy5wbGFjZW1lbnQpKSwgdS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZVRvcChhLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICB0aGlzLnBsYWNlTGVmdChhLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZVJpZ2h0KGEsIHUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMucGxhY2VCb3R0b20oYSwgdSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHUgJiYgdS5kZWxheSA/IHRoaXMuc2hvd2luZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITA7XG4gICAgICAgICAgfSwgdS5kZWxheSkgOiAodGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MudG9vbHRpcFNob3duKSwgdGhpcy5zaG93ZWQgPSAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZShhID0gITEpIHtcbiAgICAgICAgICBpZiAodGhpcy5oaWRpbmdEZWxheSAmJiAhYSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGlkaW5nVGltZW91dCksIHZvaWQgKHRoaXMuaGlkaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoITApO1xuICAgICAgICAgICAgfSwgdGhpcy5oaWRpbmdEZWxheSkpO1xuICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITEsIHRoaXMuc2hvd2luZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuc2hvd2luZ1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIG9uSG92ZXIoYSwgbCwgYykge1xuICAgICAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaG93KGEsIGwsIGMpO1xuICAgICAgICAgIH0pLCBhLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyLnJlbW92ZSgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVdpbmRvd1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGFyZSgpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSB0aGlzLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudG9vbHRpcCksIHRoaXMubm9kZXMuY29udGVudCA9IHRoaXMubWFrZShcImRpdlwiLCB0aGlzLkNTUy50b29sdGlwQ29udGVudCksIHRoaXMuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy5jb250ZW50KSwgdGhpcy5hcHBlbmQoZG9jdW1lbnQuYm9keSwgdGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkU3R5bGVzKCkge1xuICAgICAgICAgIGNvbnN0IGEgPSBcImNvZGV4LXRvb2x0aXBzLXN0eWxlXCI7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGwgPSBpKDIpLCBjID0gdGhpcy5tYWtlKFwic3R5bGVcIiwgbnVsbCwgeyB0ZXh0Q29udGVudDogbC50b1N0cmluZygpLCBpZDogYSB9KTtcbiAgICAgICAgICB0aGlzLnByZXBlbmQoZG9jdW1lbnQuaGVhZCwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VCb3R0b20oYSwgbCkge1xuICAgICAgICAgIGNvbnN0IGMgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0ICsgYS5jbGllbnRXaWR0aCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyLCBoID0gYy5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQgKyB0aGlzLm9mZnNldFRvcCArIGwubWFyZ2luVG9wO1xuICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXCJib3R0b21cIiwgdSwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VUb3AoYSwgbCkge1xuICAgICAgICAgIGNvbnN0IGMgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0ICsgYS5jbGllbnRXaWR0aCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0V2lkdGggLyAyLCBoID0gYy50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSB0aGlzLm5vZGVzLndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gdGhpcy5vZmZzZXRUb3A7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcInRvcFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZUxlZnQoYSwgbCkge1xuICAgICAgICAgIGNvbnN0IGMgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB1ID0gYy5sZWZ0IC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoIC0gdGhpcy5vZmZzZXRMZWZ0IC0gbC5tYXJnaW5MZWZ0LCBoID0gYy50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgKyBhLmNsaWVudEhlaWdodCAvIDIgLSB0aGlzLm5vZGVzLndyYXBwZXIub2Zmc2V0SGVpZ2h0IC8gMjtcbiAgICAgICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KFwibGVmdFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZVJpZ2h0KGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBjID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGMucmlnaHQgKyB0aGlzLm9mZnNldFJpZ2h0ICsgbC5tYXJnaW5SaWdodCwgaCA9IGMudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgYS5jbGllbnRIZWlnaHQgLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldEhlaWdodCAvIDI7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcInJpZ2h0XCIsIHUsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5UGxhY2VtZW50KGEsIGwsIGMpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5wbGFjZW1lbnRbYV0pLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUubGVmdCA9IGwgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBjICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIG1ha2UoYSwgbCA9IG51bGwsIGMgPSB7fSkge1xuICAgICAgICAgIGNvbnN0IHUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGEpO1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkobCkgPyB1LmNsYXNzTGlzdC5hZGQoLi4ubCkgOiBsICYmIHUuY2xhc3NMaXN0LmFkZChsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGggaW4gYylcbiAgICAgICAgICAgIGMuaGFzT3duUHJvcGVydHkoaCkgJiYgKHVbaF0gPSBjW2hdKTtcbiAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmQoYSwgbCkge1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkobCkgPyBsLmZvckVhY2goKGMpID0+IGEuYXBwZW5kQ2hpbGQoYykpIDogYS5hcHBlbmRDaGlsZChsKTtcbiAgICAgICAgfVxuICAgICAgICBwcmVwZW5kKGEsIGwpIHtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGwpID8gKGwgPSBsLnJldmVyc2UoKSkuZm9yRWFjaCgoYykgPT4gYS5wcmVwZW5kKGMpKSA6IGEucHJlcGVuZChsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHQsIG8pIHtcbiAgICAgIHQuZXhwb3J0cyA9IGAuY3R7ei1pbmRleDo5OTk7b3BhY2l0eTowOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtwb2ludGVyLWV2ZW50czpub25lOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDUwbXMgZWFzZS1pbiwtd2Via2l0LXRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO3RyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgNTBtcyBlYXNlLWluLHRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO3RyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sdHJhbnNmb3JtIDcwbXMgY3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSksLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt3aWxsLWNoYW5nZTpvcGFjaXR5LHRvcCxsZWZ0Oy13ZWJraXQtYm94LXNoYWRvdzowIDhweCAxMnB4IDAgcmdiYSgyOSwzMiw0MywuMTcpLDAgNHB4IDVweCAtM3B4IHJnYmEoNSw2LDEyLC40OSk7Ym94LXNoYWRvdzowIDhweCAxMnB4IDAgcmdiYSgyOSwzMiw0MywuMTcpLDAgNHB4IDVweCAtM3B4IHJnYmEoNSw2LDEyLC40OSk7Ym9yZGVyLXJhZGl1czo5cHh9LmN0LC5jdDpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowfS5jdDpiZWZvcmV7Y29udGVudDpcIlwiO2JvdHRvbTowO3JpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjojMWQyMDJiO3otaW5kZXg6LTE7Ym9yZGVyLXJhZGl1czo0cHh9QHN1cHBvcnRzKC13ZWJraXQtbWFzay1ib3gtaW1hZ2U6dXJsKFwiXCIpKXsuY3Q6YmVmb3Jle2JvcmRlci1yYWRpdXM6MDstd2Via2l0LW1hc2stYm94LWltYWdlOnVybCgnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCI+PHBhdGggZD1cIk0xMC43MSAwaDIuNThjMy4wMiAwIDQuNjQuNDIgNi4xIDEuMmE4LjE4IDguMTggMCAwMTMuNCAzLjRDMjMuNiA2LjA3IDI0IDcuNyAyNCAxMC43MXYyLjU4YzAgMy4wMi0uNDIgNC42NC0xLjIgNi4xYTguMTggOC4xOCAwIDAxLTMuNCAzLjRjLTEuNDcuOC0zLjEgMS4yMS02LjExIDEuMjFIMTAuN2MtMy4wMiAwLTQuNjQtLjQyLTYuMS0xLjJhOC4xOCA4LjE4IDAgMDEtMy40LTMuNEMuNCAxNy45MyAwIDE2LjMgMCAxMy4yOVYxMC43YzAtMy4wMi40Mi00LjY0IDEuMi02LjFhOC4xOCA4LjE4IDAgMDEzLjQtMy40QzYuMDcuNCA3LjcgMCAxMC43MSAwelwiLz48L3N2Zz4nKSA0OCUgNDElIDM3LjklIDUzLjMlfX1AbWVkaWEgKC0tbW9iaWxlKXsuY3R7ZGlzcGxheTpub25lfX0uY3RfX2NvbnRlbnR7cGFkZGluZzo2cHggMTBweDtjb2xvcjojY2RkMWUwO2ZvbnQtc2l6ZToxMnB4O3RleHQtYWxpZ246Y2VudGVyO2xldHRlci1zcGFjaW5nOi4wMmVtO2xpbmUtaGVpZ2h0OjFlbX0uY3Q6YWZ0ZXJ7Y29udGVudDpcIlwiO3dpZHRoOjhweDtoZWlnaHQ6OHB4O3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6IzFkMjAyYjt6LWluZGV4Oi0xfS5jdC0tYm90dG9tey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg1cHgpfS5jdC0tYm90dG9tOmFmdGVye3RvcDotM3B4O2xlZnQ6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgcm90YXRlKC00NWRlZyl9LmN0LS10b3B7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNXB4KX0uY3QtLXRvcDphZnRlcnt0b3A6YXV0bztib3R0b206LTNweDtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tbGVmdHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01cHgpfS5jdC0tbGVmdDphZnRlcnt0b3A6NTAlO2xlZnQ6YXV0bztyaWdodDowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSg0MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlKDQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCg1cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDVweCl9LmN0LS1yaWdodDphZnRlcnt0b3A6NTAlO2xlZnQ6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTQxLjYlLC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tc2hvd257b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOm5vbmU7dHJhbnNmb3JtOm5vbmV9YDtcbiAgICB9XSkuZGVmYXVsdDtcbiAgfSk7XG59KShrbyk7XG5jb25zdCB2byA9IC8qIEBfX1BVUkVfXyAqLyB4ZShfZSk7XG5jbGFzcyBGZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGliID0gbmV3IHZvKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIGxpYnJhcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5saWIuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB0b29sdGlwIG9uIGVsZW1lbnQgd2l0aCBwYXNzZWQgSFRNTCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBhbnkgSFRNTCBlbGVtZW50IGluIERPTVxuICAgKiBAcGFyYW0gY29udGVudCAtIHRvb2x0aXAncyBjb250ZW50XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc2hvd2luZyBzZXR0aW5nc1xuICAgKi9cbiAgc2hvdyhlLCB0LCBvKSB7XG4gICAgdGhpcy5saWIuc2hvdyhlLCB0LCBvKTtcbiAgfVxuICAvKipcbiAgICogSGlkZXMgdG9vbHRpcFxuICAgKlxuICAgKiBAcGFyYW0gc2tpcEhpZGluZ0RlbGF5IOKAlCBwYXNzIHRydWUgdG8gaW1tZWRpYXRlbHkgaGlkZSB0aGUgdG9vbHRpcFxuICAgKi9cbiAgaGlkZShlID0gITEpIHtcbiAgICB0aGlzLmxpYi5oaWRlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBCaW5kcyAnbW91c2VlbnRlcicgYW5kICdtb3VzZWxlYXZlJyBldmVudHMgdGhhdCBzaG93cy9oaWRlcyB0aGUgVG9vbHRpcFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gYW55IEhUTUwgZWxlbWVudCBpbiBET01cbiAgICogQHBhcmFtIGNvbnRlbnQgLSB0b29sdGlwJ3MgY29udGVudFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNob3dpbmcgc2V0dGluZ3NcbiAgICovXG4gIG9uSG92ZXIoZSwgdCwgbykge1xuICAgIHRoaXMubGliLm9uSG92ZXIoZSwgdCwgbyk7XG4gIH1cbn1cbmNsYXNzIHhvIGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24gLSBNb2R1bGUgQ29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5jb25maWcgLSBFZGl0b3IncyBjb25maWdcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uZXZlbnRzRGlzcGF0Y2hlciAtIEVkaXRvcidzIGV2ZW50IGRpc3BhdGNoZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWc6IGUsXG4gICAgICBldmVudHNEaXNwYXRjaGVyOiB0XG4gICAgfSksIHRoaXMudG9vbHRpcCA9IG5ldyBGZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95IE1vZHVsZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnRvb2x0aXAuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3c6IChlLCB0LCBvKSA9PiB0aGlzLnNob3coZSwgdCwgbyksXG4gICAgICBoaWRlOiAoKSA9PiB0aGlzLmhpZGUoKSxcbiAgICAgIG9uSG92ZXI6IChlLCB0LCBvKSA9PiB0aGlzLm9uSG92ZXIoZSwgdCwgbylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2Qgc2hvdyB0b29sdGlwIG9uIGVsZW1lbnQgd2l0aCBwYXNzZWQgSFRNTCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IG9uIHdoaWNoIHRvb2x0aXAgc2hvdWxkIGJlIHNob3duXG4gICAqIEBwYXJhbSB7VG9vbHRpcENvbnRlbnR9IGNvbnRlbnQgLSB0b29sdGlwIGNvbnRlbnRcbiAgICogQHBhcmFtIHtUb29sdGlwT3B0aW9uc30gb3B0aW9ucyAtIHRvb2x0aXAgb3B0aW9uc1xuICAgKi9cbiAgc2hvdyhlLCB0LCBvKSB7XG4gICAgdGhpcy50b29sdGlwLnNob3coZSwgdCwgbyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCBoaWRlcyB0b29sdGlwIG9uIEhUTUwgcGFnZVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRvb2x0aXAuaGlkZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvcmF0b3IgZm9yIHNob3dpbmcgVG9vbHRpcCBieSBtb3VzZWVudGVyL21vdXNlbGVhdmVcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgb24gd2hpY2ggdG9vbHRpcCBzaG91bGQgYmUgc2hvd25cbiAgICogQHBhcmFtIHtUb29sdGlwQ29udGVudH0gY29udGVudCAtIHRvb2x0aXAgY29udGVudFxuICAgKiBAcGFyYW0ge1Rvb2x0aXBPcHRpb25zfSBvcHRpb25zIC0gdG9vbHRpcCBvcHRpb25zXG4gICAqL1xuICBvbkhvdmVyKGUsIHQsIG8pIHtcbiAgICB0aGlzLnRvb2x0aXAub25Ib3ZlcihlLCB0LCBvKTtcbiAgfVxufVxuY2xhc3Mgd28gZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzIC8gZ2V0dGVyc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGVzOiB0aGlzLmVkaXRvck5vZGVzXG4gICAgICAvKipcbiAgICAgICAqIFRoZXJlIGNhbiBiZSBhZGRlZCBzb21lIFVJIG1ldGhvZHMsIGxpa2UgdG9nZ2xlVGhpbk1vZGUoKSBldGNcbiAgICAgICAqL1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydGVkIGNsYXNzZXNcbiAgICovXG4gIGdldCBlZGl0b3JOb2RlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUb3AtbGV2ZWwgZWRpdG9yIGluc3RhbmNlIHdyYXBwZXJcbiAgICAgICAqL1xuICAgICAgd3JhcHBlcjogdGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlcixcbiAgICAgIC8qKlxuICAgICAgICogRWxlbWVudCB0aGF0IGhvbGRzIGFsbCB0aGUgQmxvY2tzXG4gICAgICAgKi9cbiAgICAgIHJlZGFjdG9yOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvclxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHV0KHMsIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocykuZm9yRWFjaCgoW28sIGldKSA9PiB7XG4gICAgaWYgKGooaSkpIHtcbiAgICAgIGNvbnN0IG4gPSBlID8gYCR7ZX0uJHtvfWAgOiBvO1xuICAgICAgT2JqZWN0LnZhbHVlcyhpKS5ldmVyeSgoYSkgPT4gSihhKSkgPyB0W29dID0gbiA6IHRbb10gPSB1dChpLCBuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdFtvXSA9IGk7XG4gIH0pLCB0O1xufVxuY29uc3QgWCA9IHV0KHJ0KTtcbmZ1bmN0aW9uIHlvKHMsIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMocykuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IGkgPSBlW29dO1xuICAgIGkgIT09IHZvaWQgMCA/IHRbaV0gPSBzW29dIDogdFtvXSA9IHNbb107XG4gIH0pLCB0O1xufVxuY29uc3QgRW8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkgMTJMOSA3LjFDOSA3LjA0NDc3IDkuMDQ0NzcgNyA5LjEgN0gxMC40QzExLjUgNyAxNCA3LjEgMTQgOS41QzE0IDkuNSAxNCAxMiAxMSAxMk05IDEyVjE2LjhDOSAxNi45MTA1IDkuMDg5NTQgMTcgOS4yIDE3SDEyLjVDMTQgMTcgMTUgMTYgMTUgMTQuNUMxNSAxMS43MDQ2IDExIDEyIDExIDEyTTkgMTJIMTFcIi8+PC9zdmc+JywgcHQgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcgMTBMMTEuODU4NiAxNC44NTg2QzExLjkzNjcgMTQuOTM2NyAxMi4wNjMzIDE0LjkzNjcgMTIuMTQxNCAxNC44NTg2TDE3IDEwXCIvPjwvc3ZnPicsIEJvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDE1TDExLjg1ODYgMTAuMTQxNEMxMS45MzY3IDEwLjA2MzMgMTIuMDYzMyAxMC4wNjMzIDEyLjE0MTQgMTAuMTQxNEwxNyAxNVwiLz48L3N2Zz4nLCBDbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA4TDEyIDEyTTEyIDEyTDE2IDE2TTEyIDEyTDE2IDhNMTIgMTJMOCAxNlwiLz48L3N2Zz4nLCBUbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjRcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjwvc3ZnPicsIFNvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMy4zNCAxMEMxMi40MjIzIDEyLjczMzcgMTEgMTcgMTEgMTdcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE0LjIxIDdIMTQuMlwiLz48L3N2Zz4nLCBxZSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNy42OTk5OCAxMi42TDcuNjc4OTYgMTIuNjJDNi41Mzk5MyAxMy43MDQ4IDYuNTIwMTIgMTUuNTE1NSA3LjYzNTE2IDE2LjYyNVYxNi42MjVDOC43MjI5MyAxNy43MDczIDEwLjQ3OTkgMTcuNzEwMiAxMS41NzEyIDE2LjYzMTRMMTMuMDI2MyAxNS4xOTNDMTQuMDcwMyAxNC4xNjA5IDE0LjIxNDEgMTIuNTI1IDEzLjM2NjIgMTEuMzI2NkwxMy4yMiAxMS4xMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYuMjIgMTEuMTJMMTYuMzU2NCAxMC45ODA1QzE3LjI4OTUgMTAuMDI2NSAxNy4zNDc4IDguNTIwNyAxNi40OTE0IDcuNDk3MzNWNy40OTczM0MxNS41NjkxIDYuMzk1MDkgMTMuOTI2OSA2LjI1MTQzIDEyLjgyNzEgNy4xNzY3NUwxMS4zOTAxIDguMzg1ODhDMTAuMDkzNSA5LjQ3Njc0IDkuOTU3MDYgMTEuNDI0MSAxMS4wODg4IDEyLjY4NTJMMTEuMTIgMTIuNzJcIi8+PC9zdmc+JywgSW8gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNOS40MDk5OSA3LjI5OTk5SDkuNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMi42XCIgZD1cIk0xNC42IDcuMjk5OTlIMTQuNTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNOS4zMDk5OSAxMkg5LjNcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNMTQuNiAxMkgxNC41OVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMi42XCIgZD1cIk05LjQwOTk5IDE2LjdIOS40XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTE0LjYgMTYuN0gxNC41OVwiLz48L3N2Zz4nLCBNbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTIgN1YxMk0xMiAxN1YxMk0xNyAxMkgxMk0xMiAxMkg3XCIvPjwvc3ZnPicsIExvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxjaXJjbGUgY3g9XCIxMC41XCIgY3k9XCIxMC41XCIgcj1cIjUuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCIxNS40MTQyXCIgeDI9XCIxOVwiIHkxPVwiMTVcIiB5Mj1cIjE4LjU4NThcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48L3N2Zz4nLCBPbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTUuNzc5NSAxMS41QzE1Ljc3OTUgMTEuNSAxNi4wNTMgMTEuMTk2MiAxNi41NDk3IDEwLjY3MjJDMTcuNDQ0MiA5LjcyODU2IDE3LjQ3MDEgOC4yNDc1IDE2LjU3ODEgNy4zMDE0NVY3LjMwMTQ1QzE1LjY0ODIgNi4zMTUyMiAxNC4wODczIDYuMjkyMjcgMTMuMTI4OCA3LjI1MDczTDExLjg3OTYgOC40OTk5OVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOC4yNDUxNyAxMi4zODgzQzguMjQ1MTcgMTIuMzg4MyA3Ljk3MTcxIDEyLjY5MjIgNy40NzUwNCAxMy4yMTYxQzYuNTgwNTEgMTQuMTU5OCA2LjU1NDY3IDE1LjY0MDggNy40NDY2NiAxNi41ODY5VjE2LjU4NjlDOC4zNzY1MyAxNy41NzMxIDkuOTM3NDQgMTcuNTk2MSAxMC44OTU5IDE2LjYzNzZMMTIuMTQ1MiAxNS4zODgzXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNy43ODAyIDE1LjEwMzJMMTYuNTk3IDE0Ljk0MjJDMTYuMDEwOSAxNC44NjI0IDE1LjQ4NDEgMTUuMzA1OSAxNS40NjI3IDE1Ljg5NjlMMTUuNDE5OSAxNy4wODE4XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02LjM5MDY0IDkuMDMyMzhMNy41ODQzMiA5LjA2NjY4QzguMTc1NTEgOS4wODM2NiA4LjY1MjIgOC41ODY2NSA4LjYxMDU2IDcuOTk2NjlMOC41MjcxIDYuODEzOTdcIi8+PGxpbmUgeDE9XCIxMi4xMTQyXCIgeDI9XCIxMS43XCIgeTE9XCIxMi4yXCIgeTI9XCIxMS43ODU4XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PC9zdmc+JztcbmNsYXNzIFAge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBwb3BvdmVyIGl0ZW0gaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIHBvcG92ZXIgaXRlbSBjb25zdHJ1Y3Rpb24gcGFyYW1zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICBpY29uOiBudWxsXG4gICAgfSwgdGhpcy5jb25maXJtYXRpb25TdGF0ZSA9IG51bGwsIHRoaXMucmVtb3ZlU3BlY2lhbEZvY3VzQmVoYXZpb3IgPSAoKSA9PiB7XG4gICAgICB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShQLkNTUy5ub0ZvY3VzKTtcbiAgICB9LCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yID0gKCkgPT4ge1xuICAgICAgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoUC5DU1Mubm9Ib3Zlcik7XG4gICAgfSwgdGhpcy5vbkVycm9yQW5pbWF0aW9uRW5kID0gKCkgPT4ge1xuICAgICAgdGhpcy5ub2Rlcy5pY29uLmNsYXNzTGlzdC5yZW1vdmUoUC5DU1Mud29iYmxlQW5pbWF0aW9uKSwgdGhpcy5ub2Rlcy5pY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgdGhpcy5vbkVycm9yQW5pbWF0aW9uRW5kKTtcbiAgICB9LCB0aGlzLnBhcmFtcyA9IGUsIHRoaXMubm9kZXMucm9vdCA9IHRoaXMubWFrZShlKTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBpdGVtIGlzIGRpc2FibGVkIGFuZCBoZW5jZSBub3QgY2xpY2thYmxlXG4gICAqL1xuICBnZXQgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMuaXNEaXNhYmxlZDtcbiAgfVxuICAvKipcbiAgICogRXhwb3NlcyBwb3BvdmVyIGl0ZW0gdG9nZ2xlIHBhcmFtZXRlclxuICAgKi9cbiAgZ2V0IHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMudG9nZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBJdGVtIHRpdGxlXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnRpdGxlO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIHBvcG92ZXIgc2hvdWxkIGNsb3NlIG9uY2UgaXRlbSBpcyBhY3RpdmF0ZWRcbiAgICovXG4gIGdldCBjbG9zZU9uQWN0aXZhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLmNsb3NlT25BY3RpdmF0ZTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBjb25maXJtYXRpb24gc3RhdGUgaXMgZW5hYmxlZCBmb3IgcG9wb3ZlciBpdGVtXG4gICAqL1xuICBnZXQgaXNDb25maXJtYXRpb25TdGF0ZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgIT09IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgaXRlbSBpcyBmb2N1c2VkIGluIGtleWJvYXJkIG5hdmlnYXRpb24gcHJvY2Vzc1xuICAgKi9cbiAgZ2V0IGlzRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhQLkNTUy5mb2N1c2VkKTtcbiAgfVxuICAvKipcbiAgICogUG9wb3ZlciBpdGVtIENTUyBjbGFzc2VzXG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOiBcImNlLXBvcG92ZXItaXRlbVwiLFxuICAgICAgdGl0bGU6IFwiY2UtcG9wb3Zlci1pdGVtX190aXRsZVwiLFxuICAgICAgc2Vjb25kYXJ5VGl0bGU6IFwiY2UtcG9wb3Zlci1pdGVtX19zZWNvbmRhcnktdGl0bGVcIixcbiAgICAgIGljb246IFwiY2UtcG9wb3Zlci1pdGVtX19pY29uXCIsXG4gICAgICBhY3RpdmU6IFwiY2UtcG9wb3Zlci1pdGVtLS1hY3RpdmVcIixcbiAgICAgIGRpc2FibGVkOiBcImNlLXBvcG92ZXItaXRlbS0tZGlzYWJsZWRcIixcbiAgICAgIGZvY3VzZWQ6IFwiY2UtcG9wb3Zlci1pdGVtLS1mb2N1c2VkXCIsXG4gICAgICBoaWRkZW46IFwiY2UtcG9wb3Zlci1pdGVtLS1oaWRkZW5cIixcbiAgICAgIGNvbmZpcm1hdGlvblN0YXRlOiBcImNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uXCIsXG4gICAgICBub0hvdmVyOiBcImNlLXBvcG92ZXItaXRlbS0tbm8taG92ZXJcIixcbiAgICAgIG5vRm9jdXM6IFwiY2UtcG9wb3Zlci1pdGVtLS1uby1mb2N1c1wiLFxuICAgICAgd29iYmxlQW5pbWF0aW9uOiBcIndvYmJsZVwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwb3BvdmVyIGl0ZW0gcm9vdCBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJvb3Q7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBvbiBwb3BvdmVyIGl0ZW0gY2xpY2tcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGlmICh0aGlzLmlzQ29uZmlybWF0aW9uU3RhdGVFbmFibGVkKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlT3JFbmFibGVDb25maXJtYXRpb25Nb2RlKHRoaXMuY29uZmlybWF0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2YXRlT3JFbmFibGVDb25maXJtYXRpb25Nb2RlKHRoaXMucGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBpdGVtIGFjdGl2ZSBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaXNBY3RpdmUgLSB0cnVlIGlmIGl0ZW0gc2hvdWxkIHN0cmljdGx5IHNob3VsZCBiZWNvbWUgYWN0aXZlXG4gICAqL1xuICB0b2dnbGVBY3RpdmUoZSkge1xuICAgIHRoaXMubm9kZXMucm9vdC5jbGFzc0xpc3QudG9nZ2xlKFAuQ1NTLmFjdGl2ZSwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgaXRlbSBoaWRkZW4gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIGlzSGlkZGVuIC0gdHJ1ZSBpZiBpdGVtIHNob3VsZCBiZSBoaWRkZW5cbiAgICovXG4gIHRvZ2dsZUhpZGRlbihlKSB7XG4gICAgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC50b2dnbGUoUC5DU1MuaGlkZGVuLCBlKTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHBvcG92ZXIgaXRlbSB0byBpdHMgb3JpZ2luYWwgc3RhdGVcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaXNDb25maXJtYXRpb25TdGF0ZUVuYWJsZWQgJiYgdGhpcy5kaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgY2FsbGVkIG9uY2UgaXRlbSBiZWNvbWVzIGZvY3VzZWQgZHVyaW5nIGtleWJvYXJkIG5hdmlnYXRpb25cbiAgICovXG4gIG9uRm9jdXMoKSB7XG4gICAgdGhpcy5kaXNhYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIEhUTUwgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHBvcG92ZXIgaXRlbSBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIGl0ZW0gY29uc3RydWN0aW9uIHBhcmFtc1xuICAgKi9cbiAgbWFrZShlKSB7XG4gICAgY29uc3QgdCA9IGQubWFrZShcImRpdlwiLCBQLkNTUy5jb250YWluZXIpO1xuICAgIHJldHVybiBlLm5hbWUgJiYgKHQuZGF0YXNldC5pdGVtTmFtZSA9IGUubmFtZSksIHRoaXMubm9kZXMuaWNvbiA9IGQubWFrZShcImRpdlwiLCBQLkNTUy5pY29uLCB7XG4gICAgICBpbm5lckhUTUw6IGUuaWNvbiB8fCBUb1xuICAgIH0pLCB0LmFwcGVuZENoaWxkKHRoaXMubm9kZXMuaWNvbiksIHQuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIFAuQ1NTLnRpdGxlLCB7XG4gICAgICBpbm5lckhUTUw6IGUudGl0bGUgfHwgXCJcIlxuICAgIH0pKSwgZS5zZWNvbmRhcnlMYWJlbCAmJiB0LmFwcGVuZENoaWxkKGQubWFrZShcImRpdlwiLCBQLkNTUy5zZWNvbmRhcnlUaXRsZSwge1xuICAgICAgdGV4dENvbnRlbnQ6IGUuc2Vjb25kYXJ5TGFiZWxcbiAgICB9KSksIGUuaXNBY3RpdmUgJiYgdC5jbGFzc0xpc3QuYWRkKFAuQ1NTLmFjdGl2ZSksIGUuaXNEaXNhYmxlZCAmJiB0LmNsYXNzTGlzdC5hZGQoUC5DU1MuZGlzYWJsZWQpLCB0O1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgY29uZmlybWF0aW9uIG1vZGUgZm9yIHRoZSBpdGVtLlxuICAgKlxuICAgKiBAcGFyYW0gbmV3U3RhdGUgLSBuZXcgcG9wb3ZlciBpdGVtIHBhcmFtcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkXG4gICAqL1xuICBlbmFibGVDb25maXJtYXRpb25Nb2RlKGUpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4udGhpcy5wYXJhbXMsXG4gICAgICAuLi5lLFxuICAgICAgY29uZmlybWF0aW9uOiBlLmNvbmZpcm1hdGlvblxuICAgIH0sIG8gPSB0aGlzLm1ha2UodCk7XG4gICAgdGhpcy5ub2Rlcy5yb290LmlubmVySFRNTCA9IG8uaW5uZXJIVE1MLCB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LmFkZChQLkNTUy5jb25maXJtYXRpb25TdGF0ZSksIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgPSBlLCB0aGlzLmVuYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpdGVtIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgKi9cbiAgZGlzYWJsZUNvbmZpcm1hdGlvbk1vZGUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubWFrZSh0aGlzLnBhcmFtcyk7XG4gICAgdGhpcy5ub2Rlcy5yb290LmlubmVySFRNTCA9IGUuaW5uZXJIVE1MLCB0aGlzLm5vZGVzLnJvb3QuY2xhc3NMaXN0LnJlbW92ZShQLkNTUy5jb25maXJtYXRpb25TdGF0ZSksIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgPSBudWxsLCB0aGlzLmRpc2FibGVTcGVjaWFsSG92ZXJBbmRGb2N1c0JlaGF2aW9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgc3BlY2lhbCBmb2N1cyBhbmQgaG92ZXIgYmVoYXZpb3IgZm9yIGl0ZW0gaW4gY29uZmlybWF0aW9uIHN0YXRlLlxuICAgKiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IGl0ZW0gZnJvbSBiZWluZyBoaWdobGlnaHRlZCBhcyBob3ZlcmVkL2ZvY3VzZWQganVzdCBhZnRlciBjbGljay5cbiAgICovXG4gIGVuYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKSB7XG4gICAgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5hZGQoUC5DU1Mubm9Ib3ZlciksIHRoaXMubm9kZXMucm9vdC5jbGFzc0xpc3QuYWRkKFAuQ1NTLm5vRm9jdXMpLCB0aGlzLm5vZGVzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5yZW1vdmVTcGVjaWFsSG92ZXJCZWhhdmlvciwgeyBvbmNlOiAhMCB9KTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgc3BlY2lhbCBmb2N1cyBhbmQgaG92ZXIgYmVoYXZpb3JcbiAgICovXG4gIGRpc2FibGVTcGVjaWFsSG92ZXJBbmRGb2N1c0JlaGF2aW9yKCkge1xuICAgIHRoaXMucmVtb3ZlU3BlY2lhbEZvY3VzQmVoYXZpb3IoKSwgdGhpcy5yZW1vdmVTcGVjaWFsSG92ZXJCZWhhdmlvcigpLCB0aGlzLm5vZGVzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5yZW1vdmVTcGVjaWFsSG92ZXJCZWhhdmlvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGl0ZW0ncyBvbkFjdGl2YXRlIGNhbGxiYWNrIGlmIHRoZSBpdGVtIGhhcyBubyBjb25maXJtYXRpb24gY29uZmlndXJlZFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gYWN0aXZhdGUgb3IgYnJpbmcgdG8gY29uZmlybWF0aW9uIG1vZGVcbiAgICovXG4gIGFjdGl2YXRlT3JFbmFibGVDb25maXJtYXRpb25Nb2RlKGUpIHtcbiAgICBpZiAoZS5jb25maXJtYXRpb24gPT09IHZvaWQgMClcbiAgICAgIHRyeSB7XG4gICAgICAgIGUub25BY3RpdmF0ZShlKSwgdGhpcy5kaXNhYmxlQ29uZmlybWF0aW9uTW9kZSgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZUVycm9yKCk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgdGhpcy5lbmFibGVDb25maXJtYXRpb25Nb2RlKGUuY29uZmlybWF0aW9uKTtcbiAgfVxuICAvKipcbiAgICogQW5pbWF0ZXMgaXRlbSB3aGljaCBzeW1ib2xpemVzIHRoYXQgZXJyb3Igb2NjdXJlZCB3aGlsZSBleGVjdXRpbmcgJ29uQWN0aXZhdGUoKScgY2FsbGJhY2tcbiAgICovXG4gIGFuaW1hdGVFcnJvcigpIHtcbiAgICB0aGlzLm5vZGVzLmljb24uY2xhc3NMaXN0LmNvbnRhaW5zKFAuQ1NTLndvYmJsZUFuaW1hdGlvbikgfHwgKHRoaXMubm9kZXMuaWNvbi5jbGFzc0xpc3QuYWRkKFAuQ1NTLndvYmJsZUFuaW1hdGlvbiksIHRoaXMubm9kZXMuaWNvbi5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIHRoaXMub25FcnJvckFuaW1hdGlvbkVuZCkpO1xuICB9XG59XG5jb25zdCBjZSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gbm9kZUxpc3Qg4oCUIHRoZSBsaXN0IG9mIGl0ZXJhYmxlIEhUTUwtaXRlbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvY3VzZWRDc3NDbGFzcyAtIHVzZXItcHJvdmlkZWQgQ1NTLWNsYXNzIHRoYXQgd2lsbCBiZSBzZXQgaW4gZmxpcHBpbmcgcHJvY2Vzc1xuICAgKi9cbiAgY29uc3RydWN0b3IocywgZSkge1xuICAgIHRoaXMuY3Vyc29yID0gLTEsIHRoaXMuaXRlbXMgPSBbXSwgdGhpcy5pdGVtcyA9IHMgfHwgW10sIHRoaXMuZm9jdXNlZENzc0NsYXNzID0gZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBGb2N1c2VkIGJ1dHRvbiBOb2RlXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBjdXJyZW50SXRlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IgPT09IC0xID8gbnVsbCA6IHRoaXMuaXRlbXNbdGhpcy5jdXJzb3JdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnNvciB0byBzcGVjaWZpZWQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIGN1cnNvclBvc2l0aW9uIC0gbmV3IGN1cnNvciBwb3NpdGlvblxuICAgKi9cbiAgc2V0Q3Vyc29yKHMpIHtcbiAgICBzIDwgdGhpcy5pdGVtcy5sZW5ndGggJiYgcyA+PSAtMSAmJiAodGhpcy5kcm9wQ3Vyc29yKCksIHRoaXMuY3Vyc29yID0gcywgdGhpcy5pdGVtc1t0aGlzLmN1cnNvcl0uY2xhc3NMaXN0LmFkZCh0aGlzLmZvY3VzZWRDc3NDbGFzcykpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGl0ZW1zLiBDYW4gYmUgdXNlZCB3aGVuIGl0ZXJhYmxlIGl0ZW1zIGNoYW5nZWQgZHluYW1pY2FsbHlcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBub2RlTGlzdCAtIG5vZGVzIHRvIGl0ZXJhdGVcbiAgICovXG4gIHNldEl0ZW1zKHMpIHtcbiAgICB0aGlzLml0ZW1zID0gcztcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJzb3IgbmV4dCB0byB0aGUgY3VycmVudFxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMubGVhZk5vZGVzQW5kUmV0dXJuSW5kZXgoY2UuZGlyZWN0aW9ucy5SSUdIVCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3Vyc29yIGJlZm9yZSBjdXJyZW50XG4gICAqL1xuICBwcmV2aW91cygpIHtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMubGVhZk5vZGVzQW5kUmV0dXJuSW5kZXgoY2UuZGlyZWN0aW9ucy5MRUZUKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJzb3IgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24gYW5kIHJlbW92ZXMgQ1NTLWNsYXNzIGZyb20gcHJldmlvdXNseSBmb2N1c2VkIGl0ZW1cbiAgICovXG4gIGRyb3BDdXJzb3IoKSB7XG4gICAgdGhpcy5jdXJzb3IgIT09IC0xICYmICh0aGlzLml0ZW1zW3RoaXMuY3Vyc29yXS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZm9jdXNlZENzc0NsYXNzKSwgdGhpcy5jdXJzb3IgPSAtMSk7XG4gIH1cbiAgLyoqXG4gICAqIExlYWZzIG5vZGVzIGluc2lkZSB0aGUgdGFyZ2V0IGxpc3QgZnJvbSBhY3RpdmUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIC0gbGVhZiBkaXJlY3Rpb24uIENhbiBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBpbmRleCBvZiBmb2N1c2VkIG5vZGVcbiAgICovXG4gIGxlYWZOb2Rlc0FuZFJldHVybkluZGV4KHMpIHtcbiAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3I7XG4gICAgbGV0IGUgPSB0aGlzLmN1cnNvcjtcbiAgICByZXR1cm4gZSA9PT0gLTEgPyBlID0gcyA9PT0gY2UuZGlyZWN0aW9ucy5SSUdIVCA/IC0xIDogMCA6IHRoaXMuaXRlbXNbZV0uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmZvY3VzZWRDc3NDbGFzcyksIHMgPT09IGNlLmRpcmVjdGlvbnMuUklHSFQgPyBlID0gKGUgKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoIDogZSA9ICh0aGlzLml0ZW1zLmxlbmd0aCArIGUgLSAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoLCBkLmNhblNldENhcmV0KHRoaXMuaXRlbXNbZV0pICYmIG9lKCgpID0+IG0uc2V0Q3Vyc29yKHRoaXMuaXRlbXNbZV0pLCA1MCkoKSwgdGhpcy5pdGVtc1tlXS5jbGFzc0xpc3QuYWRkKHRoaXMuZm9jdXNlZENzc0NsYXNzKSwgZTtcbiAgfVxufTtcbmxldCBuZSA9IGNlO1xubmUuZGlyZWN0aW9ucyA9IHtcbiAgUklHSFQ6IFwicmlnaHRcIixcbiAgTEVGVDogXCJsZWZ0XCJcbn07XG5jbGFzcyBHIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RmxpcHBlck9wdGlvbnN9IG9wdGlvbnMgLSBkaWZmZXJlbnQgY29uc3RydWN0aW5nIHNldHRpbmdzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5pdGVyYXRvciA9IG51bGwsIHRoaXMuYWN0aXZhdGVkID0gITEsIHRoaXMuZmxpcENhbGxiYWNrcyA9IFtdLCB0aGlzLm9uS2V5RG93biA9ICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0V2ZW50UmVhZHlGb3JIYW5kbGluZyh0KSlcbiAgICAgICAgc3dpdGNoIChHLnVzZWRLZXlzLmluY2x1ZGVzKHQua2V5Q29kZSkgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIEIuVEFCOlxuICAgICAgICAgICAgdGhpcy5oYW5kbGVUYWJQcmVzcyh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQi5MRUZUOlxuICAgICAgICAgIGNhc2UgQi5VUDpcbiAgICAgICAgICAgIHRoaXMuZmxpcExlZnQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQi5SSUdIVDpcbiAgICAgICAgICBjYXNlIEIuRE9XTjpcbiAgICAgICAgICAgIHRoaXMuZmxpcFJpZ2h0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEIuRU5URVI6XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVudGVyUHJlc3ModCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sIHRoaXMuaXRlcmF0b3IgPSBuZXcgbmUoZS5pdGVtcywgZS5mb2N1c2VkSXRlbUNsYXNzKSwgdGhpcy5hY3RpdmF0ZUNhbGxiYWNrID0gZS5hY3RpdmF0ZUNhbGxiYWNrLCB0aGlzLmFsbG93ZWRLZXlzID0gZS5hbGxvd2VkS2V5cyB8fCBHLnVzZWRLZXlzO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGZsaXBwZXIgaXMgY3VycmVudGx5IGFjdGl2YXRlZFxuICAgKi9cbiAgZ2V0IGlzQWN0aXZhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2YXRlZDtcbiAgfVxuICAvKipcbiAgICogQXJyYXkgb2Yga2V5cyAoY29kZXMpIHRoYXQgaXMgaGFuZGxlZCBieSBGbGlwcGVyXG4gICAqIFVzZWQgdG86XG4gICAqICAtIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIHRoaXMga2V5cywgbm90IGFsbCBrZXlkb3ducyAoQHNlZSBjb25zdHJ1Y3RvcilcbiAgICogIC0gdG8gc2tpcCBleHRlcm5hbCBiZWhhdmlvdXJzIG9ubHkgZm9yIHRoZXNlIGtleXMsIHdoZW4gZmlsbGVyIGlzIGFjdGl2YXRlZCAoQHNlZSBCbG9ja0V2ZW50c0BhcnJvd1JpZ2h0QW5kRG93bilcbiAgICovXG4gIHN0YXRpYyBnZXQgdXNlZEtleXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIEIuVEFCLFxuICAgICAgQi5MRUZULFxuICAgICAgQi5SSUdIVCxcbiAgICAgIEIuRU5URVIsXG4gICAgICBCLlVQLFxuICAgICAgQi5ET1dOXG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZlIHRhYi9hcnJvd3MgaGFuZGxpbmcgYnkgZmxpcHBlclxuICAgKlxuICAgKiBAcGFyYW0gaXRlbXMgLSBTb21lIG1vZHVsZXMgKGxpa2UsIElubGluZVRvb2xiYXIsIEJsb2NrU2V0dGluZ3MpIG1pZ2h0IHJlZnJlc2ggYnV0dG9ucyBkeW5hbWljYWxseVxuICAgKiBAcGFyYW0gY3Vyc29yUG9zaXRpb24gLSBpbmRleCBvZiB0aGUgaXRlbSB0aGF0IHNob3VsZCBiZSBmb2N1c2VkIG9uY2UgZmxpcHBlciBpcyBhY3RpdmF0ZWRcbiAgICovXG4gIGFjdGl2YXRlKGUsIHQpIHtcbiAgICB0aGlzLmFjdGl2YXRlZCA9ICEwLCBlICYmIHRoaXMuaXRlcmF0b3Iuc2V0SXRlbXMoZSksIHQgIT09IHZvaWQgMCAmJiB0aGlzLml0ZXJhdG9yLnNldEN1cnNvcih0KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleURvd24sICEwKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSB0YWIvYXJyb3dzIGhhbmRsaW5nIGJ5IGZsaXBwZXJcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hY3RpdmF0ZWQgPSAhMSwgdGhpcy5kcm9wQ3Vyc29yKCksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlEb3duKTtcbiAgfVxuICAvKipcbiAgICogRm9jdXMgZmlyc3QgaXRlbVxuICAgKi9cbiAgZm9jdXNGaXJzdCgpIHtcbiAgICB0aGlzLmRyb3BDdXJzb3IoKSwgdGhpcy5mbGlwUmlnaHQoKTtcbiAgfVxuICAvKipcbiAgICogRm9jdXNlcyBwcmV2aW91cyBmbGlwcGVyIGl0ZXJhdG9yIGl0ZW1cbiAgICovXG4gIGZsaXBMZWZ0KCkge1xuICAgIHRoaXMuaXRlcmF0b3IucHJldmlvdXMoKSwgdGhpcy5mbGlwQ2FsbGJhY2soKTtcbiAgfVxuICAvKipcbiAgICogRm9jdXNlcyBuZXh0IGZsaXBwZXIgaXRlcmF0b3IgaXRlbVxuICAgKi9cbiAgZmxpcFJpZ2h0KCkge1xuICAgIHRoaXMuaXRlcmF0b3IubmV4dCgpLCB0aGlzLmZsaXBDYWxsYmFjaygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBzb21lIGJ1dHRvbiBpcyBmb2N1c2VkXG4gICAqL1xuICBoYXNGb2N1cygpIHtcbiAgICByZXR1cm4gISF0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcmVzIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIG9uIGVhY2ggbmF2aWdhdGlvbiBhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGNiIC0gZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKi9cbiAgb25GbGlwKGUpIHtcbiAgICB0aGlzLmZsaXBDYWxsYmFja3MucHVzaChlKTtcbiAgfVxuICAvKipcbiAgICogVW5yZWdpc3RlcmVzIGZ1bmN0aW9uIHRoYXQgaXMgZXhlY3V0ZWQgb24gZWFjaCBuYXZpZ2F0aW9uIGFjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gY2IgLSBmdW5jdGlvbiB0byBzdG9wIGV4ZWN1dGluZ1xuICAgKi9cbiAgcmVtb3ZlT25GbGlwKGUpIHtcbiAgICB0aGlzLmZsaXBDYWxsYmFja3MgPSB0aGlzLmZsaXBDYWxsYmFja3MuZmlsdGVyKCh0KSA9PiB0ICE9PSBlKTtcbiAgfVxuICAvKipcbiAgICogRHJvcHMgZmxpcHBlcidzIGl0ZXJhdG9yIGN1cnNvclxuICAgKlxuICAgKiBAc2VlIERvbUl0ZXJhdG9yI2Ryb3BDdXJzb3JcbiAgICovXG4gIGRyb3BDdXJzb3IoKSB7XG4gICAgdGhpcy5pdGVyYXRvci5kcm9wQ3Vyc29yKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgZmlyZWQgYmVmb3JlIGhhbmRsaW5nIGZsaXBwZXIga2V5Y29kZXNcbiAgICogVGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGRlZmluZXMgaWYgaXQgaXMgbmVlZCB0byBiZSBoYW5kbGVkIG9yIG5vdFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93biBrZXlib2FyZCBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRXZlbnRSZWFkeUZvckhhbmRsaW5nKGUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmF0ZWQgJiYgdGhpcy5hbGxvd2VkS2V5cy5pbmNsdWRlcyhlLmtleUNvZGUpO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIGZsaXBwZXIgaXMgYWN0aXZhdGVkIHRhYiBwcmVzcyB3aWxsIGxlYWYgdGhlIGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSB0YWIga2V5ZG93biBldmVudFxuICAgKi9cbiAgaGFuZGxlVGFiUHJlc3MoZSkge1xuICAgIHN3aXRjaCAoZS5zaGlmdEtleSA/IG5lLmRpcmVjdGlvbnMuTEVGVCA6IG5lLmRpcmVjdGlvbnMuUklHSFQpIHtcbiAgICAgIGNhc2UgbmUuZGlyZWN0aW9ucy5SSUdIVDpcbiAgICAgICAgdGhpcy5mbGlwUmlnaHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG5lLmRpcmVjdGlvbnMuTEVGVDpcbiAgICAgICAgdGhpcy5mbGlwTGVmdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVudGVyIHByZXNzIHdpbGwgY2xpY2sgY3VycmVudCBpdGVtIGlmIGZsaXBwZXIgaXMgYWN0aXZhdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBlbnRlciBrZXlkb3duIGV2ZW50XG4gICAqL1xuICBoYW5kbGVFbnRlclByZXNzKGUpIHtcbiAgICB0aGlzLmFjdGl2YXRlZCAmJiAodGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbSAmJiAoZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtLmNsaWNrKCkpLCBEKHRoaXMuYWN0aXZhdGVDYWxsYmFjaykgJiYgdGhpcy5hY3RpdmF0ZUNhbGxiYWNrKHRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW0pKTtcbiAgfVxuICAvKipcbiAgICogRmlyZWQgYWZ0ZXIgZmxpcHBpbmcgaW4gYW55IGRpcmVjdGlvblxuICAgKi9cbiAgZmxpcENhbGxiYWNrKCkge1xuICAgIHRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW0gJiYgdGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbS5zY3JvbGxJbnRvVmlld0lmTmVlZGVkKCksIHRoaXMuZmxpcENhbGxiYWNrcy5mb3JFYWNoKChlKSA9PiBlKCkpO1xuICB9XG59XG5jbGFzcyB1ZSB7XG4gIC8qKlxuICAgKiBTdHlsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cmFwcGVyOiBcImNkeC1zZWFyY2gtZmllbGRcIixcbiAgICAgIGljb246IFwiY2R4LXNlYXJjaC1maWVsZF9faWNvblwiLFxuICAgICAgaW5wdXQ6IFwiY2R4LXNlYXJjaC1maWVsZF9faW5wdXRcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gYXZhaWxhYmxlIGNvbmZpZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy5pdGVtcyAtIHNlYXJjaGFibGUgaXRlbXMgbGlzdFxuICAgKiBAcGFyYW0gb3B0aW9ucy5vblNlYXJjaCAtIHNlYXJjaCBjYWxsYmFja1xuICAgKiBAcGFyYW0gb3B0aW9ucy5wbGFjZWhvbGRlciAtIGlucHV0IHBsYWNlaG9sZGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGl0ZW1zOiBlLCBvblNlYXJjaDogdCwgcGxhY2Vob2xkZXI6IG8gfSkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IFJlKCksIHRoaXMuaXRlbXMgPSBlLCB0aGlzLm9uU2VhcmNoID0gdCwgdGhpcy5yZW5kZXIobyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VhcmNoIGZpZWxkIGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyBmb2N1cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGZvY3VzKCkge1xuICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHNlYXJjaCBxdWVyeSBhbmQgcmVzdWx0c1xuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5pbnB1dC52YWx1ZSA9IFwiXCIsIHRoaXMuc2VhcmNoUXVlcnkgPSBcIlwiLCB0aGlzLm9uU2VhcmNoKFwiXCIsIHRoaXMuZm91bmRJdGVtcyk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBtZW1vcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHNlYXJjaCBmaWVsZFxuICAgKlxuICAgKiBAcGFyYW0gcGxhY2Vob2xkZXIgLSBpbnB1dCBwbGFjZWhvbGRlclxuICAgKi9cbiAgcmVuZGVyKGUpIHtcbiAgICB0aGlzLndyYXBwZXIgPSBkLm1ha2UoXCJkaXZcIiwgdWUuQ1NTLndyYXBwZXIpO1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJkaXZcIiwgdWUuQ1NTLmljb24sIHtcbiAgICAgIGlubmVySFRNTDogTG9cbiAgICB9KTtcbiAgICB0aGlzLmlucHV0ID0gZC5tYWtlKFwiaW5wdXRcIiwgdWUuQ1NTLmlucHV0LCB7XG4gICAgICBwbGFjZWhvbGRlcjogZVxuICAgIH0pLCB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodCksIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmlucHV0KSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5pbnB1dCwgXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnNlYXJjaFF1ZXJ5ID0gdGhpcy5pbnB1dC52YWx1ZSwgdGhpcy5vblNlYXJjaCh0aGlzLnNlYXJjaFF1ZXJ5LCB0aGlzLmZvdW5kSXRlbXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgaXRlbXMgZm9yIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeVxuICAgKi9cbiAgZ2V0IGZvdW5kSXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKChlKSA9PiB0aGlzLmNoZWNrSXRlbShlKSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRhaW5zIGxvZ2ljIGZvciBjaGVja2luZyB3aGV0aGVyIHBhc3NlZCBpdGVtIGNvbmZvcm1zIHRoZSBzZWFyY2ggcXVlcnlcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHRvIGJlIGNoZWNrZWRcbiAgICovXG4gIGNoZWNrSXRlbShlKSB7XG4gICAgdmFyIGk7XG4gICAgY29uc3QgdCA9ICgoaSA9IGUudGl0bGUpID09IG51bGwgPyB2b2lkIDAgOiBpLnRvTG93ZXJDYXNlKCkpIHx8IFwiXCIsIG8gPSB0aGlzLnNlYXJjaFF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHQuaW5jbHVkZXMobyk7XG4gIH1cbn1cbmNvbnN0IGRlID0gY2xhc3Mge1xuICAvKipcbiAgICogTG9ja3MgYm9keSBlbGVtZW50IHNjcm9sbFxuICAgKi9cbiAgbG9jaygpIHtcbiAgICBHZSA/IHRoaXMubG9ja0hhcmQoKSA6IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChkZS5DU1Muc2Nyb2xsTG9ja2VkKTtcbiAgfVxuICAvKipcbiAgICogVW5sb2NrcyBib2R5IGVsZW1lbnQgc2Nyb2xsXG4gICAqL1xuICB1bmxvY2soKSB7XG4gICAgR2UgPyB0aGlzLnVubG9ja0hhcmQoKSA6IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShkZS5DU1Muc2Nyb2xsTG9ja2VkKTtcbiAgfVxuICAvKipcbiAgICogTG9ja3Mgc2Nyb2xsIGluIGEgaGFyZCB3YXkgKHZpYSBzZXR0aW5nIGZpeGVkIHBvc2l0aW9uIHRvIGJvZHkgZWxlbWVudClcbiAgICovXG4gIGxvY2tIYXJkKCkge1xuICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgIFwiLS13aW5kb3ctc2Nyb2xsLW9mZnNldFwiLFxuICAgICAgYCR7dGhpcy5zY3JvbGxQb3NpdGlvbn1weGBcbiAgICApLCBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoZGUuQ1NTLnNjcm9sbExvY2tlZEhhcmQpO1xuICB9XG4gIC8qKlxuICAgKiBVbmxvY2tzIGhhcmQgc2Nyb2xsIGxvY2tcbiAgICovXG4gIHVubG9ja0hhcmQoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGRlLkNTUy5zY3JvbGxMb2NrZWRIYXJkKSwgdGhpcy5zY3JvbGxQb3NpdGlvbiAhPT0gbnVsbCAmJiB3aW5kb3cuc2Nyb2xsVG8oMCwgdGhpcy5zY3JvbGxQb3NpdGlvbiksIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICB9XG59O1xubGV0IGZ0ID0gZGU7XG5mdC5DU1MgPSB7XG4gIHNjcm9sbExvY2tlZDogXCJjZS1zY3JvbGwtbG9ja2VkXCIsXG4gIHNjcm9sbExvY2tlZEhhcmQ6IFwiY2Utc2Nyb2xsLWxvY2tlZC0taGFyZFwiXG59O1xudmFyIF9vID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBBbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIE5vID0gKHMsIGUsIHQsIG8pID0+IHtcbiAgZm9yICh2YXIgaSA9IG8gPiAxID8gdm9pZCAwIDogbyA/IEFvKGUsIHQpIDogZSwgbiA9IHMubGVuZ3RoIC0gMSwgcjsgbiA+PSAwOyBuLS0pXG4gICAgKHIgPSBzW25dKSAmJiAoaSA9IChvID8gcihlLCB0LCBpKSA6IHIoaSkpIHx8IGkpO1xuICByZXR1cm4gbyAmJiBpICYmIF9vKGUsIHQsIGkpLCBpO1xufSwgZmUgPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5DbG9zZSA9IFwiY2xvc2VcIiwgcykpKGZlIHx8IHt9KTtcbmNvbnN0IHogPSBjbGFzcyBleHRlbmRzIHdlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBwb3BvdmVyIGNvbnN0cnVjdGlvbiBwYXJhbXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHMpIHtcbiAgICBzdXBlcigpLCB0aGlzLnNjb3BlRWxlbWVudCA9IGRvY3VtZW50LmJvZHksIHRoaXMubGlzdGVuZXJzID0gbmV3IFJlKCksIHRoaXMuc2Nyb2xsTG9ja2VyID0gbmV3IGZ0KCksIHRoaXMubm9kZXMgPSB7XG4gICAgICB3cmFwcGVyOiBudWxsLFxuICAgICAgcG9wb3ZlcjogbnVsbCxcbiAgICAgIG5vdGhpbmdGb3VuZE1lc3NhZ2U6IG51bGwsXG4gICAgICBjdXN0b21Db250ZW50OiBudWxsLFxuICAgICAgaXRlbXM6IG51bGwsXG4gICAgICBvdmVybGF5OiBudWxsXG4gICAgfSwgdGhpcy5tZXNzYWdlcyA9IHtcbiAgICAgIG5vdGhpbmdGb3VuZDogXCJOb3RoaW5nIGZvdW5kXCIsXG4gICAgICBzZWFyY2g6IFwiU2VhcmNoXCJcbiAgICB9LCB0aGlzLm9uRmxpcCA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXRlbXMuZmluZCgodCkgPT4gdC5pc0ZvY3VzZWQpLm9uRm9jdXMoKTtcbiAgICB9LCB0aGlzLml0ZW1zID0gcy5pdGVtcy5tYXAoKGUpID0+IG5ldyBQKGUpKSwgcy5zY29wZUVsZW1lbnQgIT09IHZvaWQgMCAmJiAodGhpcy5zY29wZUVsZW1lbnQgPSBzLnNjb3BlRWxlbWVudCksIHMubWVzc2FnZXMgJiYgKHRoaXMubWVzc2FnZXMgPSB7XG4gICAgICAuLi50aGlzLm1lc3NhZ2VzLFxuICAgICAgLi4ucy5tZXNzYWdlc1xuICAgIH0pLCBzLmN1c3RvbUNvbnRlbnRGbGlwcGFibGVJdGVtcyAmJiAodGhpcy5jdXN0b21Db250ZW50RmxpcHBhYmxlSXRlbXMgPSBzLmN1c3RvbUNvbnRlbnRGbGlwcGFibGVJdGVtcyksIHRoaXMubWFrZSgpLCBzLmN1c3RvbUNvbnRlbnQgJiYgdGhpcy5hZGRDdXN0b21Db250ZW50KHMuY3VzdG9tQ29udGVudCksIHMuc2VhcmNoYWJsZSAmJiB0aGlzLmFkZFNlYXJjaCgpLCB0aGlzLmluaXRpYWxpemVGbGlwcGVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIFBvcG92ZXIgQ1NTIGNsYXNzZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3BvdmVyOiBcImNlLXBvcG92ZXJcIixcbiAgICAgIHBvcG92ZXJPcGVuVG9wOiBcImNlLXBvcG92ZXItLW9wZW4tdG9wXCIsXG4gICAgICBwb3BvdmVyT3BlbmVkOiBcImNlLXBvcG92ZXItLW9wZW5lZFwiLFxuICAgICAgc2VhcmNoOiBcImNlLXBvcG92ZXJfX3NlYXJjaFwiLFxuICAgICAgbm90aGluZ0ZvdW5kTWVzc2FnZTogXCJjZS1wb3BvdmVyX19ub3RoaW5nLWZvdW5kLW1lc3NhZ2VcIixcbiAgICAgIG5vdGhpbmdGb3VuZE1lc3NhZ2VEaXNwbGF5ZWQ6IFwiY2UtcG9wb3Zlcl9fbm90aGluZy1mb3VuZC1tZXNzYWdlLS1kaXNwbGF5ZWRcIixcbiAgICAgIGN1c3RvbUNvbnRlbnQ6IFwiY2UtcG9wb3Zlcl9fY3VzdG9tLWNvbnRlbnRcIixcbiAgICAgIGN1c3RvbUNvbnRlbnRIaWRkZW46IFwiY2UtcG9wb3Zlcl9fY3VzdG9tLWNvbnRlbnQtLWhpZGRlblwiLFxuICAgICAgaXRlbXM6IFwiY2UtcG9wb3Zlcl9faXRlbXNcIixcbiAgICAgIG92ZXJsYXk6IFwiY2UtcG9wb3Zlcl9fb3ZlcmxheVwiLFxuICAgICAgb3ZlcmxheUhpZGRlbjogXCJjZS1wb3BvdmVyX19vdmVybGF5LS1oaWRkZW5cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgSFRNTCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBvcG92ZXJcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHNvbWUgaXRlbSBpbnNpZGUgcG9wb3ZlciBpcyBmb2N1c2VkXG4gICAqL1xuICBoYXNGb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5mbGlwcGVyLmhhc0ZvY3VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gcG9wb3ZlclxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLnNob3VsZE9wZW5Cb3R0b20gfHwgKHRoaXMubm9kZXMucG9wb3Zlci5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcG9wb3Zlci1oZWlnaHRcIiwgdGhpcy5oZWlnaHQgKyBcInB4XCIpLCB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LmFkZCh6LkNTUy5wb3BvdmVyT3BlblRvcCkpLCB0aGlzLm5vZGVzLm92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSh6LkNTUy5vdmVybGF5SGlkZGVuKSwgdGhpcy5ub2Rlcy5wb3BvdmVyLmNsYXNzTGlzdC5hZGQoei5DU1MucG9wb3Zlck9wZW5lZCksIHRoaXMuZmxpcHBlci5hY3RpdmF0ZSh0aGlzLmZsaXBwYWJsZUVsZW1lbnRzKSwgdGhpcy5zZWFyY2ggIT09IHZvaWQgMCAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2VhcmNoLmZvY3VzKCk7XG4gICAgfSwgMTAwKSwgZWUoKSAmJiB0aGlzLnNjcm9sbExvY2tlci5sb2NrKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyBwb3BvdmVyXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKHouQ1NTLnBvcG92ZXJPcGVuZWQpLCB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LnJlbW92ZSh6LkNTUy5wb3BvdmVyT3BlblRvcCksIHRoaXMubm9kZXMub3ZlcmxheS5jbGFzc0xpc3QuYWRkKHouQ1NTLm92ZXJsYXlIaWRkZW4pLCB0aGlzLmZsaXBwZXIuZGVhY3RpdmF0ZSgpLCB0aGlzLml0ZW1zLmZvckVhY2goKHMpID0+IHMucmVzZXQoKSksIHRoaXMuc2VhcmNoICE9PSB2b2lkIDAgJiYgdGhpcy5zZWFyY2guY2xlYXIoKSwgZWUoKSAmJiB0aGlzLnNjcm9sbExvY2tlci51bmxvY2soKSwgdGhpcy5lbWl0KFxuICAgICAgXCJjbG9zZVwiXG4gICAgICAvKiBDbG9zZSAqL1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBtZW1vcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCksIGVlKCkgJiYgdGhpcy5zY3JvbGxMb2NrZXIudW5sb2NrKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgSFRNTCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gcG9wb3ZlclxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLnBvcG92ZXIgPSBkLm1ha2UoXCJkaXZcIiwgW3ouQ1NTLnBvcG92ZXJdKSwgdGhpcy5ub2Rlcy5ub3RoaW5nRm91bmRNZXNzYWdlID0gZC5tYWtlKFwiZGl2XCIsIFt6LkNTUy5ub3RoaW5nRm91bmRNZXNzYWdlXSwge1xuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMubWVzc2FnZXMubm90aGluZ0ZvdW5kXG4gICAgfSksIHRoaXMubm9kZXMucG9wb3Zlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLm5vdGhpbmdGb3VuZE1lc3NhZ2UpLCB0aGlzLm5vZGVzLml0ZW1zID0gZC5tYWtlKFwiZGl2XCIsIFt6LkNTUy5pdGVtc10pLCB0aGlzLml0ZW1zLmZvckVhY2goKHMpID0+IHtcbiAgICAgIHRoaXMubm9kZXMuaXRlbXMuYXBwZW5kQ2hpbGQocy5nZXRFbGVtZW50KCkpO1xuICAgIH0pLCB0aGlzLm5vZGVzLnBvcG92ZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pdGVtcyksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucG9wb3ZlciwgXCJjbGlja1wiLCAocykgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZ2V0VGFyZ2V0SXRlbShzKTtcbiAgICAgIGUgIT09IHZvaWQgMCAmJiB0aGlzLmhhbmRsZUl0ZW1DbGljayhlKTtcbiAgICB9KSwgdGhpcy5ub2Rlcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIpLCB0aGlzLm5vZGVzLm92ZXJsYXkgPSBkLm1ha2UoXCJkaXZcIiwgW3ouQ1NTLm92ZXJsYXksIHouQ1NTLm92ZXJsYXlIaWRkZW5dKSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5vdmVybGF5LCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0pLCB0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5vdmVybGF5KSwgdGhpcy5ub2Rlcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMucG9wb3Zlcik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgc2VhcmNoIHRvIHRoZSBwb3BvdmVyXG4gICAqL1xuICBhZGRTZWFyY2goKSB7XG4gICAgdGhpcy5zZWFyY2ggPSBuZXcgdWUoe1xuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBwbGFjZWhvbGRlcjogdGhpcy5tZXNzYWdlcy5zZWFyY2gsXG4gICAgICBvblNlYXJjaDogKGUsIHQpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9ICF0LmluY2x1ZGVzKGkpO1xuICAgICAgICAgIGkudG9nZ2xlSGlkZGVuKG4pO1xuICAgICAgICB9KSwgdGhpcy50b2dnbGVOb3RoaW5nRm91bmRNZXNzYWdlKHQubGVuZ3RoID09PSAwKSwgdGhpcy50b2dnbGVDdXN0b21Db250ZW50KGUgIT09IFwiXCIpO1xuICAgICAgICBjb25zdCBvID0gZSA9PT0gXCJcIiA/IHRoaXMuZmxpcHBhYmxlRWxlbWVudHMgOiB0Lm1hcCgoaSkgPT4gaS5nZXRFbGVtZW50KCkpO1xuICAgICAgICB0aGlzLmZsaXBwZXIuaXNBY3RpdmF0ZWQgJiYgKHRoaXMuZmxpcHBlci5kZWFjdGl2YXRlKCksIHRoaXMuZmxpcHBlci5hY3RpdmF0ZShvKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcyA9IHRoaXMuc2VhcmNoLmdldEVsZW1lbnQoKTtcbiAgICBzLmNsYXNzTGlzdC5hZGQoei5DU1Muc2VhcmNoKSwgdGhpcy5ub2Rlcy5wb3BvdmVyLmluc2VydEJlZm9yZShzLCB0aGlzLm5vZGVzLnBvcG92ZXIuZmlyc3RDaGlsZCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgY3VzdG9tIGh0bWwgY29udGVudCB0byB0aGUgcG9wb3ZlclxuICAgKlxuICAgKiBAcGFyYW0gY29udGVudCAtIGh0bWwgY29udGVudCB0byBhcHBlbmRcbiAgICovXG4gIGFkZEN1c3RvbUNvbnRlbnQocykge1xuICAgIHRoaXMubm9kZXMuY3VzdG9tQ29udGVudCA9IHMsIHRoaXMubm9kZXMuY3VzdG9tQ29udGVudC5jbGFzc0xpc3QuYWRkKHouQ1NTLmN1c3RvbUNvbnRlbnQpLCB0aGlzLm5vZGVzLnBvcG92ZXIuaW5zZXJ0QmVmb3JlKHMsIHRoaXMubm9kZXMucG9wb3Zlci5maXJzdENoaWxkKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHBvcG92ZXIgaXRlbSB0aGF0IGlzIHRoZSB0YXJnZXQgb2YgdGhlIHNwZWNpZmllZCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBldmVudCB0byByZXRyaWV2ZSBwb3BvdmVyIGl0ZW0gZnJvbVxuICAgKi9cbiAgZ2V0VGFyZ2V0SXRlbShzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZCgoZSkgPT4gcy5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhlLmdldEVsZW1lbnQoKSkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGl0ZW0gY2xpY2tzXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBoYW5kbGUgY2xpY2sgb2ZcbiAgICovXG4gIGhhbmRsZUl0ZW1DbGljayhzKSB7XG4gICAgcy5pc0Rpc2FibGVkIHx8ICh0aGlzLml0ZW1zLmZpbHRlcigoZSkgPT4gZSAhPT0gcykuZm9yRWFjaCgoZSkgPT4gZS5yZXNldCgpKSwgcy5oYW5kbGVDbGljaygpLCB0aGlzLnRvZ2dsZUl0ZW1BY3RpdmVuZXNzSWZOZWVkZWQocyksIHMuY2xvc2VPbkFjdGl2YXRlICYmIHRoaXMuaGlkZSgpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBGbGlwcGVyIGluc3RhbmNlIHdoaWNoIGFsbG93cyB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHBvcG92ZXIgaXRlbXMgdmlhIGtleWJvYXJkXG4gICAqL1xuICBpbml0aWFsaXplRmxpcHBlcigpIHtcbiAgICB0aGlzLmZsaXBwZXIgPSBuZXcgRyh7XG4gICAgICBpdGVtczogdGhpcy5mbGlwcGFibGVFbGVtZW50cyxcbiAgICAgIGZvY3VzZWRJdGVtQ2xhc3M6IFAuQ1NTLmZvY3VzZWQsXG4gICAgICBhbGxvd2VkS2V5czogW1xuICAgICAgICBCLlRBQixcbiAgICAgICAgQi5VUCxcbiAgICAgICAgQi5ET1dOLFxuICAgICAgICBCLkVOVEVSXG4gICAgICBdXG4gICAgfSksIHRoaXMuZmxpcHBlci5vbkZsaXAodGhpcy5vbkZsaXApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgZWxlbWVudHMgYXZhaWxhYmxlIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICAgKiBDb250YWlucyBib3RoIHVzdWFsIHBvcG92ZXIgaXRlbXMgZWxlbWVudHMgYW5kIGN1c3RvbSBodG1sIGNvbnRlbnQuXG4gICAqL1xuICBnZXQgZmxpcHBhYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuaXRlbXMubWFwKCh0KSA9PiB0LmdldEVsZW1lbnQoKSk7XG4gICAgcmV0dXJuICh0aGlzLmN1c3RvbUNvbnRlbnRGbGlwcGFibGVJdGVtcyB8fCBbXSkuY29uY2F0KHMpO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgbGV0IHMgPSAwO1xuICAgIGlmICh0aGlzLm5vZGVzLnBvcG92ZXIgPT09IG51bGwpXG4gICAgICByZXR1cm4gcztcbiAgICBjb25zdCBlID0gdGhpcy5ub2Rlcy5wb3BvdmVyLmNsb25lTm9kZSghMCk7XG4gICAgcmV0dXJuIGUuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGUuc3R5bGUudG9wID0gXCItMTAwMHB4XCIsIGUuY2xhc3NMaXN0LmFkZCh6LkNTUy5wb3BvdmVyT3BlbmVkKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKSwgcyA9IGUub2Zmc2V0SGVpZ2h0LCBlLnJlbW92ZSgpLCBzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9wb3ZlciBzaG91bGQgYmUgb3BlbmVkIGJvdHRvbS5cbiAgICogSXQgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBiZWxvdyBvciBub3QgZW5vdWdoIHNwYWNlIGFib3ZlXG4gICAqL1xuICBnZXQgc2hvdWxkT3BlbkJvdHRvbSgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5ub2Rlcy5wb3BvdmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBlID0gdGhpcy5zY29wZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHQgPSB0aGlzLmhlaWdodCwgbyA9IHMudG9wICsgdCwgaSA9IHMudG9wIC0gdCwgbiA9IE1hdGgubWluKHdpbmRvdy5pbm5lckhlaWdodCwgZS5ib3R0b20pO1xuICAgIHJldHVybiBpIDwgZS50b3AgfHwgbyA8PSBuO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIG5vdGhpbmcgZm91bmQgbWVzc2FnZSB2aXNpYmlsaXR5XG4gICAqXG4gICAqIEBwYXJhbSBpc0Rpc3BsYXllZCAtIHRydWUgaWYgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgKi9cbiAgdG9nZ2xlTm90aGluZ0ZvdW5kTWVzc2FnZShzKSB7XG4gICAgdGhpcy5ub2Rlcy5ub3RoaW5nRm91bmRNZXNzYWdlLmNsYXNzTGlzdC50b2dnbGUoei5DU1Mubm90aGluZ0ZvdW5kTWVzc2FnZURpc3BsYXllZCwgcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgY3VzdG9tIGNvbnRlbnQgdmlzaWJpbGl0eVxuICAgKlxuICAgKiBAcGFyYW0gaXNEaXNwbGF5ZWQgLSB0cnVlIGlmIGN1c3RvbSBjb250ZW50IHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIHRvZ2dsZUN1c3RvbUNvbnRlbnQocykge1xuICAgIHZhciBlO1xuICAgIChlID0gdGhpcy5ub2Rlcy5jdXN0b21Db250ZW50KSA9PSBudWxsIHx8IGUuY2xhc3NMaXN0LnRvZ2dsZSh6LkNTUy5jdXN0b21Db250ZW50SGlkZGVuLCBzKTtcbiAgfVxuICAvKipcbiAgICogLSBUb2dnbGVzIGl0ZW0gYWN0aXZlIHN0YXRlLCBpZiBjbGlja2VkIHBvcG92ZXIgaXRlbSBoYXMgcHJvcGVydHkgJ3RvZ2dsZScgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIC0gUGVyZm9ybXMgcmFkaW9idXR0b24tbGlrZSBiZWhhdmlvciBpZiB0aGUgaXRlbSBoYXMgcHJvcGVydHkgJ3RvZ2dsZScgc2V0IHRvIHN0cmluZyBrZXkuXG4gICAqIChBbGwgdGhlIG90aGVyIGl0ZW1zIHdpdGggdGhlIHNhbWUga2V5IGdldCBpbmFjdGl2ZSwgYW5kIHRoZSBpdGVtIGdldHMgYWN0aXZlKVxuICAgKlxuICAgKiBAcGFyYW0gY2xpY2tlZEl0ZW0gLSBwb3BvdmVyIGl0ZW0gdGhhdCB3YXMgY2xpY2tlZFxuICAgKi9cbiAgdG9nZ2xlSXRlbUFjdGl2ZW5lc3NJZk5lZWRlZChzKSB7XG4gICAgaWYgKHMudG9nZ2xlID09PSAhMCAmJiBzLnRvZ2dsZUFjdGl2ZSgpLCB0eXBlb2Ygcy50b2dnbGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZSA9IHRoaXMuaXRlbXMuZmlsdGVyKCh0KSA9PiB0LnRvZ2dsZSA9PT0gcy50b2dnbGUpO1xuICAgICAgaWYgKGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHMudG9nZ2xlQWN0aXZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICB0LnRvZ2dsZUFjdGl2ZSh0ID09PSBzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcbmxldCBIZSA9IHo7XG5ObyhbXG4gIGFlXG5dLCBIZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDEpO1xuY2xhc3MgUm8gZXh0ZW5kcyBTIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5zZWxlY3Rpb24gPSBuZXcgbSgpLCB0aGlzLm9uUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBFdmVudHNcbiAgICpcbiAgICogQHJldHVybnMge3tvcGVuZWQ6IHN0cmluZywgY2xvc2VkOiBzdHJpbmd9fVxuICAgKi9cbiAgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiBcImJsb2NrLXNldHRpbmdzLW9wZW5lZFwiLFxuICAgICAgY2xvc2VkOiBcImJsb2NrLXNldHRpbmdzLWNsb3NlZFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQmxvY2sgU2V0dGluZ3MgQ1NTXG4gICAqL1xuICBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXR0aW5nczogXCJjZS1zZXR0aW5nc1wiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciBpbm5lciBwb3BvdmVyJ3MgZmxpcHBlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAdG9kbyByZW1vdmUgb25jZSBCbG9ja1NldHRpbmdzIGJlY29tZXMgc3RhbmRhbG9uZSBub24tbW9kdWxlIGNsYXNzXG4gICAqL1xuICBnZXQgZmxpcHBlcigpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKGUgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgPyB2b2lkIDAgOiBlLmZsaXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIFBhbmVsIHdpdGggYmxvY2sgc2V0dGluZ3Mgd2l0aCAyIHNlY3Rpb25zOlxuICAgKiAgLSBUb29sJ3MgU2V0dGluZ3NcbiAgICogIC0gRGVmYXVsdCBTZXR0aW5ncyBbTW92ZSwgUmVtb3ZlLCBldGNdXG4gICAqL1xuICBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlciA9IGQubWFrZShcImRpdlwiLCBbdGhpcy5DU1Muc2V0dGluZ3NdKTtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveXMgbW9kdWxlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsTm9kZXMoKTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBCbG9jayBTZXR0aW5ncyBwYW5lXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXRCbG9jayAtIG5lYXIgd2hpY2ggQmxvY2sgd2Ugc2hvdWxkIG9wZW4gQmxvY2tTZXR0aW5nc1xuICAgKi9cbiAgb3BlbihlID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jaykge1xuICAgIHRoaXMub3BlbmVkID0gITAsIHRoaXMuc2VsZWN0aW9uLnNhdmUoKSwgZS5zZWxlY3RlZCA9ICEwLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhckNhY2hlKCk7XG4gICAgY29uc3QgW3QsIG9dID0gZS5nZXRUdW5lcygpO1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHRoaXMuZXZlbnRzLm9wZW5lZCksIHRoaXMucG9wb3ZlciA9IG5ldyBIZSh7XG4gICAgICBzZWFyY2hhYmxlOiAhMCxcbiAgICAgIGl0ZW1zOiB0Lm1hcCgoaSkgPT4gdGhpcy5yZXNvbHZlVHVuZUFsaWFzZXMoaSkpLFxuICAgICAgY3VzdG9tQ29udGVudDogbyxcbiAgICAgIGN1c3RvbUNvbnRlbnRGbGlwcGFibGVJdGVtczogdGhpcy5nZXRDb250cm9scyhvKSxcbiAgICAgIHNjb3BlRWxlbWVudDogdGhpcy5FZGl0b3IuQVBJLm1ldGhvZHMudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICBub3RoaW5nRm91bmQ6ICQudWkoWC51aS5wb3BvdmVyLCBcIk5vdGhpbmcgZm91bmRcIiksXG4gICAgICAgIHNlYXJjaDogJC51aShYLnVpLnBvcG92ZXIsIFwiRmlsdGVyXCIpXG4gICAgICB9XG4gICAgfSksIHRoaXMucG9wb3Zlci5vbihmZS5DbG9zZSwgdGhpcy5vblBvcG92ZXJDbG9zZSksIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmQodGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKSksIHRoaXMucG9wb3Zlci5zaG93KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcm9vdCBibG9jayBzZXR0aW5ncyBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLndyYXBwZXI7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIEJsb2NrIFNldHRpbmdzIHBhbmVcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMub3BlbmVkID0gITEsIG0uaXNBdEVkaXRvciB8fCB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2F2ZWQoKSwgIXRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24uaXNDcm9zc0Jsb2NrU2VsZWN0aW9uU3RhcnRlZCAmJiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrICYmICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLnNlbGVjdGVkID0gITEpLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIuZW1pdCh0aGlzLmV2ZW50cy5jbG9zZWQpLCB0aGlzLnBvcG92ZXIgJiYgKHRoaXMucG9wb3Zlci5vZmYoZmUuQ2xvc2UsIHRoaXMub25Qb3BvdmVyQ2xvc2UpLCB0aGlzLnBvcG92ZXIuZGVzdHJveSgpLCB0aGlzLnBvcG92ZXIuZ2V0RWxlbWVudCgpLnJlbW92ZSgpLCB0aGlzLnBvcG92ZXIgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGJ1dHRvbnMgYW5kIGlucHV0cyBpbnNpZGUgc3BlY2lmaWVkIGNvbnRhaW5lclxuICAgKlxuICAgKiBAcGFyYW0gY29udGFpbmVyIC0gY29udGFpbmVyIHRvIHF1ZXJ5IGNvbnRyb2xzIGluc2lkZSBvZlxuICAgKi9cbiAgZ2V0Q29udHJvbHMoZSkge1xuICAgIGNvbnN0IHsgU3R5bGVzQVBJOiB0IH0gPSB0aGlzLkVkaXRvciwgbyA9IGUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgIGAuJHt0LmNsYXNzZXMuc2V0dGluZ3NCdXR0b259LCAke2QuYWxsSW5wdXRzU2VsZWN0b3J9YFxuICAgICk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFsaWFzZXMgaW4gdHVuZXMgbWVudSBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gd2l0aCByZXNvbHZlZCBhbGlhc2VzXG4gICAqL1xuICByZXNvbHZlVHVuZUFsaWFzZXMoZSkge1xuICAgIGNvbnN0IHQgPSB5byhlLCB7IGxhYmVsOiBcInRpdGxlXCIgfSk7XG4gICAgcmV0dXJuIGUuY29uZmlybWF0aW9uICYmICh0LmNvbmZpcm1hdGlvbiA9IHRoaXMucmVzb2x2ZVR1bmVBbGlhc2VzKGUuY29uZmlybWF0aW9uKSksIHQ7XG4gIH1cbn1cbmNsYXNzIFkgZXh0ZW5kcyBTIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy50b29scyA9IFtdLCB0aGlzLmZsaXBwZXIgPSBudWxsLCB0aGlzLnRvZ2dsaW5nQ2FsbGJhY2sgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDU1MgZ2V0dGVyXG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udmVyc2lvblRvb2xiYXJXcmFwcGVyOiBcImNlLWNvbnZlcnNpb24tdG9vbGJhclwiLFxuICAgICAgY29udmVyc2lvblRvb2xiYXJTaG93ZWQ6IFwiY2UtY29udmVyc2lvbi10b29sYmFyLS1zaG93ZWRcIixcbiAgICAgIGNvbnZlcnNpb25Ub29sYmFyVG9vbHM6IFwiY2UtY29udmVyc2lvbi10b29sYmFyX190b29sc1wiLFxuICAgICAgY29udmVyc2lvblRvb2xiYXJMYWJlbDogXCJjZS1jb252ZXJzaW9uLXRvb2xiYXJfX2xhYmVsXCIsXG4gICAgICBjb252ZXJzaW9uVG9vbDogXCJjZS1jb252ZXJzaW9uLXRvb2xcIixcbiAgICAgIGNvbnZlcnNpb25Ub29sSGlkZGVuOiBcImNlLWNvbnZlcnNpb24tdG9vbC0taGlkZGVuXCIsXG4gICAgICBjb252ZXJzaW9uVG9vbEljb246IFwiY2UtY29udmVyc2lvbi10b29sX19pY29uXCIsXG4gICAgICBjb252ZXJzaW9uVG9vbEZvY3VzZWQ6IFwiY2UtY29udmVyc2lvbi10b29sLS1mb2N1c2VkXCIsXG4gICAgICBjb252ZXJzaW9uVG9vbEFjdGl2ZTogXCJjZS1jb252ZXJzaW9uLXRvb2wtLWFjdGl2ZVwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIFVJIG9mIENvbnZlcnNpb24gVG9vbGJhclxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIgPSBkLm1ha2UoXCJkaXZcIiwgW1xuICAgICAgWS5DU1MuY29udmVyc2lvblRvb2xiYXJXcmFwcGVyLFxuICAgICAgLi4udGhpcy5pc1J0bCA/IFt0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yUnRsRml4XSA6IFtdXG4gICAgXSksIHRoaXMubm9kZXMudG9vbHMgPSBkLm1ha2UoXCJkaXZcIiwgWS5DU1MuY29udmVyc2lvblRvb2xiYXJUb29scyk7XG4gICAgY29uc3QgZSA9IGQubWFrZShcImRpdlwiLCBZLkNTUy5jb252ZXJzaW9uVG9vbGJhckxhYmVsLCB7XG4gICAgICB0ZXh0Q29udGVudDogJC51aShYLnVpLmlubGluZVRvb2xiYXIuY29udmVydGVyLCBcIkNvbnZlcnQgdG9cIilcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5hZGRUb29scygpLCB0aGlzLmVuYWJsZUZsaXBwZXIoKSwgZC5hcHBlbmQodGhpcy5ub2Rlcy53cmFwcGVyLCBlKSwgZC5hcHBlbmQodGhpcy5ub2Rlcy53cmFwcGVyLCB0aGlzLm5vZGVzLnRvb2xzKSwgdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyBmbGlwcGVyIGFuZCByZW1vdmVzIGFsbCBub2Rlc1xuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmZsaXBwZXIgJiYgKHRoaXMuZmxpcHBlci5kZWFjdGl2YXRlKCksIHRoaXMuZmxpcHBlciA9IG51bGwpLCB0aGlzLnJlbW92ZUFsbE5vZGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSBjb252ZXJzaW9uIGRyb3Bkb3duIHZpc2liaWxpdHlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3RvZ2dsaW5nQ2FsbGJhY2tdIOKAlCBjYWxsYmFjayB0aGF0IHdpbGwgYWNjZXB0IG9wZW5pbmcgc3RhdGVcbiAgICovXG4gIHRvZ2dsZShlKSB7XG4gICAgdGhpcy5vcGVuZWQgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKSwgRChlKSAmJiAodGhpcy50b2dnbGluZ0NhbGxiYWNrID0gZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIENvbnZlcnNpb24gVG9vbGJhclxuICAgKi9cbiAgb3BlbigpIHtcbiAgICB0aGlzLmZpbHRlclRvb2xzKCksIHRoaXMub3BlbmVkID0gITAsIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKFkuQ1NTLmNvbnZlcnNpb25Ub29sYmFyU2hvd2VkKSwgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmZsaXBwZXIuYWN0aXZhdGUodGhpcy50b29scy5tYXAoKGUpID0+IGUuYnV0dG9uKS5maWx0ZXIoKGUpID0+ICFlLmNsYXNzTGlzdC5jb250YWlucyhZLkNTUy5jb252ZXJzaW9uVG9vbEhpZGRlbikpKSwgdGhpcy5mbGlwcGVyLmZvY3VzRmlyc3QoKSwgRCh0aGlzLnRvZ2dsaW5nQ2FsbGJhY2spICYmIHRoaXMudG9nZ2xpbmdDYWxsYmFjayghMCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyBDb252ZXJzaW9uIFRvb2xiYXJcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMub3BlbmVkID0gITEsIHRoaXMuZmxpcHBlci5kZWFjdGl2YXRlKCksIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFkuQ1NTLmNvbnZlcnNpb25Ub29sYmFyU2hvd2VkKSwgRCh0aGlzLnRvZ2dsaW5nQ2FsbGJhY2spICYmIHRoaXMudG9nZ2xpbmdDYWxsYmFjayghMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBpdCBoYXMgbW9yZSB0aGFuIG9uZSB0b29sIGF2YWlsYWJsZSBmb3IgY29udmVydCBpblxuICAgKi9cbiAgaGFzVG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHMubGVuZ3RoID09PSAxID8gdGhpcy50b29sc1swXS5uYW1lICE9PSB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgOiAhMDtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgb25lIEJsb2NrIHdpdGggYW5vdGhlclxuICAgKiBGb3IgdGhhdCBUb29scyBtdXN0IHByb3ZpZGUgaW1wb3J0L2V4cG9ydCBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXBsYWNpbmdUb29sTmFtZSAtIG5hbWUgb2YgVG9vbCB3aGljaCByZXBsYWNlcyBjdXJyZW50XG4gICAqIEBwYXJhbSBibG9ja0RhdGFPdmVycmlkZXMgLSBCbG9jayBkYXRhIG92ZXJyaWRlcy4gQ291bGQgYmUgcGFzc2VkIGluIGNhc2UgaWYgTXVsdGlwbGUgVG9vbGJveCBpdGVtcyBzcGVjaWZpZWRcbiAgICovXG4gIGFzeW5jIHJlcGxhY2VXaXRoQmxvY2soZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLnRvb2wsIG4gPSAoYXdhaXQgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay5zYXZlKCkpLmRhdGEsIHIgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldChlKTtcbiAgICBsZXQgYSA9IFwiXCI7XG4gICAgY29uc3QgbCA9IG8uY29udmVyc2lvbkNvbmZpZy5leHBvcnQ7XG4gICAgaWYgKEQobCkpXG4gICAgICBhID0gbChuKTtcbiAgICBlbHNlIGlmIChKKGwpKVxuICAgICAgYSA9IG5bbF07XG4gICAgZWxzZSB7XG4gICAgICBUKFwiQ29udmVyc2lvbiDCq2V4cG9ydMK7IHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24uIFN0cmluZyBtZWFucyBrZXkgb2Ygc2F2ZWQgZGF0YSBvYmplY3QgdG8gZXhwb3J0LiBGdW5jdGlvbiBzaG91bGQgZXhwb3J0IHByb2Nlc3NlZCBzdHJpbmcgdG8gZXhwb3J0LlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYyA9IFooXG4gICAgICBhLFxuICAgICAgci5zYW5pdGl6ZUNvbmZpZ1xuICAgICk7XG4gICAgbGV0IHUgPSB7fTtcbiAgICBjb25zdCBoID0gci5jb252ZXJzaW9uQ29uZmlnLmltcG9ydDtcbiAgICBpZiAoRChoKSlcbiAgICAgIHUgPSBoKGMpO1xuICAgIGVsc2UgaWYgKEooaCkpXG4gICAgICB1W2hdID0gYztcbiAgICBlbHNlIHtcbiAgICAgIFQoXCJDb252ZXJzaW9uIMKraW1wb3J0wrsgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZyBvciBmdW5jdGlvbi4gU3RyaW5nIG1lYW5zIGtleSBvZiB0b29sIGRhdGEgdG8gaW1wb3J0LiBGdW5jdGlvbiBhY2NlcHRzIGEgaW1wb3J0ZWQgc3RyaW5nIGFuZCByZXR1cm4gY29tcG9zZWQgdG9vbCBkYXRhLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdCAmJiAodSA9IE9iamVjdC5hc3NpZ24odSwgdCkpLCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucmVwbGFjZSh7XG4gICAgICB0b29sOiBlLFxuICAgICAgZGF0YTogdVxuICAgIH0pLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpLCB0aGlzLmNsb3NlKCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgb2UoKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKTtcbiAgICB9LCAxMCkoKTtcbiAgfVxuICAvKipcbiAgICogSXRlcmF0ZXMgZXhpc3RpbmcgVG9vbHMgYW5kIGluc2VydHMgdG8gdGhlIENvbnZlcnNpb25Ub29sYmFyXG4gICAqIGlmIHRvb2xzIGhhdmUgYWJpbGl0eSB0byBpbXBvcnRcbiAgICovXG4gIGFkZFRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzO1xuICAgIEFycmF5LmZyb20oZS5lbnRyaWVzKCkpLmZvckVhY2goKFt0LCBvXSkgPT4ge1xuICAgICAgY29uc3QgaSA9IG8uY29udmVyc2lvbkNvbmZpZztcbiAgICAgICFpIHx8ICFpLmltcG9ydCB8fCBvLnRvb2xib3guZm9yRWFjaChcbiAgICAgICAgKG4pID0+IHRoaXMuYWRkVG9vbElmVmFsaWQodCwgbilcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgYSB0b29sIHRvIHRoZSBDb252ZXJzaW9uVG9vbGJhciBpZiB0aGUgdG9vbCdzIHRvb2xib3ggY29uZmlnIGlzIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gdG9vbCdzIG5hbWVcbiAgICogQHBhcmFtIHRvb2xib3hTZXR0aW5ncyAtIHRvb2wncyBzaW5nbGUgdG9vbGJveCBzZXR0aW5nXG4gICAqL1xuICBhZGRUb29sSWZWYWxpZChlLCB0KSB7XG4gICAgVih0KSB8fCAhdC5pY29uIHx8IHRoaXMuYWRkVG9vbChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogQWRkIHRvb2wgdG8gdGhlIENvbnZlcnNpb24gVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0gdG9vbE5hbWUgLSBuYW1lIG9mIFRvb2wgdG8gYWRkXG4gICAqIEBwYXJhbSB0b29sYm94SXRlbSAtIHRvb2wncyB0b29sYm94IGl0ZW0gZGF0YVxuICAgKi9cbiAgYWRkVG9vbChlLCB0KSB7XG4gICAgY29uc3QgbyA9IGQubWFrZShcImRpdlwiLCBbWS5DU1MuY29udmVyc2lvblRvb2xdKSwgaSA9IGQubWFrZShcImRpdlwiLCBbWS5DU1MuY29udmVyc2lvblRvb2xJY29uXSk7XG4gICAgby5kYXRhc2V0LnRvb2wgPSBlLCBpLmlubmVySFRNTCA9IHQuaWNvbiwgZC5hcHBlbmQobywgaSksIGQuYXBwZW5kKG8sIGQudGV4dCgkLnQoWC50b29sTmFtZXMsIHQudGl0bGUgfHwga2UoZSkpKSksIGQuYXBwZW5kKHRoaXMubm9kZXMudG9vbHMsIG8pLCB0aGlzLnRvb2xzLnB1c2goe1xuICAgICAgbmFtZTogZSxcbiAgICAgIGJ1dHRvbjogbyxcbiAgICAgIHRvb2xib3hJdGVtOiB0XG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKG8sIFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5yZXBsYWNlV2l0aEJsb2NrKGUsIHQuZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhpZGUgY3VycmVudCBUb29sIGFuZCBzaG93IG90aGVyc1xuICAgKi9cbiAgYXN5bmMgZmlsdGVyVG9vbHMoKSB7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IGUgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlciwgdCA9IGF3YWl0IGUuZ2V0QWN0aXZlVG9vbGJveEVudHJ5KCk7XG4gICAgZnVuY3Rpb24gbyhpLCBuKSB7XG4gICAgICByZXR1cm4gaS5pY29uID09PSBuLmljb24gJiYgaS50aXRsZSA9PT0gbi50aXRsZTtcbiAgICB9XG4gICAgdGhpcy50b29scy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBsZXQgbiA9ICExO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgciA9IG8odCwgaS50b29sYm94SXRlbSk7XG4gICAgICAgIG4gPSBpLmJ1dHRvbi5kYXRhc2V0LnRvb2wgPT09IGUubmFtZSAmJiByO1xuICAgICAgfVxuICAgICAgaS5idXR0b24uaGlkZGVuID0gbiwgaS5idXR0b24uY2xhc3NMaXN0LnRvZ2dsZShZLkNTUy5jb252ZXJzaW9uVG9vbEhpZGRlbiwgbik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBhcmUgRmxpcHBlciB0byBiZSBhYmxlIHRvIGxlYWYgdG9vbHMgYnkgYXJyb3dzL3RhYlxuICAgKi9cbiAgZW5hYmxlRmxpcHBlcigpIHtcbiAgICB0aGlzLmZsaXBwZXIgPSBuZXcgRyh7XG4gICAgICBmb2N1c2VkSXRlbUNsYXNzOiBZLkNTUy5jb252ZXJzaW9uVG9vbEZvY3VzZWRcbiAgICB9KTtcbiAgfVxufVxudmFyIEFlID0ge30sIERvID0ge1xuICBnZXQgZXhwb3J0cygpIHtcbiAgICByZXR1cm4gQWU7XG4gIH0sXG4gIHNldCBleHBvcnRzKHMpIHtcbiAgICBBZSA9IHM7XG4gIH1cbn07XG4vKiFcbiAqIExpYnJhcnkgZm9yIGhhbmRsaW5nIGtleWJvYXJkIHNob3J0Y3V0c1xuICogQGNvcHlyaWdodCBDb2RlWCAoaHR0cHM6Ly9jb2RleC5zbylcbiAqIEBsaWNlbnNlIE1JVFxuICogQGF1dGhvciBDb2RlWCAoaHR0cHM6Ly9jb2RleC5zbylcbiAqIEB2ZXJzaW9uIDEuMi4wXG4gKi9cbihmdW5jdGlvbihzLCBlKSB7XG4gIChmdW5jdGlvbih0LCBvKSB7XG4gICAgcy5leHBvcnRzID0gbygpO1xuICB9KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbyA9IHt9O1xuICAgICAgZnVuY3Rpb24gaShuKSB7XG4gICAgICAgIGlmIChvW25dKVxuICAgICAgICAgIHJldHVybiBvW25dLmV4cG9ydHM7XG4gICAgICAgIHZhciByID0gb1tuXSA9IHsgaTogbiwgbDogITEsIGV4cG9ydHM6IHt9IH07XG4gICAgICAgIHJldHVybiB0W25dLmNhbGwoci5leHBvcnRzLCByLCByLmV4cG9ydHMsIGkpLCByLmwgPSAhMCwgci5leHBvcnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGkubSA9IHQsIGkuYyA9IG8sIGkuZCA9IGZ1bmN0aW9uKG4sIHIsIGEpIHtcbiAgICAgICAgaS5vKG4sIHIpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCByLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGEgfSk7XG4gICAgICB9LCBpLnIgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICAgIH0sIGkudCA9IGZ1bmN0aW9uKG4sIHIpIHtcbiAgICAgICAgaWYgKDEgJiByICYmIChuID0gaShuKSksIDggJiByIHx8IDQgJiByICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgbiAmJiBuLl9fZXNNb2R1bGUpXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIHZhciBhID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmIChpLnIoYSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgdmFsdWU6IG4gfSksIDIgJiByICYmIHR5cGVvZiBuICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgZm9yICh2YXIgbCBpbiBuKVxuICAgICAgICAgICAgaS5kKGEsIGwsIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5bY107XG4gICAgICAgICAgICB9LmJpbmQobnVsbCwgbCkpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIHIgPSBuICYmIG4uX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihuLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgcik7XG4gICAgICB9LCBpLnAgPSBcIlwiLCBpKGkucyA9IDApO1xuICAgIH0oW2Z1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIGZ1bmN0aW9uIG4obCwgYykge1xuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICB2YXIgaCA9IGNbdV07XG4gICAgICAgICAgaC5lbnVtZXJhYmxlID0gaC5lbnVtZXJhYmxlIHx8ICExLCBoLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gaCAmJiAoaC53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsIGgua2V5LCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcihsLCBjLCB1KSB7XG4gICAgICAgIHJldHVybiBjICYmIG4obC5wcm90b3R5cGUsIGMpLCB1ICYmIG4obCwgdSksIGw7XG4gICAgICB9XG4gICAgICBpLnIobyk7XG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBsKGMpIHtcbiAgICAgICAgICB2YXIgdSA9IHRoaXM7XG4gICAgICAgICAgKGZ1bmN0aW9uKGgsIGYpIHtcbiAgICAgICAgICAgIGlmICghKGggaW5zdGFuY2VvZiBmKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB9KSh0aGlzLCBsKSwgdGhpcy5jb21tYW5kcyA9IHt9LCB0aGlzLmtleXMgPSB7fSwgdGhpcy5uYW1lID0gYy5uYW1lLCB0aGlzLnBhcnNlU2hvcnRjdXROYW1lKGMubmFtZSksIHRoaXMuZWxlbWVudCA9IGMub24sIHRoaXMuY2FsbGJhY2sgPSBjLmNhbGxiYWNrLCB0aGlzLmV4ZWN1dGVTaG9ydGN1dCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHUuZXhlY3V0ZShoKTtcbiAgICAgICAgICB9LCB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5leGVjdXRlU2hvcnRjdXQsICExKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcihsLCBudWxsLCBbeyBrZXk6IFwic3VwcG9ydGVkQ29tbWFuZHNcIiwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4geyBTSElGVDogW1wiU0hJRlRcIl0sIENNRDogW1wiQ01EXCIsIFwiQ09OVFJPTFwiLCBcIkNPTU1BTkRcIiwgXCJXSU5ET1dTXCIsIFwiQ1RSTFwiXSwgQUxUOiBbXCJBTFRcIiwgXCJPUFRJT05cIl0gfTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJrZXlDb2Rlc1wiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IDA6IDQ4LCAxOiA0OSwgMjogNTAsIDM6IDUxLCA0OiA1MiwgNTogNTMsIDY6IDU0LCA3OiA1NSwgODogNTYsIDk6IDU3LCBBOiA2NSwgQjogNjYsIEM6IDY3LCBEOiA2OCwgRTogNjksIEY6IDcwLCBHOiA3MSwgSDogNzIsIEk6IDczLCBKOiA3NCwgSzogNzUsIEw6IDc2LCBNOiA3NywgTjogNzgsIE86IDc5LCBQOiA4MCwgUTogODEsIFI6IDgyLCBTOiA4MywgVDogODQsIFU6IDg1LCBWOiA4NiwgVzogODcsIFg6IDg4LCBZOiA4OSwgWjogOTAsIEJBQ0tTUEFDRTogOCwgRU5URVI6IDEzLCBFU0NBUEU6IDI3LCBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIERPV046IDQwLCBJTlNFUlQ6IDQ1LCBERUxFVEU6IDQ2LCBcIi5cIjogMTkwIH07XG4gICAgICAgIH0gfV0pLCByKGwsIFt7IGtleTogXCJwYXJzZVNob3J0Y3V0TmFtZVwiLCB2YWx1ZTogZnVuY3Rpb24oYykge1xuICAgICAgICAgIGMgPSBjLnNwbGl0KFwiK1wiKTtcbiAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNbdV0gPSBjW3VdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgaCA9ICExO1xuICAgICAgICAgICAgZm9yICh2YXIgZiBpbiBsLnN1cHBvcnRlZENvbW1hbmRzKVxuICAgICAgICAgICAgICBpZiAobC5zdXBwb3J0ZWRDb21tYW5kc1tmXS5pbmNsdWRlcyhjW3VdKSkge1xuICAgICAgICAgICAgICAgIGggPSB0aGlzLmNvbW1hbmRzW2ZdID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggfHwgKHRoaXMua2V5c1tjW3VdXSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgdiBpbiBsLnN1cHBvcnRlZENvbW1hbmRzKVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kc1t2XSB8fCAodGhpcy5jb21tYW5kc1t2XSA9ICExKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJleGVjdXRlXCIsIHZhbHVlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgdmFyIHUsIGggPSB7IENNRDogYy5jdHJsS2V5IHx8IGMubWV0YUtleSwgU0hJRlQ6IGMuc2hpZnRLZXksIEFMVDogYy5hbHRLZXkgfSwgZiA9ICEwO1xuICAgICAgICAgIGZvciAodSBpbiB0aGlzLmNvbW1hbmRzKVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kc1t1XSAhPT0gaFt1XSAmJiAoZiA9ICExKTtcbiAgICAgICAgICB2YXIgdiwgcCA9ICEwO1xuICAgICAgICAgIGZvciAodiBpbiB0aGlzLmtleXMpXG4gICAgICAgICAgICBwID0gcCAmJiBjLmtleUNvZGUgPT09IGwua2V5Q29kZXNbdl07XG4gICAgICAgICAgZiAmJiBwICYmIHRoaXMuY2FsbGJhY2soYyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5leGVjdXRlU2hvcnRjdXQpO1xuICAgICAgICB9IH1dKSwgbDtcbiAgICAgIH0oKTtcbiAgICAgIG8uZGVmYXVsdCA9IGE7XG4gICAgfV0pLmRlZmF1bHQ7XG4gIH0pO1xufSkoRG8pO1xuY29uc3QgUG8gPSAvKiBAX19QVVJFX18gKi8geGUoQWUpO1xuY2xhc3MgRm8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBzaG9ydGN1dFxuICAgKlxuICAgKiBAcGFyYW0gc2hvcnRjdXQgLSBzaG9ydGN1dCBvcHRpb25zXG4gICAqL1xuICBhZGQoZSkge1xuICAgIGlmICh0aGlzLmZpbmRTaG9ydGN1dChlLm9uLCBlLm5hbWUpKVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBTaG9ydGN1dCAke2UubmFtZX0gaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciAke2Uub259LiBQbGVhc2UgcmVtb3ZlIGl0IGJlZm9yZSBhZGQgYSBuZXcgaGFuZGxlci5gXG4gICAgICApO1xuICAgIGNvbnN0IG8gPSBuZXcgUG8oe1xuICAgICAgbmFtZTogZS5uYW1lLFxuICAgICAgb246IGUub24sXG4gICAgICBjYWxsYmFjazogZS5oYW5kbGVyXG4gICAgfSksIGkgPSB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuZ2V0KGUub24pIHx8IFtdO1xuICAgIHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5zZXQoZS5vbiwgWy4uLmksIG9dKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNob3J0Y3V0XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gRWxlbWVudCBzaG9ydGN1dCBpcyBzZXQgZm9yXG4gICAqIEBwYXJhbSBuYW1lIC0gc2hvcnRjdXQgbmFtZVxuICAgKi9cbiAgcmVtb3ZlKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5maW5kU2hvcnRjdXQoZSwgdCk7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuO1xuICAgIG8ucmVtb3ZlKCk7XG4gICAgY29uc3QgaSA9IHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5nZXQoZSk7XG4gICAgdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLnNldChlLCBpLmZpbHRlcigobikgPT4gbiAhPT0gbykpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgU2hvcnRjdXQgaW5zdGFuY2UgaWYgZXhpc3RcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBFbGVtZW50IHNob3JjdXQgaXMgc2V0IGZvclxuICAgKiBAcGFyYW0gc2hvcnRjdXQgLSBzaG9ydGN1dCBuYW1lXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IC0gc2hvcnRjdXQgaW5kZXggaWYgZXhpc3RcbiAgICovXG4gIGZpbmRTaG9ydGN1dChlLCB0KSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuZ2V0KGUpIHx8IFtdKS5maW5kKCh7IG5hbWU6IGkgfSkgPT4gaSA9PT0gdCk7XG4gIH1cbn1cbmNvbnN0IHJlID0gbmV3IEZvKCk7XG52YXIgSG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHpvID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgZ3QgPSAocywgZSwgdCwgbykgPT4ge1xuICBmb3IgKHZhciBpID0gbyA+IDEgPyB2b2lkIDAgOiBvID8gem8oZSwgdCkgOiBlLCBuID0gcy5sZW5ndGggLSAxLCByOyBuID49IDA7IG4tLSlcbiAgICAociA9IHNbbl0pICYmIChpID0gKG8gPyByKGUsIHQsIGkpIDogcihpKSkgfHwgaSk7XG4gIHJldHVybiBvICYmIGkgJiYgSG8oZSwgdCwgaSksIGk7XG59LCBiZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLk9wZW5lZCA9IFwidG9vbGJveC1vcGVuZWRcIiwgcy5DbG9zZWQgPSBcInRvb2xib3gtY2xvc2VkXCIsIHMuQmxvY2tBZGRlZCA9IFwidG9vbGJveC1ibG9jay1hZGRlZFwiLCBzKSkoYmUgfHwge30pO1xuY29uc3QgYnQgPSBjbGFzcyBleHRlbmRzIHdlIHtcbiAgLyoqXG4gICAqIFRvb2xib3ggY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBhdmFpbGFibGUgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5hcGkgLSBFZGl0b3IgQVBJIG1ldGhvZHNcbiAgICogQHBhcmFtIG9wdGlvbnMudG9vbHMgLSBUb29scyBhdmFpbGFibGUgdG8gY2hlY2sgd2hldGhlciBzb21lIG9mIHRoZW0gc2hvdWxkIGJlIGRpc3BsYXllZCBhdCB0aGUgVG9vbGJveCBvciBub3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBzLCB0b29sczogZSwgaTE4bkxhYmVsczogdCB9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHRvb2xib3g6IG51bGxcbiAgICB9LCB0aGlzLm9uUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5lbWl0KFxuICAgICAgICBcInRvb2xib3gtY2xvc2VkXCJcbiAgICAgICAgLyogQ2xvc2VkICovXG4gICAgICApO1xuICAgIH0sIHRoaXMuYXBpID0gcywgdGhpcy50b29scyA9IGUsIHRoaXMuaTE4bkxhYmVscyA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVHJ1ZSBpZiBUb29sYm94IGlzIEVtcHR5IGFuZCBub3RoaW5nIHRvIHNob3dcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sc1RvQmVEaXNwbGF5ZWQubGVuZ3RoID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBDU1Mgc3R5bGVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xib3g6IFwiY2UtdG9vbGJveFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgdGhlIFRvb2xib3hcbiAgICovXG4gIG1ha2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9wb3ZlciA9IG5ldyBIZSh7XG4gICAgICBzY29wZUVsZW1lbnQ6IHRoaXMuYXBpLnVpLm5vZGVzLnJlZGFjdG9yLFxuICAgICAgc2VhcmNoYWJsZTogITAsXG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICBub3RoaW5nRm91bmQ6IHRoaXMuaTE4bkxhYmVscy5ub3RoaW5nRm91bmQsXG4gICAgICAgIHNlYXJjaDogdGhpcy5pMThuTGFiZWxzLmZpbHRlclxuICAgICAgfSxcbiAgICAgIGl0ZW1zOiB0aGlzLnRvb2xib3hJdGVtc1RvQmVEaXNwbGF5ZWRcbiAgICB9KSwgdGhpcy5wb3BvdmVyLm9uKGZlLkNsb3NlLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgdGhpcy5lbmFibGVTaG9ydGN1dHMoKSwgdGhpcy5ub2Rlcy50b29sYm94ID0gdGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKSwgdGhpcy5ub2Rlcy50b29sYm94LmNsYXNzTGlzdC5hZGQoYnQuQ1NTLnRvb2xib3gpLCB0aGlzLm5vZGVzLnRvb2xib3g7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVG9vbGJveCBoYXMgdGhlIEZsaXBwZXIgYWN0aXZhdGVkIGFuZCB0aGUgRmxpcHBlciBoYXMgc2VsZWN0ZWQgYnV0dG9uXG4gICAqL1xuICBoYXNGb2N1cygpIHtcbiAgICB2YXIgcztcbiAgICByZXR1cm4gKHMgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgPyB2b2lkIDAgOiBzLmhhc0ZvY3VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgTW9kdWxlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHZhciBzO1xuICAgIHN1cGVyLmRlc3Ryb3koKSwgdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLnRvb2xib3ggJiYgKHRoaXMubm9kZXMudG9vbGJveC5yZW1vdmUoKSwgdGhpcy5ub2Rlcy50b29sYm94ID0gbnVsbCksIHRoaXMucmVtb3ZlQWxsU2hvcnRjdXRzKCksIChzID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IHMub2ZmKGZlLkNsb3NlLCB0aGlzLm9uUG9wb3ZlckNsb3NlKTtcbiAgfVxuICAvKipcbiAgICogVG9vbGJveCBUb29sJ3MgYnV0dG9uIGNsaWNrIGhhbmRsZXJcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIC0gdG9vbCB0eXBlIHRvIGJlIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gQmxvY2sgZGF0YSBwcmVkZWZpbmVkIGJ5IHRoZSBhY3RpdmF0ZWQgVG9vbGJveCBpdGVtXG4gICAqL1xuICB0b29sQnV0dG9uQWN0aXZhdGVkKHMsIGUpIHtcbiAgICB0aGlzLmluc2VydE5ld0Jsb2NrKHMsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xib3ggd2l0aCBUb29sc1xuICAgKi9cbiAgb3BlbigpIHtcbiAgICB2YXIgcztcbiAgICB0aGlzLmlzRW1wdHkgfHwgKChzID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IHMuc2hvdygpLCB0aGlzLm9wZW5lZCA9ICEwLCB0aGlzLmVtaXQoXG4gICAgICBcInRvb2xib3gtb3BlbmVkXCJcbiAgICAgIC8qIE9wZW5lZCAqL1xuICAgICkpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBUb29sYm94XG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgcztcbiAgICAocyA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCBzLmhpZGUoKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5lbWl0KFxuICAgICAgXCJ0b29sYm94LWNsb3NlZFwiXG4gICAgICAvKiBDbG9zZWQgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBUb29sYm94XG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5vcGVuZWQgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICBnZXQgdG9vbHNUb0JlRGlzcGxheWVkKCkge1xuICAgIGNvbnN0IHMgPSBbXTtcbiAgICByZXR1cm4gdGhpcy50b29scy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLnRvb2xib3ggJiYgcy5wdXNoKGUpO1xuICAgIH0pLCBzO1xuICB9XG4gIGdldCB0b29sYm94SXRlbXNUb0JlRGlzcGxheWVkKCkge1xuICAgIGNvbnN0IHMgPSAoZSwgdCkgPT4gKHtcbiAgICAgIGljb246IGUuaWNvbixcbiAgICAgIHRpdGxlOiAkLnQoWC50b29sTmFtZXMsIGUudGl0bGUgfHwga2UodC5uYW1lKSksXG4gICAgICBuYW1lOiB0Lm5hbWUsXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudG9vbEJ1dHRvbkFjdGl2YXRlZCh0Lm5hbWUsIGUuZGF0YSk7XG4gICAgICB9LFxuICAgICAgc2Vjb25kYXJ5TGFiZWw6IHQuc2hvcnRjdXQgPyBudCh0LnNob3J0Y3V0KSA6IFwiXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy50b29sc1RvQmVEaXNwbGF5ZWQucmVkdWNlKChlLCB0KSA9PiAoQXJyYXkuaXNBcnJheSh0LnRvb2xib3gpID8gdC50b29sYm94LmZvckVhY2goKG8pID0+IHtcbiAgICAgIGUucHVzaChzKG8sIHQpKTtcbiAgICB9KSA6IHQudG9vbGJveCAhPT0gdm9pZCAwICYmIGUucHVzaChzKHQudG9vbGJveCwgdCkpLCBlKSwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBJdGVyYXRlIGFsbCB0b29scyBhbmQgZW5hYmxlIHRoZWlycyBzaG9ydGN1dHMgaWYgc3BlY2lmaWVkXG4gICAqL1xuICBlbmFibGVTaG9ydGN1dHMoKSB7XG4gICAgdGhpcy50b29sc1RvQmVEaXNwbGF5ZWQuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3QgZSA9IHMuc2hvcnRjdXQ7XG4gICAgICBlICYmIHRoaXMuZW5hYmxlU2hvcnRjdXRGb3JUb29sKHMubmFtZSwgZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBzaG9ydGN1dCBCbG9jayBUb29sIGltcGxlbWVudGVkIHNob3J0Y3V0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b29sTmFtZSAtIFRvb2wgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnRjdXQgLSBzaG9ydGN1dCBhY2NvcmRpbmcgdG8gdGhlIFNob3J0Y3V0RGF0YSBNb2R1bGUgZm9ybWF0XG4gICAqL1xuICBlbmFibGVTaG9ydGN1dEZvclRvb2wocywgZSkge1xuICAgIHJlLmFkZCh7XG4gICAgICBuYW1lOiBlLFxuICAgICAgb246IHRoaXMuYXBpLnVpLm5vZGVzLnJlZGFjdG9yLFxuICAgICAgaGFuZGxlcjogKHQpID0+IHtcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmluc2VydE5ld0Jsb2NrKHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBhZGRlZCBzaG9ydGN1dHNcbiAgICogRmlyZWQgd2hlbiB0aGUgUmVhZC1Pbmx5IG1vZGUgaXMgYWN0aXZhdGVkXG4gICAqL1xuICByZW1vdmVBbGxTaG9ydGN1dHMoKSB7XG4gICAgdGhpcy50b29sc1RvQmVEaXNwbGF5ZWQuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3QgZSA9IHMuc2hvcnRjdXQ7XG4gICAgICBlICYmIHJlLnJlbW92ZSh0aGlzLmFwaS51aS5ub2Rlcy5yZWRhY3RvciwgZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGJsb2NrXG4gICAqIENhbiBiZSBjYWxsZWQgd2hlbiBidXR0b24gY2xpY2tlZCBvbiBUb29sYm94IG9yIGJ5IFNob3J0Y3V0RGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbE5hbWUgLSBUb29sIG5hbWVcbiAgICogQHBhcmFtIGJsb2NrRGF0YU92ZXJyaWRlcyAtIHByZWRlZmluZWQgQmxvY2sgZGF0YVxuICAgKi9cbiAgYXN5bmMgaW5zZXJ0TmV3QmxvY2socywgZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgbyA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgodCk7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBvLmlzRW1wdHkgPyB0IDogdCArIDE7XG4gICAgbGV0IG47XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IGEgPSBhd2FpdCB0aGlzLmFwaS5ibG9ja3MuY29tcG9zZUJsb2NrRGF0YShzKTtcbiAgICAgIG4gPSBPYmplY3QuYXNzaWduKGEsIGUpO1xuICAgIH1cbiAgICBjb25zdCByID0gdGhpcy5hcGkuYmxvY2tzLmluc2VydChcbiAgICAgIHMsXG4gICAgICBuLFxuICAgICAgdm9pZCAwLFxuICAgICAgaSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIG8uaXNFbXB0eVxuICAgICk7XG4gICAgci5jYWxsKHEuQVBQRU5EX0NBTExCQUNLKSwgdGhpcy5hcGkuY2FyZXQuc2V0VG9CbG9jayhpKSwgdGhpcy5lbWl0KFwidG9vbGJveC1ibG9jay1hZGRlZFwiLCB7XG4gICAgICBibG9jazogclxuICAgIH0pLCB0aGlzLmFwaS50b29sYmFyLmNsb3NlKCk7XG4gIH1cbn07XG5sZXQgemUgPSBidDtcbmd0KFtcbiAgYWVcbl0sIHplLnByb3RvdHlwZSwgXCJ0b29sc1RvQmVEaXNwbGF5ZWRcIiwgMSk7XG5ndChbXG4gIGFlXG5dLCB6ZS5wcm90b3R5cGUsIFwidG9vbGJveEl0ZW1zVG9CZURpc3BsYXllZFwiLCAxKTtcbmNvbnN0IG10ID0gXCJibG9jayBob3ZlcmVkXCI7XG5jbGFzcyBqbyBleHRlbmRzIFMge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uIC0gTW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmV2ZW50c0Rpc3BhdGNoZXIgLSBFZGl0b3IncyBldmVudCBkaXNwYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLnRvb2x0aXAgPSBuZXcgRmUoKTtcbiAgfVxuICAvKipcbiAgICogQ1NTIHN0eWxlc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbGJhcjogXCJjZS10b29sYmFyXCIsXG4gICAgICBjb250ZW50OiBcImNlLXRvb2xiYXJfX2NvbnRlbnRcIixcbiAgICAgIGFjdGlvbnM6IFwiY2UtdG9vbGJhcl9fYWN0aW9uc1wiLFxuICAgICAgYWN0aW9uc09wZW5lZDogXCJjZS10b29sYmFyX19hY3Rpb25zLS1vcGVuZWRcIixcbiAgICAgIHRvb2xiYXJPcGVuZWQ6IFwiY2UtdG9vbGJhci0tb3BlbmVkXCIsXG4gICAgICBvcGVuZWRUb29sYm94SG9sZGVyTW9kaWZpZXI6IFwiY29kZXgtZWRpdG9yLS10b29sYm94LW9wZW5lZFwiLFxuICAgICAgcGx1c0J1dHRvbjogXCJjZS10b29sYmFyX19wbHVzXCIsXG4gICAgICBwbHVzQnV0dG9uU2hvcnRjdXQ6IFwiY2UtdG9vbGJhcl9fcGx1cy1zaG9ydGN1dFwiLFxuICAgICAgc2V0dGluZ3NUb2dnbGVyOiBcImNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0blwiLFxuICAgICAgc2V0dGluZ3NUb2dnbGVySGlkZGVuOiBcImNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0taGlkZGVuXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBUb29sYmFyIG9wZW5pbmcgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgb3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuQ1NTLnRvb2xiYXJPcGVuZWQpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaWMgaW50ZXJmYWNlIGZvciBhY2Nlc3NpbmcgdGhlIFRvb2xib3hcbiAgICovXG4gIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuZWQ6IHRoaXMudG9vbGJveEluc3RhbmNlLm9wZW5lZCxcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudG9vbGJveEluc3RhbmNlLmNsb3NlKCk7XG4gICAgICB9LFxuICAgICAgb3BlbjogKCkgPT4ge1xuICAgICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrID0gdGhpcy5ob3ZlcmVkQmxvY2ssIHRoaXMudG9vbGJveEluc3RhbmNlLm9wZW4oKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGU6ICgpID0+IHRoaXMudG9vbGJveEluc3RhbmNlLnRvZ2dsZSgpLFxuICAgICAgaGFzRm9jdXM6ICgpID0+IHRoaXMudG9vbGJveEluc3RhbmNlLmhhc0ZvY3VzKClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBhY3Rpb25zIGFwcGVhcmFuY2UgbWFuaXB1bGF0aW9uc1xuICAgKi9cbiAgZ2V0IGJsb2NrQWN0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGlkZTogKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVzLmFjdGlvbnMuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5hY3Rpb25zT3BlbmVkKTtcbiAgICAgIH0sXG4gICAgICBzaG93OiAoKSA9PiB7XG4gICAgICAgIHRoaXMubm9kZXMuYWN0aW9ucy5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmFjdGlvbnNPcGVuZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCBCbG9jayBUdW5lcyB0b2dnbGVyXG4gICAqL1xuICBnZXQgYmxvY2tUdW5lc1RvZ2dsZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZGU6ICgpID0+IHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1Muc2V0dGluZ3NUb2dnbGVySGlkZGVuKSxcbiAgICAgIHNob3c6ICgpID0+IHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1Muc2V0dGluZ3NUb2dnbGVySGlkZGVuKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgcmVhZC1vbmx5IG1vZGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyAodGhpcy5kZXN0cm95KCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuZGVzdHJveSgpLCB0aGlzLmRpc2FibGVNb2R1bGVCaW5kaW5ncygpKSA6ICh0aGlzLmRyYXdVSSgpLCB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIFRvb2xiYXIgdG8gdGhlIHBhc3NlZCAob3IgY3VycmVudCkgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gbW92ZSBUb29sYmFyIG5lYXIgaXRcbiAgICovXG4gIG1vdmVBbmRPcGVuKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSB7XG4gICAgaWYgKHRoaXMudG9vbGJveEluc3RhbmNlLm9wZW5lZCAmJiB0aGlzLnRvb2xib3hJbnN0YW5jZS5jbG9zZSgpLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCAmJiB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCksICFlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaG92ZXJlZEJsb2NrID0gZTtcbiAgICBjb25zdCB0ID0gZS5ob2xkZXIsIHsgaXNNb2JpbGU6IG8gfSA9IHRoaXMuRWRpdG9yLlVJLCBpID0gZS5wbHVnaW5zQ29udGVudCwgbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGkpLCByID0gcGFyc2VJbnQobi5wYWRkaW5nVG9wLCAxMCksIGEgPSB0Lm9mZnNldEhlaWdodDtcbiAgICBsZXQgbDtcbiAgICBvID8gbCA9IHQub2Zmc2V0VG9wICsgYSA6IGwgPSB0Lm9mZnNldFRvcCArIHIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBgJHtNYXRoLmZsb29yKGwpfXB4YCwgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5sZW5ndGggPT09IDEgJiYgZS5pc0VtcHR5ID8gdGhpcy5ibG9ja1R1bmVzVG9nZ2xlci5oaWRlKCkgOiB0aGlzLmJsb2NrVHVuZXNUb2dnbGVyLnNob3coKSwgdGhpcy5vcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBUb29sYmFyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQgfHwgKHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLnRvb2xiYXJPcGVuZWQpLCB0aGlzLmJsb2NrQWN0aW9ucy5oaWRlKCksIHRoaXMudG9vbGJveEluc3RhbmNlLmNsb3NlKCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gVG9vbGJhciB3aXRoIFBsdXMgQnV0dG9uIGFuZCBBY3Rpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aEJsb2NrQWN0aW9ucyAtIGJ5IGRlZmF1bHQsIFRvb2xiYXIgb3BlbnMgd2l0aCBCbG9jayBBY3Rpb25zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZsYWcgYWxsb3dzIHRvIG9wZW4gVG9vbGJhciB3aXRob3V0IEFjdGlvbnMuXG4gICAqL1xuICBvcGVuKGUgPSAhMCkge1xuICAgIG9lKCgpID0+IHtcbiAgICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2xiYXJPcGVuZWQpLCBlID8gdGhpcy5ibG9ja0FjdGlvbnMuc2hvdygpIDogdGhpcy5ibG9ja0FjdGlvbnMuaGlkZSgpO1xuICAgIH0sIDUwKSgpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBUb29sYmFyIGVsZW1lbnRzXG4gICAqL1xuICBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlciA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy50b29sYmFyKSwgW1wiY29udGVudFwiLCBcImFjdGlvbnNcIl0uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdGhpcy5ub2Rlc1t0XSA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTU1t0XSk7XG4gICAgfSksIGQuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy5jb250ZW50KSwgZC5hcHBlbmQodGhpcy5ub2Rlcy5jb250ZW50LCB0aGlzLm5vZGVzLmFjdGlvbnMpLCB0aGlzLm5vZGVzLnBsdXNCdXR0b24gPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MucGx1c0J1dHRvbiwge1xuICAgICAgaW5uZXJIVE1MOiBNb1xuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubm9kZXMucGx1c0J1dHRvbiksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucGx1c0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnRvb2x0aXAuaGlkZSghMCksIHRoaXMucGx1c0J1dHRvbkNsaWNrZWQoKTtcbiAgICB9LCAhMSk7XG4gICAgY29uc3QgZSA9IGQubWFrZShcImRpdlwiKTtcbiAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCQudWkoWC51aS50b29sYmFyLnRvb2xib3gsIFwiQWRkXCIpKSksIGUuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnBsdXNCdXR0b25TaG9ydGN1dCwge1xuICAgICAgdGV4dENvbnRlbnQ6IFwi4oelIFRhYlwiXG4gICAgfSkpLCB0aGlzLnRvb2x0aXAub25Ib3Zlcih0aGlzLm5vZGVzLnBsdXNCdXR0b24sIGUsIHtcbiAgICAgIGhpZGluZ0RlbGF5OiA0MDBcbiAgICB9KSwgdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIgPSBkLm1ha2UoXCJzcGFuXCIsIHRoaXMuQ1NTLnNldHRpbmdzVG9nZ2xlciwge1xuICAgICAgaW5uZXJIVE1MOiBJb1xuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyKSwgdGhpcy50b29sdGlwLm9uSG92ZXIoXG4gICAgICB0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlcixcbiAgICAgICQudWkoWC51aS5ibG9ja1R1bmVzLnRvZ2dsZXIsIFwiQ2xpY2sgdG8gdHVuZVwiKSxcbiAgICAgIHtcbiAgICAgICAgaGlkaW5nRGVsYXk6IDQwMFxuICAgICAgfVxuICAgICksIGQuYXBwZW5kKHRoaXMubm9kZXMuYWN0aW9ucywgdGhpcy5tYWtlVG9vbGJveCgpKSwgZC5hcHBlbmQodGhpcy5ub2Rlcy5hY3Rpb25zLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmdldEVsZW1lbnQoKSksIGQuYXBwZW5kKHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIsIHRoaXMubm9kZXMud3JhcHBlcik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIFRvb2xib3ggaW5zdGFuY2UgYW5kIHJldHVybiBpdCdzIHJlbmRlcmVkIGVsZW1lbnRcbiAgICovXG4gIG1ha2VUb29sYm94KCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xib3hJbnN0YW5jZSA9IG5ldyB6ZSh7XG4gICAgICBhcGk6IHRoaXMuRWRpdG9yLkFQSS5tZXRob2RzLFxuICAgICAgdG9vbHM6IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHMsXG4gICAgICBpMThuTGFiZWxzOiB7XG4gICAgICAgIGZpbHRlcjogJC51aShYLnVpLnBvcG92ZXIsIFwiRmlsdGVyXCIpLFxuICAgICAgICBub3RoaW5nRm91bmQ6ICQudWkoWC51aS5wb3BvdmVyLCBcIk5vdGhpbmcgZm91bmRcIilcbiAgICAgIH1cbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2Uub24oYmUuT3BlbmVkLCAoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1Mub3BlbmVkVG9vbGJveEhvbGRlck1vZGlmaWVyKTtcbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2Uub24oYmUuQ2xvc2VkLCAoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1Mub3BlbmVkVG9vbGJveEhvbGRlck1vZGlmaWVyKTtcbiAgICB9KSwgdGhpcy50b29sYm94SW5zdGFuY2Uub24oYmUuQmxvY2tBZGRlZCwgKHsgYmxvY2s6IGUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIENhcmV0OiBvIH0gPSB0aGlzLkVkaXRvciwgaSA9IHQuZ2V0QmxvY2tCeUlkKGUuaWQpO1xuICAgICAgaS5pbnB1dHMubGVuZ3RoID09PSAwICYmIChpID09PSB0Lmxhc3RCbG9jayA/ICh0Lmluc2VydEF0RW5kKCksIG8uc2V0VG9CbG9jayh0Lmxhc3RCbG9jaykpIDogby5zZXRUb0Jsb2NrKHQubmV4dEJsb2NrKSk7XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLm1ha2UoKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlciBmb3IgUGx1cyBCdXR0b25cbiAgICovXG4gIHBsdXNCdXR0b25DbGlja2VkKCkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgPSB0aGlzLmhvdmVyZWRCbG9jaywgdGhpcy50b29sYm94SW5zdGFuY2UudG9nZ2xlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZSBiaW5kaW5nc1xuICAgKi9cbiAgZW5hYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIsIFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpLCB0aGlzLnNldHRpbmdzVG9nZ2xlckNsaWNrZWQoKSwgdGhpcy50b29sYm94SW5zdGFuY2Uub3BlbmVkICYmIHRoaXMudG9vbGJveEluc3RhbmNlLmNsb3NlKCksIHRoaXMudG9vbHRpcC5oaWRlKCEwKTtcbiAgICB9LCAhMCksIGVlKCkgfHwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKG10LCAoZSkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgfHwgdGhpcy50b29sYm94SW5zdGFuY2Uub3BlbmVkIHx8IHRoaXMubW92ZUFuZE9wZW4oZS5ibG9jayk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGUgYmluZGluZ3NcbiAgICovXG4gIGRpc2FibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5jbGVhckFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGlja3Mgb24gdGhlIEJsb2NrIFNldHRpbmdzIHRvZ2dsZXJcbiAgICovXG4gIHNldHRpbmdzVG9nZ2xlckNsaWNrZWQoKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayA9IHRoaXMuaG92ZXJlZEJsb2NrLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCA/IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKSA6IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3Blbih0aGlzLmhvdmVyZWRCbG9jayk7XG4gIH1cbiAgLyoqXG4gICAqIERyYXdzIFRvb2xiYXIgVUlcbiAgICpcbiAgICogVG9vbGJhciBjb250YWlucyBCbG9ja1NldHRpbmdzIGFuZCBUb29sYm94LlxuICAgKiBUaGF0J3Mgd2h5IGF0IGZpcnN0IHdlIGRyYXcgaXRzIGNvbXBvbmVudHMgYW5kIHRoZW4gVG9vbGJhciBpdHNlbGZcbiAgICpcbiAgICogU3RlcHM6XG4gICAqICAtIE1ha2UgVG9vbGJhciBkZXBlbmRlbnQgY29tcG9uZW50cyBsaWtlIEJsb2NrU2V0dGluZ3MsIFRvb2xib3ggYW5kIHNvIG9uXG4gICAqICAtIE1ha2UgaXRzZWxmIGFuZCBhcHBlbmQgZGVwZW5kZW50IG5vZGVzIHRvIGl0c2VsZlxuICAgKlxuICAgKi9cbiAgZHJhd1VJKCkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MubWFrZSgpLCB0aGlzLm1ha2UoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgY3JlYXRlZCBhbmQgc2F2ZWQgSFRNTEVsZW1lbnRzXG4gICAqIEl0IGlzIHVzZWQgaW4gUmVhZC1Pbmx5IG1vZGVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxOb2RlcygpLCB0aGlzLnRvb2xib3hJbnN0YW5jZSAmJiB0aGlzLnRvb2xib3hJbnN0YW5jZS5kZXN0cm95KCksIHRoaXMudG9vbHRpcC5kZXN0cm95KCk7XG4gIH1cbn1cbnZhciB5ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzW3MuQmxvY2sgPSAwXSA9IFwiQmxvY2tcIiwgc1tzLklubGluZSA9IDFdID0gXCJJbmxpbmVcIiwgc1tzLlR1bmUgPSAyXSA9IFwiVHVuZVwiLCBzKSkoeWUgfHwge30pLCBtZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLlNob3J0Y3V0ID0gXCJzaG9ydGN1dFwiLCBzLlRvb2xib3ggPSBcInRvb2xib3hcIiwgcy5FbmFibGVkSW5saW5lVG9vbHMgPSBcImlubGluZVRvb2xiYXJcIiwgcy5FbmFibGVkQmxvY2tUdW5lcyA9IFwidHVuZXNcIiwgcy5Db25maWcgPSBcImNvbmZpZ1wiLCBzKSkobWUgfHwge30pLCBrdCA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLlNob3J0Y3V0ID0gXCJzaG9ydGN1dFwiLCBzLlNhbml0aXplQ29uZmlnID0gXCJzYW5pdGl6ZVwiLCBzKSkoa3QgfHwge30pLCBzZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLklzRW5hYmxlZExpbmVCcmVha3MgPSBcImVuYWJsZUxpbmVCcmVha3NcIiwgcy5Ub29sYm94ID0gXCJ0b29sYm94XCIsIHMuQ29udmVyc2lvbkNvbmZpZyA9IFwiY29udmVyc2lvbkNvbmZpZ1wiLCBzLklzUmVhZE9ubHlTdXBwb3J0ZWQgPSBcImlzUmVhZE9ubHlTdXBwb3J0ZWRcIiwgcy5QYXN0ZUNvbmZpZyA9IFwicGFzdGVDb25maWdcIiwgcykpKHNlIHx8IHt9KSwgamUgPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5Jc0lubGluZSA9IFwiaXNJbmxpbmVcIiwgcy5UaXRsZSA9IFwidGl0bGVcIiwgcykpKGplIHx8IHt9KSwgdnQgPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5Jc1R1bmUgPSBcImlzVHVuZVwiLCBzKSkodnQgfHwge30pO1xuY2xhc3MgVWUge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3JPcHRpb25zfSBvcHRpb25zIC0gQ29uc3RydWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IGUsXG4gICAgY29uc3RydWN0YWJsZTogdCxcbiAgICBjb25maWc6IG8sXG4gICAgYXBpOiBpLFxuICAgIGlzRGVmYXVsdDogbixcbiAgICBpc0ludGVybmFsOiByID0gITEsXG4gICAgZGVmYXVsdFBsYWNlaG9sZGVyOiBhXG4gIH0pIHtcbiAgICB0aGlzLmFwaSA9IGksIHRoaXMubmFtZSA9IGUsIHRoaXMuY29uc3RydWN0YWJsZSA9IHQsIHRoaXMuY29uZmlnID0gbywgdGhpcy5pc0RlZmF1bHQgPSBuLCB0aGlzLmlzSW50ZXJuYWwgPSByLCB0aGlzLmRlZmF1bHRQbGFjZWhvbGRlciA9IGE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBzZXR0aW5ncygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb25maWcuY29uZmlnIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLmlzRGVmYXVsdCAmJiAhKFwicGxhY2Vob2xkZXJcIiBpbiBlKSAmJiB0aGlzLmRlZmF1bHRQbGFjZWhvbGRlciAmJiAoZS5wbGFjZWhvbGRlciA9IHRoaXMuZGVmYXVsdFBsYWNlaG9sZGVyKSwgZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgVG9vbCdzIHJlc2V0IG1ldGhvZFxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgaWYgKEQodGhpcy5jb25zdHJ1Y3RhYmxlLnJlc2V0KSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGUucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgVG9vbCdzIHByZXBhcmUgbWV0aG9kXG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIGlmIChEKHRoaXMuY29uc3RydWN0YWJsZS5wcmVwYXJlKSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGUucHJlcGFyZSh7XG4gICAgICAgIHRvb2xOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5nc1xuICAgICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2hvcnRjdXQgZm9yIFRvb2wgKGludGVybmFsIG9yIHNwZWNpZmllZCBieSB1c2VyKVxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnN0cnVjdGFibGUuc2hvcnRjdXQ7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnNob3J0Y3V0IHx8IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCdzIHNhbml0aXplciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgc2FuaXRpemVDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZS5zYW5pdGl6ZSB8fCB7fTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2xzIGlzIGlubGluZVxuICAgKi9cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2xzIGlzIGJsb2NrXG4gICAqL1xuICBpc0Jsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBUb29scyBpcyB0dW5lXG4gICAqL1xuICBpc1R1bmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMjtcbiAgfVxufVxuY2xhc3MgVW8gZXh0ZW5kcyBTIHtcbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KSwgdGhpcy5DU1MgPSB7XG4gICAgICBpbmxpbmVUb29sYmFyOiBcImNlLWlubGluZS10b29sYmFyXCIsXG4gICAgICBpbmxpbmVUb29sYmFyU2hvd2VkOiBcImNlLWlubGluZS10b29sYmFyLS1zaG93ZWRcIixcbiAgICAgIGlubGluZVRvb2xiYXJMZWZ0T3JpZW50ZWQ6IFwiY2UtaW5saW5lLXRvb2xiYXItLWxlZnQtb3JpZW50ZWRcIixcbiAgICAgIGlubGluZVRvb2xiYXJSaWdodE9yaWVudGVkOiBcImNlLWlubGluZS10b29sYmFyLS1yaWdodC1vcmllbnRlZFwiLFxuICAgICAgaW5saW5lVG9vbGJhclNob3J0Y3V0OiBcImNlLWlubGluZS10b29sYmFyX19zaG9ydGN1dFwiLFxuICAgICAgYnV0dG9uc1dyYXBwZXI6IFwiY2UtaW5saW5lLXRvb2xiYXJfX2J1dHRvbnNcIixcbiAgICAgIGFjdGlvbnNXcmFwcGVyOiBcImNlLWlubGluZS10b29sYmFyX19hY3Rpb25zXCIsXG4gICAgICBpbmxpbmVUb29sQnV0dG9uOiBcImNlLWlubGluZS10b29sXCIsXG4gICAgICBpbnB1dEZpZWxkOiBcImNkeC1pbnB1dFwiLFxuICAgICAgZm9jdXNlZEJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbC0tZm9jdXNlZFwiLFxuICAgICAgY29udmVyc2lvblRvZ2dsZXI6IFwiY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duXCIsXG4gICAgICBjb252ZXJzaW9uVG9nZ2xlckFycm93OiBcImNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1hcnJvd1wiLFxuICAgICAgY29udmVyc2lvblRvZ2dsZXJIaWRkZW46IFwiY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLS1oaWRkZW5cIixcbiAgICAgIGNvbnZlcnNpb25Ub2dnbGVyQ29udGVudDogXCJjZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tY29udGVudFwiLFxuICAgICAgdG9nZ2xlckFuZEJ1dHRvbnNXcmFwcGVyOiBcImNlLWlubGluZS10b29sYmFyX190b2dnbGVyLWFuZC1idXR0b24td3JhcHBlclwiXG4gICAgfSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy50b29sYmFyVmVydGljYWxNYXJnaW4gPSBlZSgpID8gMjAgOiA2LCB0aGlzLmJ1dHRvbnNMaXN0ID0gbnVsbCwgdGhpcy53aWR0aCA9IDAsIHRoaXMuZmxpcHBlciA9IG51bGwsIHRoaXMudG9vbHRpcCA9IG5ldyBGZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIHJlYWQtb25seSBtb2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHlFbmFibGVkIC0gcmVhZC1vbmx5IG1vZGVcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KGUpIHtcbiAgICBlID8gKHRoaXMuZGVzdHJveSgpLCB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci5kZXN0cm95KCkpIDogdGhpcy5tYWtlKCk7XG4gIH1cbiAgLyoqXG4gICAqICBNb3ZpbmcgLyBhcHBlYXJhbmNlXG4gICAqICB+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XG4gICAqL1xuICAvKipcbiAgICogU2hvd3MgSW5saW5lIFRvb2xiYXIgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSBbbmVlZFRvQ2xvc2VdIC0gcGFzcyB0cnVlIHRvIGNsb3NlIHRvb2xiYXIgaWYgaXQgaXMgbm90IGFsbG93ZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF2b2lkIHRvIHVzZSBpdCBqdXN0IGZvciBjbG9zaW5nIElULCBiZXR0ZXIgY2FsbCAuY2xvc2UoKSBjbGVhcmx5LlxuICAgKiBAcGFyYW0gW25lZWRUb1Nob3dDb252ZXJzaW9uVG9vbGJhcl0gLSBwYXNzIGZhbHNlIHRvIG5vdCB0byBzaG93IENvbnZlcnNpb24gVG9vbGJhclxuICAgKi9cbiAgdHJ5VG9TaG93KGUgPSAhMSwgdCA9ICEwKSB7XG4gICAgaWYgKCF0aGlzLmFsbG93ZWRUb1Nob3coKSkge1xuICAgICAgZSAmJiB0aGlzLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubW92ZSgpLCB0aGlzLm9wZW4odCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBUb29sYmFyIHRvIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAqL1xuICBtb3ZlKCkge1xuICAgIGNvbnN0IGUgPSBtLnJlY3QsIHQgPSB0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvID0ge1xuICAgICAgeDogZS54IC0gdC5sZWZ0LFxuICAgICAgeTogZS55ICsgZS5oZWlnaHQgLSAvLyArIHdpbmRvdy5zY3JvbGxZXG4gICAgICB0LnRvcCArIHRoaXMudG9vbGJhclZlcnRpY2FsTWFyZ2luXG4gICAgfTtcbiAgICBlLndpZHRoICYmIChvLnggKz0gTWF0aC5mbG9vcihlLndpZHRoIC8gMikpO1xuICAgIGNvbnN0IGkgPSBvLnggLSB0aGlzLndpZHRoIC8gMiwgbiA9IG8ueCArIHRoaXMud2lkdGggLyAyO1xuICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QudG9nZ2xlKFxuICAgICAgdGhpcy5DU1MuaW5saW5lVG9vbGJhckxlZnRPcmllbnRlZCxcbiAgICAgIGkgPCB0aGlzLkVkaXRvci5VSS5jb250ZW50UmVjdC5sZWZ0XG4gICAgKSwgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUoXG4gICAgICB0aGlzLkNTUy5pbmxpbmVUb29sYmFyUmlnaHRPcmllbnRlZCxcbiAgICAgIG4gPiB0aGlzLkVkaXRvci5VSS5jb250ZW50UmVjdC5yaWdodFxuICAgICksIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gTWF0aC5mbG9vcihvLngpICsgXCJweFwiLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUudG9wID0gTWF0aC5mbG9vcihvLnkpICsgXCJweFwiO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5vcGVuZWQgJiYgKHRoaXMuRWRpdG9yLlJlYWRPbmx5LmlzRW5hYmxlZCB8fCAodGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5DU1MuaW5saW5lVG9vbGJhclNob3dlZCksIEFycmF5LmZyb20odGhpcy50b29sc0luc3RhbmNlcy5lbnRyaWVzKCkpLmZvckVhY2goKFtlLCB0XSkgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0VG9vbFNob3J0Y3V0KGUpO1xuICAgICAgbyAmJiByZS5yZW1vdmUodGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3IsIG8pLCBEKHQuY2xlYXIpICYmIHQuY2xlYXIoKTtcbiAgICB9KSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIuY2xvc2UoKSkpO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyBJbmxpbmUgVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0gW25lZWRUb1Nob3dDb252ZXJzaW9uVG9vbGJhcl0gLSBwYXNzIGZhbHNlIHRvIG5vdCB0byBzaG93IENvbnZlcnNpb24gVG9vbGJhclxuICAgKi9cbiAgb3BlbihlID0gITApIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hZGRUb29sc0ZpbHRlcmVkKCksIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmlubGluZVRvb2xiYXJTaG93ZWQpLCB0aGlzLmJ1dHRvbnNMaXN0ID0gdGhpcy5ub2Rlcy5idXR0b25zLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke3RoaXMuQ1NTLmlubGluZVRvb2xCdXR0b259YCksIHRoaXMub3BlbmVkID0gITAsIGUgJiYgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIuaGFzVG9vbHMoKSA/IHRoaXMuc2V0Q29udmVyc2lvblRvZ2dsZXJDb250ZW50KCkgOiB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyLmhpZGRlbiA9ICEwO1xuICAgIGxldCB0ID0gQXJyYXkuZnJvbSh0aGlzLmJ1dHRvbnNMaXN0KTtcbiAgICB0LnVuc2hpZnQodGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlciksIHQgPSB0LmZpbHRlcigobykgPT4gIW8uaGlkZGVuKSwgdGhpcy5mbGlwcGVyLmFjdGl2YXRlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBub2RlIGlzIGNvbnRhaW5lZCBieSBJbmxpbmUgVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUg4oCUIG5vZGUgdG8gY2hlY2tcbiAgICovXG4gIGNvbnRhaW5zTm9kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMud3JhcHBlci5jb250YWlucyhlKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBVSSBhbmQgaXRzIGNvbXBvbmVudHNcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5mbGlwcGVyICYmICh0aGlzLmZsaXBwZXIuZGVhY3RpdmF0ZSgpLCB0aGlzLmZsaXBwZXIgPSBudWxsKSwgdGhpcy5yZW1vdmVBbGxOb2RlcygpLCB0aGlzLnRvb2x0aXAuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtpbmcgRE9NXG4gICAqL1xuICBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlciA9IGQubWFrZShcImRpdlwiLCBbXG4gICAgICB0aGlzLkNTUy5pbmxpbmVUb29sYmFyLFxuICAgICAgLi4udGhpcy5pc1J0bCA/IFt0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yUnRsRml4XSA6IFtdXG4gICAgXSksIHRoaXMubm9kZXMudG9nZ2xlckFuZEJ1dHRvbnNXcmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnRvZ2dsZXJBbmRCdXR0b25zV3JhcHBlciksIHRoaXMubm9kZXMuYnV0dG9ucyA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5idXR0b25zV3JhcHBlciksIHRoaXMubm9kZXMuYWN0aW9ucyA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5hY3Rpb25zV3JhcHBlciksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMud3JhcHBlciwgXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGUudGFyZ2V0LmNsb3Nlc3QoYC4ke3RoaXMuQ1NTLmFjdGlvbnNXcmFwcGVyfWApIHx8IGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KSwgZC5hcHBlbmQodGhpcy5ub2Rlcy53cmFwcGVyLCBbdGhpcy5ub2Rlcy50b2dnbGVyQW5kQnV0dG9uc1dyYXBwZXIsIHRoaXMubm9kZXMuYWN0aW9uc10pLCBkLmFwcGVuZCh0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLCB0aGlzLm5vZGVzLndyYXBwZXIpLCB0aGlzLmFkZENvbnZlcnNpb25Ub2dnbGVyKCksIGQuYXBwZW5kKHRoaXMubm9kZXMudG9nZ2xlckFuZEJ1dHRvbnNXcmFwcGVyLCB0aGlzLm5vZGVzLmJ1dHRvbnMpLCB0aGlzLnByZXBhcmVDb252ZXJzaW9uVG9vbGJhcigpLCB0aGlzLnJlY2FsY3VsYXRlV2lkdGgoKSwgdGhpcy5lbmFibGVGbGlwcGVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIE5lZWQgdG8gc2hvdyBJbmxpbmUgVG9vbGJhciBvciBub3RcbiAgICovXG4gIGFsbG93ZWRUb1Nob3coKSB7XG4gICAgY29uc3QgZSA9IFtcIklNR1wiLCBcIklOUFVUXCJdLCB0ID0gbS5nZXQoKSwgbyA9IG0udGV4dDtcbiAgICBpZiAoIXQgfHwgIXQuYW5jaG9yTm9kZSB8fCB0LmlzQ29sbGFwc2VkIHx8IG8ubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBpID0gZC5pc0VsZW1lbnQodC5hbmNob3JOb2RlKSA/IHQuYW5jaG9yTm9kZSA6IHQuYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICh0ICYmIGUuaW5jbHVkZXMoaS50YWdOYW1lKSB8fCBpLmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJykgPT09IG51bGwpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgciA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayh0LmFuY2hvck5vZGUpO1xuICAgIHJldHVybiByID8gci50b29sLmlubGluZVRvb2xzLnNpemUgIT09IDAgOiAhMTtcbiAgfVxuICAvKipcbiAgICogUmVjYWxjdWxhdGUgaW5saW5lIHRvb2xiYXIgd2lkdGhcbiAgICovXG4gIHJlY2FsY3VsYXRlV2lkdGgoKSB7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMubm9kZXMud3JhcHBlci5vZmZzZXRXaWR0aDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdG9nZ2xlciBmb3IgQ29udmVyc2lvbiBEcm9wZG93blxuICAgKiBhbmQgcHJlcGVuZCBpdCB0byB0aGUgYnV0dG9ucyBsaXN0XG4gICAqL1xuICBhZGRDb252ZXJzaW9uVG9nZ2xlcigpIHtcbiAgICB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLmNvbnZlcnNpb25Ub2dnbGVyKSwgdGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlckNvbnRlbnQgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuY29udmVyc2lvblRvZ2dsZXJDb250ZW50KTtcbiAgICBjb25zdCBlID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLmNvbnZlcnNpb25Ub2dnbGVyQXJyb3csIHtcbiAgICAgIGlubmVySFRNTDogcHRcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVzLmNvbnZlcnNpb25Ub2dnbGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMuY29udmVyc2lvblRvZ2dsZXJDb250ZW50KSwgdGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlci5hcHBlbmRDaGlsZChlKSwgdGhpcy5ub2Rlcy50b2dnbGVyQW5kQnV0dG9uc1dyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlciksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMuY29udmVyc2lvblRvZ2dsZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIudG9nZ2xlKCh0KSA9PiB7XG4gICAgICAgICF0ICYmIHRoaXMub3BlbmVkID8gdGhpcy5mbGlwcGVyLmFjdGl2YXRlKCkgOiB0aGlzLm9wZW5lZCAmJiB0aGlzLmZsaXBwZXIuZGVhY3RpdmF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSksIGVlKCkgPT09ICExICYmIHRoaXMudG9vbHRpcC5vbkhvdmVyKHRoaXMubm9kZXMuY29udmVyc2lvblRvZ2dsZXIsICQudWkoWC51aS5pbmxpbmVUb29sYmFyLmNvbnZlcnRlciwgXCJDb252ZXJ0IHRvXCIpLCB7XG4gICAgICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gICAgICBoaWRpbmdEZWxheTogMTAwXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZXMgQ29udmVyc2lvbiBEcm9wZG93biBjb250ZW50IGZvciBjdXJyZW50IGJsb2NrJ3MgVG9vbFxuICAgKi9cbiAgYXN5bmMgc2V0Q29udmVyc2lvblRvZ2dsZXJDb250ZW50KCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IHQgfSA9IGUsIG8gPSB0Lm5hbWUsIGkgPSB0LnRvb2wuY29udmVyc2lvbkNvbmZpZywgbiA9IGkgJiYgaS5leHBvcnQ7XG4gICAgdGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlci5oaWRkZW4gPSAhbiwgdGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlci5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuQ1NTLmNvbnZlcnNpb25Ub2dnbGVySGlkZGVuLCAhbik7XG4gICAgY29uc3QgciA9IGF3YWl0IHQuZ2V0QWN0aXZlVG9vbGJveEVudHJ5KCkgfHwge307XG4gICAgdGhpcy5ub2Rlcy5jb252ZXJzaW9uVG9nZ2xlckNvbnRlbnQuaW5uZXJIVE1MID0gci5pY29uIHx8IHIudGl0bGUgfHwga2Uobyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIHRoZSBDb252ZXJzaW9uIERyb3Bkb3duXG4gICAqL1xuICBwcmVwYXJlQ29udmVyc2lvblRvb2xiYXIoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkNvbnZlcnNpb25Ub29sYmFyLm1ha2UoKTtcbiAgICBkLmFwcGVuZCh0aGlzLm5vZGVzLndyYXBwZXIsIGUpO1xuICB9XG4gIC8qKlxuICAgKiAgV29ya2luZyB3aXRoIFRvb2xzXG4gICAqICB+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+XG4gICAqL1xuICAvKipcbiAgICogQXBwZW5kIG9ubHkgYWxsb3dlZCBUb29sc1xuICAgKi9cbiAgYWRkVG9vbHNGaWx0ZXJlZCgpIHtcbiAgICBjb25zdCBlID0gbS5nZXQoKSwgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayhlLmFuY2hvck5vZGUpO1xuICAgIHRoaXMubm9kZXMuYnV0dG9ucy5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLm5vZGVzLmFjdGlvbnMuaW5uZXJIVE1MID0gXCJcIiwgdGhpcy50b29sc0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIEFycmF5LmZyb20odC50b29sLmlubGluZVRvb2xzLnZhbHVlcygpKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICB0aGlzLmFkZFRvb2wobyk7XG4gICAgfSksIHRoaXMucmVjYWxjdWxhdGVXaWR0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgdG9vbCBidXR0b24gYW5kIGFjdGl2YXRlIGNsaWNrc1xuICAgKlxuICAgKiBAcGFyYW0ge0lubGluZVRvb2x9IHRvb2wgLSBJbmxpbmVUb29sIG9iamVjdFxuICAgKi9cbiAgYWRkVG9vbChlKSB7XG4gICAgY29uc3QgdCA9IGUuY3JlYXRlKCksIG8gPSB0LnJlbmRlcigpO1xuICAgIGlmICghbykge1xuICAgICAgVChcIlJlbmRlciBtZXRob2QgbXVzdCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgTm9kZVwiLCBcIndhcm5cIiwgZS5uYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8uZGF0YXNldC50b29sID0gZS5uYW1lLCB0aGlzLm5vZGVzLmJ1dHRvbnMuYXBwZW5kQ2hpbGQobyksIHRoaXMudG9vbHNJbnN0YW5jZXMuc2V0KGUubmFtZSwgdCksIEQodC5yZW5kZXJBY3Rpb25zKSkge1xuICAgICAgY29uc3QgYSA9IHQucmVuZGVyQWN0aW9ucygpO1xuICAgICAgdGhpcy5ub2Rlcy5hY3Rpb25zLmFwcGVuZENoaWxkKGEpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycy5vbihvLCBcImNsaWNrXCIsIChhKSA9PiB7XG4gICAgICB0aGlzLnRvb2xDbGlja2VkKHQpLCBhLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0VG9vbFNob3J0Y3V0KGUubmFtZSk7XG4gICAgaWYgKGkpXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmVuYWJsZVNob3J0Y3V0cyh0LCBpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIGNvbnN0IG4gPSBkLm1ha2UoXCJkaXZcIiksIHIgPSAkLnQoXG4gICAgICBYLnRvb2xOYW1lcyxcbiAgICAgIGUudGl0bGUgfHwga2UoZS5uYW1lKVxuICAgICk7XG4gICAgbi5hcHBlbmRDaGlsZChkLnRleHQocikpLCBpICYmIG4uYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLmlubGluZVRvb2xiYXJTaG9ydGN1dCwge1xuICAgICAgdGV4dENvbnRlbnQ6IG50KGkpXG4gICAgfSkpLCBlZSgpID09PSAhMSAmJiB0aGlzLnRvb2x0aXAub25Ib3ZlcihvLCBuLCB7XG4gICAgICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gICAgICBoaWRpbmdEZWxheTogMTAwXG4gICAgfSksIHQuY2hlY2tTdGF0ZShtLmdldCgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHNob3J0Y3V0IG5hbWUgZm9yIHRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIOKAlCBUb29sIG5hbWVcbiAgICovXG4gIGdldFRvb2xTaG9ydGN1dChlKSB7XG4gICAgY29uc3QgeyBUb29sczogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSB0LmlubGluZVRvb2xzLmdldChlKSwgaSA9IHQuaW50ZXJuYWwuaW5saW5lVG9vbHM7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaS5rZXlzKCkpLmluY2x1ZGVzKGUpID8gdGhpcy5pbmxpbmVUb29sc1tlXVtrdC5TaG9ydGN1dF0gOiBvLnNob3J0Y3V0O1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgVG9vbCBzaG9ydGN1dCB3aXRoIEVkaXRvciBTaG9ydGN1dHMgTW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSB7SW5saW5lVG9vbH0gdG9vbCAtIFRvb2wgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0Y3V0IC0gc2hvcnRjdXQgYWNjb3JkaW5nIHRvIHRoZSBTaG9ydGN1dERhdGEgTW9kdWxlIGZvcm1hdFxuICAgKi9cbiAgZW5hYmxlU2hvcnRjdXRzKGUsIHQpIHtcbiAgICByZS5hZGQoe1xuICAgICAgbmFtZTogdCxcbiAgICAgIGhhbmRsZXI6IChvKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiBpIH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXI7XG4gICAgICAgIGkgJiYgaS50b29sLmVuYWJsZWRJbmxpbmVUb29scyAmJiAoby5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnRvb2xDbGlja2VkKGUpKTtcbiAgICAgIH0sXG4gICAgICBvbjogdGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3JcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5saW5lIFRvb2wgYnV0dG9uIGNsaWNrc1xuICAgKlxuICAgKiBAcGFyYW0ge0lubGluZVRvb2x9IHRvb2wgLSBUb29sJ3MgaW5zdGFuY2VcbiAgICovXG4gIHRvb2xDbGlja2VkKGUpIHtcbiAgICBjb25zdCB0ID0gbS5yYW5nZTtcbiAgICBlLnN1cnJvdW5kKHQpLCB0aGlzLmNoZWNrVG9vbHNTdGF0ZSgpLCBlLnJlbmRlckFjdGlvbnMgIT09IHZvaWQgMCAmJiB0aGlzLmZsaXBwZXIuZGVhY3RpdmF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBUb29sc2Agc3RhdGUgYnkgc2VsZWN0aW9uXG4gICAqL1xuICBjaGVja1Rvb2xzU3RhdGUoKSB7XG4gICAgdGhpcy50b29sc0luc3RhbmNlcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBlLmNoZWNrU3RhdGUobS5nZXQoKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmxpbmUgdG9vbHMgdG9vbHNcbiAgICogVG9vbHMgdGhhdCBoYXMgaXNJbmxpbmUgaXMgdHJ1ZVxuICAgKi9cbiAgZ2V0IGlubGluZVRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLkVkaXRvci5Ub29scy5pbmxpbmVUb29scy5lbnRyaWVzKCkpLmZvckVhY2goKFt0LCBvXSkgPT4ge1xuICAgICAgZVt0XSA9IG8uY3JlYXRlKCk7XG4gICAgfSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IHRvIGxlYWYgYnV0dG9ucyBieSBhcnJvd3MgLyB0YWJcbiAgICogQnV0dG9ucyB3aWxsIGJlIGZpbGxlZCBvbiBvcGVuaW5nXG4gICAqL1xuICBlbmFibGVGbGlwcGVyKCkge1xuICAgIHRoaXMuZmxpcHBlciA9IG5ldyBHKHtcbiAgICAgIGZvY3VzZWRJdGVtQ2xhc3M6IHRoaXMuQ1NTLmZvY3VzZWRCdXR0b24sXG4gICAgICBhbGxvd2VkS2V5czogW1xuICAgICAgICBCLkVOVEVSLFxuICAgICAgICBCLlRBQlxuICAgICAgXVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyAkbyBleHRlbmRzIFMge1xuICAvKipcbiAgICogQWxsIGtleWRvd25zIG9uIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBrZXlkb3duKGUpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYmVmb3JlS2V5ZG93blByb2Nlc3NpbmcoZSksIGUua2V5Q29kZSkge1xuICAgICAgY2FzZSBCLkJBQ0tTUEFDRTpcbiAgICAgICAgdGhpcy5iYWNrc3BhY2UoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCLkVOVEVSOlxuICAgICAgICB0aGlzLmVudGVyKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQi5ET1dOOlxuICAgICAgY2FzZSBCLlJJR0hUOlxuICAgICAgICB0aGlzLmFycm93UmlnaHRBbmREb3duKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQi5VUDpcbiAgICAgIGNhc2UgQi5MRUZUOlxuICAgICAgICB0aGlzLmFycm93TGVmdEFuZFVwKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQi5UQUI6XG4gICAgICAgIHRoaXMudGFiUHJlc3NlZChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGaXJlcyBvbiBrZXlkb3duIGJlZm9yZSBldmVudCBwcm9jZXNzaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBiZWZvcmVLZXlkb3duUHJvY2Vzc2luZyhlKSB7XG4gICAgdGhpcy5uZWVkVG9vbGJhckNsb3NpbmcoZSkgJiYgdHQoZS5rZXlDb2RlKSAmJiAodGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpLCB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci5jbG9zZSgpLCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHwgKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhckZvY3VzZWQoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSkpKTtcbiAgfVxuICAvKipcbiAgICogS2V5IHVwIG9uIEJsb2NrOlxuICAgKiAtIHNob3dzIElubGluZSBUb29sYmFyIGlmIHNvbWV0aGluZyBzZWxlY3RlZFxuICAgKiAtIHNob3dzIGNvbnZlcnNpb24gdG9vbGJhciB3aXRoIDg1JSBvZiBibG9jayBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleXVwIGV2ZW50XG4gICAqL1xuICBrZXl1cChlKSB7XG4gICAgZS5zaGlmdEtleSB8fCB0aGlzLkVkaXRvci5VSS5jaGVja0VtcHRpbmVzcygpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xib3ggdG8gbGVhZiBUb29sc1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0gdGFiIGtleWRvd24gZXZlbnRcbiAgICovXG4gIHRhYlByZXNzZWQoZSkge1xuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBJbmxpbmVUb29sYmFyOiBvLCBDb252ZXJzaW9uVG9vbGJhcjogaSB9ID0gdGhpcy5FZGl0b3IsIG4gPSB0LmN1cnJlbnRCbG9jaztcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IG4uaXNFbXB0eSwgYSA9IG4udG9vbC5pc0RlZmF1bHQgJiYgciwgbCA9ICFyICYmIGkub3BlbmVkLCBjID0gIXIgJiYgIW0uaXNDb2xsYXBzZWQgJiYgby5vcGVuZWQ7XG4gICAgYSA/IHRoaXMuYWN0aXZhdGVUb29sYm94KCkgOiAhbCAmJiAhYyAmJiB0aGlzLmFjdGl2YXRlQmxvY2tTZXR0aW5ncygpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgZHJvcCB0YXJnZXQgc3R5bGVzXG4gICAqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBldmVudCAtIGRyYWcgb3ZlciBldmVudFxuICAgKi9cbiAgZHJhZ092ZXIoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgdC5kcm9wVGFyZ2V0ID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBkcm9wIHRhcmdldCBzdHlsZVxuICAgKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnQgLSBkcmFnIGxlYXZlIGV2ZW50XG4gICAqL1xuICBkcmFnTGVhdmUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgdC5kcm9wVGFyZ2V0ID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIENvcHlpbmcgc2VsZWN0ZWQgYmxvY2tzXG4gICAqIEJlZm9yZSBwdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmQgd2Ugc2FuaXRpemUgYWxsIGJsb2NrcyBhbmQgdGhlbiBjb3B5IHRvIHRoZSBjbGlwYm9hcmRcbiAgICpcbiAgICogQHBhcmFtIHtDbGlwYm9hcmRFdmVudH0gZXZlbnQgLSBjbGlwYm9hcmQgZXZlbnRcbiAgICovXG4gIGhhbmRsZUNvbW1hbmRDKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrU2VsZWN0aW9uOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmFueUJsb2NrU2VsZWN0ZWQgJiYgdC5jb3B5U2VsZWN0ZWRCbG9ja3MoZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcHkgYW5kIERlbGV0ZSBzZWxlY3RlZCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtDbGlwYm9hcmRFdmVudH0gZXZlbnQgLSBjbGlwYm9hcmQgZXZlbnRcbiAgICovXG4gIGhhbmRsZUNvbW1hbmRYKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrU2VsZWN0aW9uOiB0LCBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmFueUJsb2NrU2VsZWN0ZWQgJiYgdC5jb3B5U2VsZWN0ZWRCbG9ja3MoZSkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBuID0gby5yZW1vdmVTZWxlY3RlZEJsb2NrcygpLCByID0gby5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KG4sICEwKTtcbiAgICAgIGkuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5TVEFSVCksIHQuY2xlYXJTZWxlY3Rpb24oZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVOVEVSIHByZXNzZWQgb24gYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGVudGVyKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgVUk6IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgIGlmICh0LmN1cnJlbnRCbG9jay50b29sLmlzTGluZUJyZWFrc0VuYWJsZWQgfHwgby5zb21lVG9vbGJhck9wZW5lZCAmJiBvLnNvbWVGbGlwcGVyQnV0dG9uRm9jdXNlZCB8fCBlLnNoaWZ0S2V5KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBuID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jaztcbiAgICB0aGlzLkVkaXRvci5DYXJldC5pc0F0U3RhcnQgJiYgIXRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2suaGFzTWVkaWEgPyB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleCh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXgpIDogdGhpcy5FZGl0b3IuQ2FyZXQuaXNBdEVuZCA/IG4gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleCh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXggKyAxKSA6IG4gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc3BsaXQoKSwgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhuKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbihuKSwgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYmFja3NwYWNlIGtleWRvd24gb24gQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGJhY2tzcGFjZShlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3IsIG4gPSB0LmN1cnJlbnRCbG9jaywgciA9IG4udG9vbDtcbiAgICBpZiAobi5zZWxlY3RlZCB8fCBuLmlzRW1wdHkgJiYgbi5jdXJyZW50SW5wdXQgPT09IG4uZmlyc3RJbnB1dCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgYyA9IHQuY3VycmVudEJsb2NrSW5kZXg7XG4gICAgICB0LnByZXZpb3VzQmxvY2sgJiYgdC5wcmV2aW91c0Jsb2NrLmlucHV0cy5sZW5ndGggPT09IDAgPyB0LnJlbW92ZUJsb2NrKGMgLSAxKSA6IHQucmVtb3ZlQmxvY2soKSwgaS5zZXRUb0Jsb2NrKFxuICAgICAgICB0LmN1cnJlbnRCbG9jayxcbiAgICAgICAgYyA/IGkucG9zaXRpb25zLkVORCA6IGkucG9zaXRpb25zLlNUQVJUXG4gICAgICApLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCksIG8uY2xlYXJTZWxlY3Rpb24oZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyLmlzTGluZUJyZWFrc0VuYWJsZWQgJiYgIWkuaXNBdFN0YXJ0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSB0LmN1cnJlbnRCbG9ja0luZGV4ID09PSAwO1xuICAgIGkuaXNBdFN0YXJ0ICYmIG0uaXNDb2xsYXBzZWQgJiYgbi5jdXJyZW50SW5wdXQgPT09IG4uZmlyc3RJbnB1dCAmJiAhYSAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLm1lcmdlQmxvY2tzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZSBjdXJyZW50IGFuZCBwcmV2aW91cyBCbG9ja3MgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHR5cGVcbiAgICovXG4gIG1lcmdlQmxvY2tzKCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlLCBDYXJldDogdCwgVG9vbGJhcjogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSBlLnByZXZpb3VzQmxvY2ssIG4gPSBlLmN1cnJlbnRCbG9jaztcbiAgICBpZiAobi5uYW1lICE9PSBpLm5hbWUgfHwgIWkubWVyZ2VhYmxlKSB7XG4gICAgICBpZiAoaS5pbnB1dHMubGVuZ3RoID09PSAwIHx8IGkuaXNFbXB0eSkge1xuICAgICAgICBlLnJlbW92ZUJsb2NrKGUuY3VycmVudEJsb2NrSW5kZXggLSAxKSwgdC5zZXRUb0Jsb2NrKGUuY3VycmVudEJsb2NrKSwgby5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0Lm5hdmlnYXRlUHJldmlvdXMoKSAmJiBvLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuY3JlYXRlU2hhZG93KGkucGx1Z2luc0NvbnRlbnQpLCBlLm1lcmdlQmxvY2tzKGksIG4pLnRoZW4oKCkgPT4ge1xuICAgICAgdC5yZXN0b3JlQ2FyZXQoaS5wbHVnaW5zQ29udGVudCksIGkucGx1Z2luc0NvbnRlbnQubm9ybWFsaXplKCksIG8uY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHJpZ2h0IGFuZCBkb3duIGtleWJvYXJkIGtleXNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBhcnJvd1JpZ2h0QW5kRG93bihlKSB7XG4gICAgY29uc3QgdCA9IEcudXNlZEtleXMuaW5jbHVkZXMoZS5rZXlDb2RlKSAmJiAoIWUuc2hpZnRLZXkgfHwgZS5rZXlDb2RlID09PSBCLlRBQik7XG4gICAgaWYgKHRoaXMuRWRpdG9yLlVJLnNvbWVUb29sYmFyT3BlbmVkICYmIHQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmNsZWFyRm9jdXNlZCgpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gICAgY29uc3QgbyA9IHRoaXMuRWRpdG9yLkNhcmV0LmlzQXRFbmQgfHwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uYW55QmxvY2tTZWxlY3RlZDtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IEIuRE9XTiAmJiBvKSB7XG4gICAgICB0aGlzLkVkaXRvci5Dcm9zc0Jsb2NrU2VsZWN0aW9uLnRvZ2dsZUJsb2NrU2VsZWN0ZWRTdGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoZS5rZXlDb2RlID09PSBCLkRPV04gfHwgZS5rZXlDb2RlID09PSBCLlJJR0hUICYmICF0aGlzLmlzUnRsID8gdGhpcy5FZGl0b3IuQ2FyZXQubmF2aWdhdGVOZXh0KCkgOiB0aGlzLkVkaXRvci5DYXJldC5uYXZpZ2F0ZVByZXZpb3VzKCkpID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogb2UoKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayAmJiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLnVwZGF0ZUN1cnJlbnRJbnB1dCgpO1xuICAgIH0sIDIwKSgpLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGxlZnQgYW5kIHVwIGtleWJvYXJkIGtleXNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBhcnJvd0xlZnRBbmRVcChlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLlVJLnNvbWVUb29sYmFyT3BlbmVkKSB7XG4gICAgICBpZiAoRy51c2VkS2V5cy5pbmNsdWRlcyhlLmtleUNvZGUpICYmICghZS5zaGlmdEtleSB8fCBlLmtleUNvZGUgPT09IEIuVEFCKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5FZGl0b3IuVUkuY2xvc2VBbGxUb29sYmFycygpO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXJGb2N1c2VkKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQ2FyZXQuaXNBdFN0YXJ0IHx8IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFueUJsb2NrU2VsZWN0ZWQ7XG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSBCLlVQICYmIHQpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24udG9nZ2xlQmxvY2tTZWxlY3RlZFN0YXRlKCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKGUua2V5Q29kZSA9PT0gQi5VUCB8fCBlLmtleUNvZGUgPT09IEIuTEVGVCAmJiAhdGhpcy5pc1J0bCA/IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlUHJldmlvdXMoKSA6IHRoaXMuRWRpdG9yLkNhcmV0Lm5hdmlnYXRlTmV4dCgpKSA/IGUucHJldmVudERlZmF1bHQoKSA6IG9lKCgpID0+IHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgJiYgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay51cGRhdGVDdXJyZW50SW5wdXQoKTtcbiAgICB9LCAyMCkoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSk7XG4gIH1cbiAgLyoqXG4gICAqIENhc2VzIHdoZW4gd2UgbmVlZCB0byBjbG9zZSBUb29sYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgbmVlZFRvb2xiYXJDbG9zaW5nKGUpIHtcbiAgICBjb25zdCB0ID0gZS5rZXlDb2RlID09PSBCLkVOVEVSICYmIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuZWQsIG8gPSBlLmtleUNvZGUgPT09IEIuRU5URVIgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQsIGkgPSBlLmtleUNvZGUgPT09IEIuRU5URVIgJiYgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5vcGVuZWQsIG4gPSBlLmtleUNvZGUgPT09IEIuRU5URVIgJiYgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIub3BlbmVkLCByID0gZS5rZXlDb2RlID09PSBCLlRBQjtcbiAgICByZXR1cm4gIShlLnNoaWZ0S2V5IHx8IHIgfHwgdCB8fCBvIHx8IGkgfHwgbik7XG4gIH1cbiAgLyoqXG4gICAqIElmIFRvb2xib3ggaXMgbm90IG9wZW4sIHRoZW4ganVzdCBvcGVuIGl0IGFuZCBzaG93IHBsdXMgYnV0dG9uXG4gICAqL1xuICBhY3RpdmF0ZVRvb2xib3goKSB7XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5vcGVuZWQgfHwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpLCB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIFRvb2xiYXIgYW5kIHNob3cgQmxvY2tTZXR0aW5ncyBiZWZvcmUgZmxpcHBpbmcgVG9vbHNcbiAgICovXG4gIGFjdGl2YXRlQmxvY2tTZXR0aW5ncygpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm9wZW5lZCB8fCAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay5mb2N1c2VkID0gITAsIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKSksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkIHx8IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbigpO1xuICB9XG59XG5jbGFzcyBDZSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gd29ya2luZ0FyZWEg4oCUIGVkaXRvcmBzIHdvcmtpbmcgbm9kZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuYmxvY2tzID0gW10sIHRoaXMud29ya2luZ0FyZWEgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgbGVuZ3RoIG9mIEJsb2NrIGluc3RhbmNlcyBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgaW5zdGFuY2VzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKi9cbiAgZ2V0IGFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrcztcbiAgfVxuICAvKipcbiAgICogR2V0IGJsb2NrcyBodG1sIGVsZW1lbnRzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfVxuICAgKi9cbiAgZ2V0IG5vZGVzKCkge1xuICAgIHJldHVybiBpdCh0aGlzLndvcmtpbmdBcmVhLmNoaWxkcmVuKTtcbiAgfVxuICAvKipcbiAgICogUHJveHkgdHJhcCB0byBpbXBsZW1lbnQgYXJyYXktbGlrZSBzZXR0ZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYmxvY2tzWzBdID0gbmV3IEJsb2NrKC4uLilcbiAgICogQHBhcmFtIHtCbG9ja3N9IGluc3RhbmNlIOKAlCBCbG9ja3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0gcHJvcGVydHkg4oCUIGJsb2NrIGluZGV4IG9yIGFueSBCbG9ja3MgY2xhc3MgcHJvcGVydHkga2V5IHRvIHNldFxuICAgKiBAcGFyYW0ge0Jsb2NrfSB2YWx1ZSDigJQgdmFsdWUgdG8gc2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIHNldChlLCB0LCBvKSB7XG4gICAgcmV0dXJuIGlzTmFOKE51bWJlcih0KSkgPyAoUmVmbGVjdC5zZXQoZSwgdCwgbyksICEwKSA6IChlLmluc2VydCgrdCwgbyksICEwKTtcbiAgfVxuICAvKipcbiAgICogUHJveHkgdHJhcCB0byBpbXBsZW1lbnQgYXJyYXktbGlrZSBnZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja3N9IGluc3RhbmNlIOKAlCBCbG9ja3MgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0gcHJvcGVydHkg4oCUIEJsb2NrcyBjbGFzcyBwcm9wZXJ0eSBrZXlcbiAgICogQHJldHVybnMge0Jsb2NrfCp9XG4gICAqL1xuICBzdGF0aWMgZ2V0KGUsIHQpIHtcbiAgICByZXR1cm4gaXNOYU4oTnVtYmVyKHQpKSA/IFJlZmxlY3QuZ2V0KGUsIHQpIDogZS5nZXQoK3QpO1xuICB9XG4gIC8qKlxuICAgKiBQdXNoIG5ldyBCbG9jayB0byB0aGUgYmxvY2tzIGFycmF5IGFuZCBhcHBlbmQgaXQgdG8gd29ya2luZyBhcmVhXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gYWRkXG4gICAqL1xuICBwdXNoKGUpIHtcbiAgICB0aGlzLmJsb2Nrcy5wdXNoKGUpLCB0aGlzLmluc2VydFRvRE9NKGUpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwcyBibG9ja3Mgd2l0aCBpbmRleGVzIGZpcnN0IGFuZCBzZWNvbmRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZpcnN0IC0gZmlyc3QgYmxvY2sgaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZCAtIHNlY29uZCBibG9jayBpbmRleFxuICAgKiBAZGVwcmVjYXRlZCDigJQgdXNlICdtb3ZlJyBpbnN0ZWFkXG4gICAqL1xuICBzd2FwKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5ibG9ja3NbdF07XG4gICAgZC5zd2FwKHRoaXMuYmxvY2tzW2VdLmhvbGRlciwgby5ob2xkZXIpLCB0aGlzLmJsb2Nrc1t0XSA9IHRoaXMuYmxvY2tzW2VdLCB0aGlzLmJsb2Nrc1tlXSA9IG87XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgYSBibG9jayBmcm9tIG9uZSB0byBhbm90aGVyIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gbmV3IGluZGV4IG9mIHRoZSBibG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gYmxvY2sgdG8gbW92ZVxuICAgKi9cbiAgbW92ZShlLCB0KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuYmxvY2tzLnNwbGljZSh0LCAxKVswXSwgaSA9IGUgLSAxLCBuID0gTWF0aC5tYXgoMCwgaSksIHIgPSB0aGlzLmJsb2Nrc1tuXTtcbiAgICBlID4gMCA/IHRoaXMuaW5zZXJ0VG9ET00obywgXCJhZnRlcmVuZFwiLCByKSA6IHRoaXMuaW5zZXJ0VG9ET00obywgXCJiZWZvcmViZWdpblwiLCByKSwgdGhpcy5ibG9ja3Muc3BsaWNlKGUsIDAsIG8pO1xuICAgIGNvbnN0IGEgPSB0aGlzLmNvbXBvc2VCbG9ja0V2ZW50KFwibW92ZVwiLCB7XG4gICAgICBmcm9tSW5kZXg6IHQsXG4gICAgICB0b0luZGV4OiBlXG4gICAgfSk7XG4gICAgby5jYWxsKHEuTU9WRUQsIGEpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IEJsb2NrIGF0IHBhc3NlZCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg4oCUIGluZGV4IHRvIGluc2VydCBCbG9ja1xuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayDigJQgQmxvY2sgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSDigJQgaXQgdHJ1ZSwgcmVwbGFjZSBibG9jayBvbiBnaXZlbiBpbmRleFxuICAgKi9cbiAgaW5zZXJ0KGUsIHQsIG8gPSAhMSkge1xuICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucHVzaCh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA+IHRoaXMubGVuZ3RoICYmIChlID0gdGhpcy5sZW5ndGgpLCBvICYmICh0aGlzLmJsb2Nrc1tlXS5ob2xkZXIucmVtb3ZlKCksIHRoaXMuYmxvY2tzW2VdLmNhbGwocS5SRU1PVkVEKSk7XG4gICAgY29uc3QgaSA9IG8gPyAxIDogMDtcbiAgICBpZiAodGhpcy5ibG9ja3Muc3BsaWNlKGUsIGksIHQpLCBlID4gMCkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuYmxvY2tzW2UgLSAxXTtcbiAgICAgIHRoaXMuaW5zZXJ0VG9ET00odCwgXCJhZnRlcmVuZFwiLCBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbiA9IHRoaXMuYmxvY2tzW2UgKyAxXTtcbiAgICAgIG4gPyB0aGlzLmluc2VydFRvRE9NKHQsIFwiYmVmb3JlYmVnaW5cIiwgbikgOiB0aGlzLmluc2VydFRvRE9NKHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlKGUpIHtcbiAgICBpc05hTihlKSAmJiAoZSA9IHRoaXMubGVuZ3RoIC0gMSksIHRoaXMuYmxvY2tzW2VdLmhvbGRlci5yZW1vdmUoKSwgdGhpcy5ibG9ja3NbZV0uY2FsbChxLlJFTU9WRUQpLCB0aGlzLmJsb2Nrcy5zcGxpY2UoZSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgYmxvY2tzXG4gICAqL1xuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy53b3JraW5nQXJlYS5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLmJsb2Nrcy5mb3JFYWNoKChlKSA9PiBlLmNhbGwocS5SRU1PVkVEKSksIHRoaXMuYmxvY2tzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBCbG9jayBhZnRlciBwYXNzZWQgdGFyZ2V0XG4gICAqXG4gICAqIEB0b2RvIGRlY2lkZSBpZiB0aGlzIG1ldGhvZCBpcyBuZWNlc3NhcnlcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0QmxvY2sg4oCUIHRhcmdldCBhZnRlciB3aGljaCBCbG9jayBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICogQHBhcmFtIHtCbG9ja30gbmV3QmxvY2sg4oCUIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmJsb2Nrcy5pbmRleE9mKGUpO1xuICAgIHRoaXMuaW5zZXJ0KG8gKyAxLCB0KTtcbiAgfVxuICAvKipcbiAgICogR2V0IEJsb2NrIGJ5IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDigJQgQmxvY2sgaW5kZXhcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3NbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBpbmRleCBvZiBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBmaW5kXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBpbmRleE9mKGUpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuaW5kZXhPZihlKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IG5ldyBCbG9jayBpbnRvIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge0luc2VydFBvc2l0aW9ufSBwb3NpdGlvbiDigJQgaW5zZXJ0IHBvc2l0aW9uIChpZiBzZXQsIHdpbGwgdXNlIGluc2VydEFkamFjZW50RWxlbWVudClcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0IOKAlCBCbG9jayByZWxhdGVkIHRvIHBvc2l0aW9uXG4gICAqL1xuICBpbnNlcnRUb0RPTShlLCB0LCBvKSB7XG4gICAgdCA/IG8uaG9sZGVyLmluc2VydEFkamFjZW50RWxlbWVudCh0LCBlLmhvbGRlcikgOiB0aGlzLndvcmtpbmdBcmVhLmFwcGVuZENoaWxkKGUuaG9sZGVyKSwgZS5jYWxsKHEuUkVOREVSRUQpO1xuICB9XG4gIC8qKlxuICAgKiBDb21wb3NlcyBCbG9jayBldmVudCB3aXRoIHBhc3NlZCB0eXBlIGFuZCBkZXRhaWxzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsIC0gZXZlbnQgZGV0YWlsXG4gICAqL1xuICBjb21wb3NlQmxvY2tFdmVudChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChlLCB7XG4gICAgICBkZXRhaWw6IHRcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgSmUgPSBcImJsb2NrLXJlbW92ZWRcIiwgUWUgPSBcImJsb2NrLWFkZGVkXCIsIFdvID0gXCJibG9jay1tb3ZlZFwiLCBZbyA9IFwiYmxvY2stY2hhbmdlZFwiO1xuY2xhc3MgS28gZXh0ZW5kcyBTIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fY3VycmVudEJsb2NrSW5kZXggPSAtMSwgdGhpcy5fYmxvY2tzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IEJsb2NrIGluZGV4XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgY3VycmVudEJsb2NrSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCbG9ja0luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgY3VycmVudCBCbG9jayBpbmRleCBhbmQgZmlyZSBCbG9jayBsaWZlY3ljbGUgY2FsbGJhY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIHNldCBhcyBjdXJyZW50XG4gICAqL1xuICBzZXQgY3VycmVudEJsb2NrSW5kZXgoZSkge1xuICAgIHRoaXMuX2N1cnJlbnRCbG9ja0luZGV4ID0gZTtcbiAgfVxuICAvKipcbiAgICogcmV0dXJucyBmaXJzdCBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXQgZmlyc3RCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzWzBdO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIGxhc3QgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0IGxhc3RCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2Nrcy5sZW5ndGggLSAxXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgQmxvY2sgaW5zdGFuY2VcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzW3RoaXMuY3VycmVudEJsb2NrSW5kZXhdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgcGFzc2VkIEJsb2NrIGFzIGEgY3VycmVudFxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byBzZXQgYXMgYSBjdXJyZW50XG4gICAqL1xuICBzZXQgY3VycmVudEJsb2NrKGUpIHtcbiAgICB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdGhpcy5nZXRCbG9ja0luZGV4KGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIG5leHQgQmxvY2sgaW5zdGFuY2VcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfG51bGx9XG4gICAqL1xuICBnZXQgbmV4dEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID09PSB0aGlzLl9ibG9ja3MubGVuZ3RoIC0gMSA/IG51bGwgOiB0aGlzLl9ibG9ja3NbdGhpcy5jdXJyZW50QmxvY2tJbmRleCArIDFdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgQmxvY2sgd2l0aCBpbnB1dHMgYWZ0ZXIgY3VycmVudCBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2sgfCB1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgbmV4dENvbnRlbnRmdWxCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3Muc2xpY2UodGhpcy5jdXJyZW50QmxvY2tJbmRleCArIDEpLmZpbmQoKHQpID0+ICEhdC5pbnB1dHMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IEJsb2NrIHdpdGggaW5wdXRzIGJlZm9yZSBjdXJyZW50IEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9jayB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBwcmV2aW91c0NvbnRlbnRmdWxCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3Muc2xpY2UoMCwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCkucmV2ZXJzZSgpLmZpbmQoKHQpID0+ICEhdC5pbnB1dHMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcmV2aW91cyBCbG9jayBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2aW91c0Jsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID09PSAwID8gbnVsbCA6IHRoaXMuX2Jsb2Nrc1t0aGlzLmN1cnJlbnRCbG9ja0luZGV4IC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhcnJheSBvZiBCbG9jayBpbnN0YW5jZXNcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrW119IHtAbGluayBCbG9ja3MjYXJyYXl9XG4gICAqL1xuICBnZXQgYmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3MuYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGVhY2ggQmxvY2sgaXMgZW1wdHlcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNFZGl0b3JFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuZXZlcnkoKGUpID0+IGUuaXNFbXB0eSk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgRWRpdG9yLlVJIHByZXBhcmF0aW9uXG4gICAqIERlZmluZSB0aGlzLl9ibG9ja3MgcHJvcGVydHlcbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBDZSh0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3Rvcik7XG4gICAgdGhpcy5fYmxvY2tzID0gbmV3IFByb3h5KGUsIHtcbiAgICAgIHNldDogQ2Uuc2V0LFxuICAgICAgZ2V0OiBDZS5nZXRcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY29weVwiLFxuICAgICAgKHQpID0+IHRoaXMuRWRpdG9yLkJsb2NrRXZlbnRzLmhhbmRsZUNvbW1hbmRDKHQpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIHJlYWQtb25seSBzdGF0ZVxuICAgKlxuICAgKiBJZiByZWFkT25seSBpcyB0cnVlOlxuICAgKiAgLSBVbmJpbmQgZXZlbnQgaGFuZGxlcnMgZnJvbSBjcmVhdGVkIEJsb2Nrc1xuICAgKlxuICAgKiBpZiByZWFkT25seSBpcyBmYWxzZTpcbiAgICogIC0gQmluZCBldmVudCBoYW5kbGVycyB0byBhbGwgZXhpc3RpbmcgQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHlFbmFibGVkIC0gXCJyZWFkIG9ubHlcIiBzdGF0ZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyB0aGlzLmRpc2FibGVNb2R1bGVCaW5kaW5ncygpIDogdGhpcy5lbmFibGVNb2R1bGVCaW5kaW5ncygpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIEJsb2NrIGluc3RhbmNlIGJ5IHRvb2wgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGJsb2NrIGNyZWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbCAtIHRvb2xzIHBhc3NlZCBpbiBlZGl0b3IgY29uZmlnIHtAbGluayBFZGl0b3JDb25maWcjdG9vbHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF0gLSB1bmlxdWUgaWQgZm9yIHRoaXMgYmxvY2tcbiAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBbb3B0aW9ucy5kYXRhXSAtIGNvbnN0cnVjdG9yIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBjb21wb3NlQmxvY2soe1xuICAgIHRvb2w6IGUsXG4gICAgZGF0YTogdCA9IHt9LFxuICAgIGlkOiBvID0gdm9pZCAwLFxuICAgIHR1bmVzOiBpID0ge31cbiAgfSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQsIHIgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldChlKSwgYSA9IG5ldyBGKHtcbiAgICAgIGlkOiBvLFxuICAgICAgZGF0YTogdCxcbiAgICAgIHRvb2w6IHIsXG4gICAgICBhcGk6IHRoaXMuRWRpdG9yLkFQSSxcbiAgICAgIHJlYWRPbmx5OiBuLFxuICAgICAgdHVuZXNEYXRhOiBpXG4gICAgfSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyKTtcbiAgICByZXR1cm4gbiB8fCB0aGlzLmJpbmRCbG9ja0V2ZW50cyhhKSwgYTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IG5ldyBibG9jayBpbnRvIF9ibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBpbnNlcnQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWRdIC0gYmxvY2sncyB1bmlxdWUgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRvb2xdIC0gcGx1Z2luIG5hbWUsIGJ5IGRlZmF1bHQgbWV0aG9kIGluc2VydHMgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZGF0YV0gLSBwbHVnaW4gZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5kZXhdIC0gaW5kZXggd2hlcmUgdG8gaW5zZXJ0IG5ldyBCbG9ja1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5lZWRUb0ZvY3VzXSAtIGZsYWcgc2hvd3MgaWYgbmVlZGVkIHRvIHVwZGF0ZSBjdXJyZW50IEJsb2NrIGluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVwbGFjZV0gLSBmbGFnIHNob3dzIGlmIGJsb2NrIGJ5IHBhc3NlZCBpbmRleCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBpbnNlcnRlZCBvbmVcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgaW5zZXJ0KHtcbiAgICBpZDogZSA9IHZvaWQgMCxcbiAgICB0b29sOiB0ID0gdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLFxuICAgIGRhdGE6IG8gPSB7fSxcbiAgICBpbmRleDogaSxcbiAgICBuZWVkVG9Gb2N1czogbiA9ICEwLFxuICAgIHJlcGxhY2U6IHIgPSAhMSxcbiAgICB0dW5lczogYSA9IHt9XG4gIH0gPSB7fSkge1xuICAgIGxldCBsID0gaTtcbiAgICBsID09PSB2b2lkIDAgJiYgKGwgPSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICsgKHIgPyAwIDogMSkpO1xuICAgIGNvbnN0IGMgPSB0aGlzLmNvbXBvc2VCbG9jayh7XG4gICAgICBpZDogZSxcbiAgICAgIHRvb2w6IHQsXG4gICAgICBkYXRhOiBvLFxuICAgICAgdHVuZXM6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gciAmJiB0aGlzLmJsb2NrRGlkTXV0YXRlZChKZSwgdGhpcy5nZXRCbG9ja0J5SW5kZXgobCksIHtcbiAgICAgIGluZGV4OiBsXG4gICAgfSksIHRoaXMuX2Jsb2Nrcy5pbnNlcnQobCwgYywgciksIHRoaXMuYmxvY2tEaWRNdXRhdGVkKFFlLCBjLCB7XG4gICAgICBpbmRleDogbFxuICAgIH0pLCBuID8gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IGwgOiBsIDw9IHRoaXMuY3VycmVudEJsb2NrSW5kZXggJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleCsrLCBjO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIGN1cnJlbnQgd29ya2luZyBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHJlcGxhY2Ugb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sIOKAlCBwbHVnaW4gbmFtZVxuICAgKiBAcGFyYW0ge0Jsb2NrVG9vbERhdGF9IG9wdGlvbnMuZGF0YSDigJQgcGx1Z2luIGRhdGFcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgcmVwbGFjZSh7XG4gICAgdG9vbDogZSA9IHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayxcbiAgICBkYXRhOiB0ID0ge31cbiAgfSkge1xuICAgIHJldHVybiB0aGlzLmluc2VydCh7XG4gICAgICB0b29sOiBlLFxuICAgICAgZGF0YTogdCxcbiAgICAgIGluZGV4OiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4LFxuICAgICAgcmVwbGFjZTogITBcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHBhc3RlZCBjb250ZW50LiBDYWxsIG9uUGFzdGUgY2FsbGJhY2sgYWZ0ZXIgaW5zZXJ0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbE5hbWUgLSBuYW1lIG9mIFRvb2wgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudH0gcGFzdGVFdmVudCAtIHBhc3RlZCBkYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZSAtIHNob3VsZCByZXBsYWNlIGN1cnJlbnQgYmxvY2tcbiAgICovXG4gIHBhc3RlKGUsIHQsIG8gPSAhMSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLmluc2VydCh7XG4gICAgICB0b29sOiBlLFxuICAgICAgcmVwbGFjZTogb1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBpLmNhbGwocS5PTl9QQVNURSwgdCk7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgVChgJHtlfTogb25QYXN0ZSBjYWxsYmFjayBjYWxsIGlzIGZhaWxlZGAsIFwiZXJyb3JcIiwgbik7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IGRlZmF1bHQgYmxvY2sgYXQgcGFzc2VkIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IHdoZXJlIEJsb2NrIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZWRUb0ZvY3VzIC0gaWYgdHJ1ZSwgdXBkYXRlcyBjdXJyZW50IEJsb2NrIGluZGV4XG4gICAqXG4gICAqIFRPRE86IFJlbW92ZSBtZXRob2QgYW5kIHVzZSBpbnNlcnQoKSB3aXRoIGluZGV4IGluc3RlYWQgKD8pXG4gICAqIEByZXR1cm5zIHtCbG9ja30gaW5zZXJ0ZWQgQmxvY2tcbiAgICovXG4gIGluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgoZSwgdCA9ICExKSB7XG4gICAgY29uc3QgbyA9IHRoaXMuY29tcG9zZUJsb2NrKHsgdG9vbDogdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrIH0pO1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbZV0gPSBvLCB0aGlzLmJsb2NrRGlkTXV0YXRlZChRZSwgbywge1xuICAgICAgaW5kZXg6IGVcbiAgICB9KSwgdCA/IHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSBlIDogZSA8PSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICYmIHRoaXMuY3VycmVudEJsb2NrSW5kZXgrKywgbztcbiAgfVxuICAvKipcbiAgICogQWx3YXlzIGluc2VydHMgYXQgdGhlIGVuZFxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBpbnNlcnRBdEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDEsIHRoaXMuaW5zZXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0QmxvY2sgLSBwcmV2aW91cyBibG9jayB3aWxsIGJlIGFwcGVuZCB0byB0aGlzIGJsb2NrXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrVG9NZXJnZSAtIGJsb2NrIHRoYXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0YXJnZXQgYmxvY2tcbiAgICogQHJldHVybnMge1Byb21pc2V9IC0gdGhlIHNlcXVlbmNlIHRoYXQgY2FuIGJlIGNvbnRpbnVlZFxuICAgKi9cbiAgYXN5bmMgbWVyZ2VCbG9ja3MoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9ibG9ja3MuaW5kZXhPZih0KTtcbiAgICBpZiAodC5pc0VtcHR5KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBhd2FpdCB0LmRhdGE7XG4gICAgVihpKSB8fCBhd2FpdCBlLm1lcmdlV2l0aChpKSwgdGhpcy5yZW1vdmVCbG9jayhvKSwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuX2Jsb2Nrcy5pbmRleE9mKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYmxvY2sgd2l0aCBwYXNzZWQgaW5kZXggb3IgcmVtb3ZlIGxhc3RcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gaW5kZXggLSBpbmRleCBvZiBCbG9jayB0byByZW1vdmVcbiAgICogQHRocm93cyB7RXJyb3J9IGlmIEJsb2NrIHRvIHJlbW92ZSBpcyBub3QgZm91bmRcbiAgICovXG4gIHJlbW92ZUJsb2NrKGUgPSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5kZXgoZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGEgQmxvY2sgdG8gcmVtb3ZlXCIpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9ibG9ja3NbZV07XG4gICAgdC5kZXN0cm95KCksIHRoaXMuX2Jsb2Nrcy5yZW1vdmUoZSksIHRoaXMuYmxvY2tEaWRNdXRhdGVkKEplLCB0LCB7XG4gICAgICBpbmRleDogZVxuICAgIH0pLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID49IGUgJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleC0tLCB0aGlzLmJsb2Nrcy5sZW5ndGggPyBlID09PSAwICYmICh0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gMCkgOiAodGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IC0xLCB0aGlzLmluc2VydCgpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIG9ubHkgc2VsZWN0ZWQgQmxvY2tzXG4gICAqIGFuZCByZXR1cm5zIGZpcnN0IEJsb2NrIGluZGV4IHdoZXJlIHN0YXJ0ZWQgcmVtb3ZpbmcuLi5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICByZW1vdmVTZWxlY3RlZEJsb2NrcygpIHtcbiAgICBsZXQgZTtcbiAgICBmb3IgKGxldCB0ID0gdGhpcy5ibG9ja3MubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pXG4gICAgICB0aGlzLmJsb2Nrc1t0XS5zZWxlY3RlZCAmJiAodGhpcy5yZW1vdmVCbG9jayh0KSwgZSA9IHQpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbnRpb24hXG4gICAqIEFmdGVyIHJlbW92aW5nIGluc2VydCB0aGUgbmV3IGRlZmF1bHQgdHlwZWQgQmxvY2sgYW5kIGZvY3VzIG9uIGl0XG4gICAqIFJlbW92ZXMgYWxsIGJsb2Nrc1xuICAgKi9cbiAgcmVtb3ZlQWxsQmxvY2tzKCkge1xuICAgIGZvciAobGV0IGUgPSB0aGlzLmJsb2Nrcy5sZW5ndGggLSAxOyBlID49IDA7IGUtLSlcbiAgICAgIHRoaXMuX2Jsb2Nrcy5yZW1vdmUoZSk7XG4gICAgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IC0xLCB0aGlzLmluc2VydCgpLCB0aGlzLmN1cnJlbnRCbG9jay5maXJzdElucHV0LmZvY3VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0IGN1cnJlbnQgQmxvY2tcbiAgICogMS4gRXh0cmFjdCBjb250ZW50IGZyb20gQ2FyZXQgcG9zaXRpb24gdG8gdGhlIEJsb2NrYHMgZW5kXG4gICAqIDIuIEluc2VydCBhIG5ldyBCbG9jayBiZWxvdyBjdXJyZW50IG9uZSB3aXRoIGV4dHJhY3RlZCBjb250ZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIHNwbGl0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLkVkaXRvci5DYXJldC5leHRyYWN0RnJhZ21lbnRGcm9tQ2FyZXRQb3NpdGlvbigpLCB0ID0gZC5tYWtlKFwiZGl2XCIpO1xuICAgIHQuYXBwZW5kQ2hpbGQoZSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHRleHQ6IGQuaXNFbXB0eSh0KSA/IFwiXCIgOiB0LmlubmVySFRNTFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHsgZGF0YTogbyB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBCbG9jayBieSBwYXNzZWQgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggdG8gZ2V0LiAtMSB0byBnZXQgbGFzdFxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXRCbG9ja0J5SW5kZXgoZSkge1xuICAgIHJldHVybiBlID09PSAtMSAmJiAoZSA9IHRoaXMuX2Jsb2Nrcy5sZW5ndGggLSAxKSwgdGhpcy5fYmxvY2tzW2VdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluZGV4IGZvciBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gZmluZCBpbmRleFxuICAgKi9cbiAgZ2V0QmxvY2tJbmRleChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrcy5pbmRleE9mKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBCbG9jayBieSBwYXNzZWQgaWRcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gaWQgb2YgYmxvY2sgdG8gZ2V0XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldEJsb2NrQnlJZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrcy5hcnJheS5maW5kKCh0KSA9PiB0LmlkID09PSBlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEJsb2NrIGluc3RhbmNlIGJ5IGh0bWwgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsZW1lbnQgLSBodG1sIGVsZW1lbnQgdG8gZ2V0IEJsb2NrIGJ5XG4gICAqL1xuICBnZXRCbG9jayhlKSB7XG4gICAgZC5pc0VsZW1lbnQoZSkgfHwgKGUgPSBlLnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9ibG9ja3Mubm9kZXMsIG8gPSBlLmNsb3Nlc3QoYC4ke0YuQ1NTLndyYXBwZXJ9YCksIGkgPSB0LmluZGV4T2Yobyk7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIHJldHVybiB0aGlzLl9ibG9ja3NbaV07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxlY3Rpb24gZnJvbSBhbGwgQmxvY2tzIHRoZW4gaGlnaGxpZ2h0IG9ubHkgQ3VycmVudCBCbG9ja1xuICAgKi9cbiAgaGlnaGxpZ2h0Q3VycmVudE5vZGUoKSB7XG4gICAgdGhpcy5jbGVhckZvY3VzZWQoKSwgdGhpcy5jdXJyZW50QmxvY2suZm9jdXNlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZWN0aW9uIGZyb20gYWxsIEJsb2Nrc1xuICAgKi9cbiAgY2xlYXJGb2N1c2VkKCkge1xuICAgIHRoaXMuYmxvY2tzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuZm9jdXNlZCA9ICExO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiAxKSBGaW5kIGZpcnN0LWxldmVsIEJsb2NrIGZyb20gcGFzc2VkIGNoaWxkIE5vZGVcbiAgICogMikgTWFyayBpdCBhcyBjdXJyZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gY2hpbGROb2RlIC0gbG9vayBhaGVhZCBmcm9tIHRoaXMgbm9kZS5cbiAgICogQHJldHVybnMge0Jsb2NrIHwgdW5kZWZpbmVkfSBjYW4gcmV0dXJuIHVuZGVmaW5lZCBpbiBjYXNlIHdoZW4gdGhlIHBhc3NlZCBjaGlsZCBub3RlIGlzIG5vdCBhIHBhcnQgb2YgdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG4gICAqL1xuICBzZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShlKSB7XG4gICAgZC5pc0VsZW1lbnQoZSkgfHwgKGUgPSBlLnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IHQgPSBlLmNsb3Nlc3QoYC4ke0YuQ1NTLndyYXBwZXJ9YCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSB0LmNsb3Nlc3QoYC4ke3RoaXMuRWRpdG9yLlVJLkNTUy5lZGl0b3JXcmFwcGVyfWApO1xuICAgIGlmIChvICE9IG51bGwgJiYgby5pc0VxdWFsTm9kZSh0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyKSlcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdGhpcy5fYmxvY2tzLm5vZGVzLmluZGV4T2YodCksIHRoaXMuY3VycmVudEJsb2NrLnVwZGF0ZUN1cnJlbnRJbnB1dCgpLCB0aGlzLmN1cnJlbnRCbG9jaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGJsb2NrIHdoaWNoIGNvbnRlbnRzIHBhc3NlZCBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gY2hpbGROb2RlIC0gbm9kZSB0byBnZXQgQmxvY2sgYnlcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0QmxvY2tCeUNoaWxkTm9kZShlKSB7XG4gICAgZC5pc0VsZW1lbnQoZSkgfHwgKGUgPSBlLnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IHQgPSBlLmNsb3Nlc3QoYC4ke0YuQ1NTLndyYXBwZXJ9YCk7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLmZpbmQoKG8pID0+IG8uaG9sZGVyID09PSB0KTtcbiAgfVxuICAvKipcbiAgICogU3dhcCBCbG9ja3MgUG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIGluZGV4IG9mIGZpcnN0IGJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gaW5kZXggb2Ygc2Vjb25kIGJsb2NrXG4gICAqIEBkZXByZWNhdGVkIOKAlCB1c2UgJ21vdmUnIGluc3RlYWRcbiAgICovXG4gIHN3YXAoZSwgdCkge1xuICAgIHRoaXMuX2Jsb2Nrcy5zd2FwKGUsIHQpLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdDtcbiAgfVxuICAvKipcbiAgICogTW92ZSBhIGJsb2NrIHRvIGEgbmV3IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gaW5kZXggd2hlcmUgdG8gbW92ZSBCbG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggb2YgQmxvY2sgdG8gbW92ZVxuICAgKi9cbiAgbW92ZShlLCB0ID0gdGhpcy5jdXJyZW50QmxvY2tJbmRleCkge1xuICAgIGlmIChpc05hTihlKSB8fCBpc05hTih0KSkge1xuICAgICAgVChcIldhcm5pbmcgZHVyaW5nICdtb3ZlJyBjYWxsOiBpbmNvcnJlY3QgaW5kaWNlcyBwcm92aWRlZC5cIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVJbmRleChlKSB8fCAhdGhpcy52YWxpZGF0ZUluZGV4KHQpKSB7XG4gICAgICBUKFwiV2FybmluZyBkdXJpbmcgJ21vdmUnIGNhbGw6IGluZGljZXMgY2Fubm90IGJlIGxvd2VyIHRoYW4gMCBvciBncmVhdGVyIHRoYW4gdGhlIGFtb3VudCBvZiBibG9ja3MuXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYmxvY2tzLm1vdmUoZSwgdCksIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSBlLCB0aGlzLmJsb2NrRGlkTXV0YXRlZChXbywgdGhpcy5jdXJyZW50QmxvY2ssIHtcbiAgICAgIGZyb21JbmRleDogdCxcbiAgICAgIHRvSW5kZXg6IGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJyZW50IEJsb2NrIEluZGV4IC0xIHdoaWNoIG1lYW5zIHVua25vd25cbiAgICogYW5kIGNsZWFyIGhpZ2hsaWdodHNcbiAgICovXG4gIGRyb3BQb2ludGVyKCkge1xuICAgIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSAtMSwgdGhpcy5jbGVhckZvY3VzZWQoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZWRUb0FkZERlZmF1bHRCbG9jayAtIDEpIGluIGludGVybmFsIGNhbGxzIChmb3IgZXhhbXBsZSwgaW4gYXBpLmJsb2Nrcy5yZW5kZXIpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2UgZG9uJ3QgbmVlZCB0byBhZGQgYW4gZW1wdHkgZGVmYXVsdCBibG9ja1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyKSBpbiBhcGkuYmxvY2tzLmNsZWFyIHdlIHNob3VsZCBhZGQgZW1wdHkgYmxvY2tcbiAgICovXG4gIGNsZWFyKGUgPSAhMSkge1xuICAgIHRoaXMuX2Jsb2Nrcy5yZW1vdmVBbGwoKSwgdGhpcy5kcm9wUG9pbnRlcigpLCBlICYmIHRoaXMuaW5zZXJ0KCksIHRoaXMuRWRpdG9yLlVJLmNoZWNrRW1wdGluZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFucyB1cCBhbGwgdGhlIGJsb2NrIHRvb2xzJyByZXNvdXJjZXNcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBlZGl0b3IgaXMgZGVzdHJveWVkXG4gICAqL1xuICBhc3luYyBkZXN0cm95KCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuYmxvY2tzLm1hcCgoZSkgPT4gZS5kZXN0cm95KCkpKTtcbiAgfVxuICAvKipcbiAgICogQmluZCBCbG9jayBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byB3aGljaCBldmVudCBzaG91bGQgYmUgYm91bmRcbiAgICovXG4gIGJpbmRCbG9ja0V2ZW50cyhlKSB7XG4gICAgY29uc3QgeyBCbG9ja0V2ZW50czogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwia2V5ZG93blwiLCAobykgPT4ge1xuICAgICAgdC5rZXlkb3duKG8pO1xuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLmhvbGRlciwgXCJrZXl1cFwiLCAobykgPT4ge1xuICAgICAgdC5rZXl1cChvKTtcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwiZHJhZ292ZXJcIiwgKG8pID0+IHtcbiAgICAgIHQuZHJhZ092ZXIobyk7XG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUuaG9sZGVyLCBcImRyYWdsZWF2ZVwiLCAobykgPT4ge1xuICAgICAgdC5kcmFnTGVhdmUobyk7XG4gICAgfSksIGUub24oXCJkaWRNdXRhdGVkXCIsIChvKSA9PiB0aGlzLmJsb2NrRGlkTXV0YXRlZChZbywgbywge1xuICAgICAgaW5kZXg6IHRoaXMuZ2V0QmxvY2tJbmRleChvKVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBtdXRhYmxlIGhhbmRsZXJzIGFuZCBiaW5kaW5nc1xuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgYWxsIG1vZHVsZSBoYW5kbGVycyBhbmQgYmluZGluZ3MgZm9yIGFsbCBCbG9ja3NcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBcImN1dFwiLFxuICAgICAgKGUpID0+IHRoaXMuRWRpdG9yLkJsb2NrRXZlbnRzLmhhbmRsZUNvbW1hbmRYKGUpXG4gICAgKSwgdGhpcy5ibG9ja3MuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgdGhpcy5iaW5kQmxvY2tFdmVudHMoZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBnaXZlbiBpbmRleCBpcyBub3QgbG93ZXIgdGhhbiAwIG9yIGhpZ2hlciB0aGFuIHRoZSBhbW91bnQgb2YgYmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIGJsb2NrcyBhcnJheSB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlSW5kZXgoZSkge1xuICAgIHJldHVybiAhKGUgPCAwIHx8IGUgPj0gdGhpcy5fYmxvY2tzLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIG11dGF0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBtdXRhdGlvblR5cGUgLSB3aGF0IGhhcHBlbmVkIHdpdGggYmxvY2tcbiAgICogQHBhcmFtIGJsb2NrIC0gbXV0YXRlZCBibG9ja1xuICAgKiBAcGFyYW0gZGV0YWlsRGF0YSAtIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggY2hhbmdlIGV2ZW50XG4gICAqL1xuICBibG9ja0RpZE11dGF0ZWQoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSBuZXcgQ3VzdG9tRXZlbnQoZSwge1xuICAgICAgZGV0YWlsOiB7XG4gICAgICAgIHRhcmdldDogbmV3IGhlKHQpLFxuICAgICAgICAuLi5vXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KGx0LCB7XG4gICAgICBldmVudDogaVxuICAgIH0pLCB0O1xuICB9XG59XG5jbGFzcyBYbyBleHRlbmRzIFMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IG51bGwsIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgQ29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9XG4gICAqL1xuICBnZXQgc2FuaXRpemVyQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwOiB7fSxcbiAgICAgIGgxOiB7fSxcbiAgICAgIGgyOiB7fSxcbiAgICAgIGgzOiB7fSxcbiAgICAgIGg0OiB7fSxcbiAgICAgIGg1OiB7fSxcbiAgICAgIGg2OiB7fSxcbiAgICAgIG9sOiB7fSxcbiAgICAgIHVsOiB7fSxcbiAgICAgIGxpOiB7fSxcbiAgICAgIGJyOiAhMCxcbiAgICAgIGltZzoge1xuICAgICAgICBzcmM6ICEwLFxuICAgICAgICB3aWR0aDogITAsXG4gICAgICAgIGhlaWdodDogITBcbiAgICAgIH0sXG4gICAgICBhOiB7XG4gICAgICAgIGhyZWY6ICEwXG4gICAgICB9LFxuICAgICAgYjoge30sXG4gICAgICBpOiB7fSxcbiAgICAgIHU6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmxhZyB0aGF0IGlkZW50aWZpZXMgYWxsIEJsb2NrcyBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWxsQmxvY2tzU2VsZWN0ZWQoKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHJldHVybiBlLmJsb2Nrcy5ldmVyeSgodCkgPT4gdC5zZWxlY3RlZCA9PT0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgYWxsIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gc3RhdGUgdG8gc2V0XG4gICAqL1xuICBzZXQgYWxsQmxvY2tzU2VsZWN0ZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmJsb2Nrcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBvLnNlbGVjdGVkID0gZTtcbiAgICB9KSwgdGhpcy5jbGVhckNhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZsYWcgdGhhdCBpZGVudGlmaWVzIGFueSBCbG9jayBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYW55QmxvY2tTZWxlY3RlZCgpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgcmV0dXJuIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID09PSBudWxsICYmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IGUuYmxvY2tzLnNvbWUoKHQpID0+IHQuc2VsZWN0ZWQgPT09ICEwKSksIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gc2VsZWN0ZWQgQmxvY2tzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkQmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmZpbHRlcigoZSkgPT4gZS5zZWxlY3RlZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBQcmVwYXJhdGlvblxuICAgKiBSZWdpc3RlcnMgU2hvcnRjdXRzIENNRCtBIGFuZCBDTUQrQ1xuICAgKiB0byBzZWxlY3QgYWxsIGFuZCBjb3B5IHRoZW1cbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgbSgpLCByZS5hZGQoe1xuICAgICAgbmFtZTogXCJDTUQrQVwiLFxuICAgICAgaGFuZGxlcjogKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIFJlYWRPbmx5OiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgICAgaWYgKG8uaXNFbmFibGVkKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEFsbEJsb2NrcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0LmN1cnJlbnRCbG9jayAmJiB0aGlzLmhhbmRsZUNvbW1hbmRBKGUpO1xuICAgICAgfSxcbiAgICAgIG9uOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqICAtIFJlbW92ZSBhbGwgcmFuZ2VzXG4gICAqICAtIFVuc2VsZWN0IGFsbCBCbG9ja3NcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KCkge1xuICAgIG0uZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIHRoaXMuYWxsQmxvY2tzU2VsZWN0ZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGlvbiBvZiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4IC0gQmxvY2sgaW5kZXggYWNjb3JkaW5nIHRvIHRoZSBCbG9ja01hbmFnZXIncyBpbmRleGVzXG4gICAqL1xuICB1blNlbGVjdEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBvO1xuICAgIGlzTmFOKGUpID8gbyA9IHQuY3VycmVudEJsb2NrIDogbyA9IHQuZ2V0QmxvY2tCeUluZGV4KGUpLCBvLnNlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBzZWxlY3Rpb24gZnJvbSBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gcmVhc29uIC0gZXZlbnQgY2F1c2VkIGNsZWFyIG9mIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3RvcmVTZWxlY3Rpb24gLSBpZiB0cnVlLCByZXN0b3JlIHNhdmVkIHNlbGVjdGlvblxuICAgKi9cbiAgY2xlYXJTZWxlY3Rpb24oZSwgdCA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpLCBSZWN0YW5nbGVTZWxlY3Rpb246IG4gfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICAgIGNvbnN0IHIgPSBlICYmIGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50LCBhID0gciAmJiB0dChlLmtleUNvZGUpO1xuICAgIGlmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWQgJiYgciAmJiBhICYmICFtLmlzU2VsZWN0aW9uRXhpc3RzKSB7XG4gICAgICBjb25zdCBsID0gby5yZW1vdmVTZWxlY3RlZEJsb2NrcygpO1xuICAgICAgby5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KGwsICEwKSwgaS5zZXRUb0Jsb2NrKG8uY3VycmVudEJsb2NrKSwgb2UoKCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gZS5rZXk7XG4gICAgICAgIGkuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihjLmxlbmd0aCA+IDEgPyBcIlwiIDogYyk7XG4gICAgICB9LCAyMCkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24uY2xlYXIoZSksICF0aGlzLmFueUJsb2NrU2VsZWN0ZWQgfHwgbi5pc1JlY3RBY3RpdmF0ZWQoKSkge1xuICAgICAgdGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgJiYgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLmFsbEJsb2Nrc1NlbGVjdGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFJlZHVjZSBlYWNoIEJsb2NrIGFuZCBjb3B5IGl0cyBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGUgLSBjb3B5L2N1dCBldmVudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGNvcHlTZWxlY3RlZEJsb2NrcyhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgdGhpcy5zZWxlY3RlZEJsb2Nrcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCByID0gWihuLmhvbGRlci5pbm5lckhUTUwsIHRoaXMuc2FuaXRpemVyQ29uZmlnKSwgYSA9IGQubWFrZShcInBcIik7XG4gICAgICBhLmlubmVySFRNTCA9IHIsIHQuYXBwZW5kQ2hpbGQoYSk7XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IEFycmF5LmZyb20odC5jaGlsZE5vZGVzKS5tYXAoKG4pID0+IG4udGV4dENvbnRlbnQpLmpvaW4oYFxuXG5gKSwgaSA9IHQuaW5uZXJIVE1MO1xuICAgIHJldHVybiBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgbyksIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGkpLCBQcm9taXNlLmFsbCh0aGlzLnNlbGVjdGVkQmxvY2tzLm1hcCgobikgPT4gbi5zYXZlKCkpKS50aGVuKChuKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSh0aGlzLkVkaXRvci5QYXN0ZS5NSU1FX1RZUEUsIEpTT04uc3RyaW5naWZ5KG4pKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBzZWxlY3QgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXI/fSBpbmRleCAtIEJsb2NrIGluZGV4IGFjY29yZGluZyB0byB0aGUgQmxvY2tNYW5hZ2VyJ3MgaW5kZXhlc1xuICAgKi9cbiAgc2VsZWN0QmxvY2tCeUluZGV4KGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdC5jbGVhckZvY3VzZWQoKTtcbiAgICBsZXQgbztcbiAgICBpc05hTihlKSA/IG8gPSB0LmN1cnJlbnRCbG9jayA6IG8gPSB0LmdldEJsb2NrQnlJbmRleChlKSwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpLCBtLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpLCBvLnNlbGVjdGVkID0gITAsIHRoaXMuY2xlYXJDYWNoZSgpLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGFueUJsb2NrU2VsZWN0ZWQgY2FjaGVcbiAgICovXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5hbnlCbG9ja1NlbGVjdGVkQ2FjaGUgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGUgZGVzdHJ1Y3Rpb25cbiAgICogRGUtcmVnaXN0ZXJzIFNob3J0Y3V0IENNRCtBXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHJlLnJlbW92ZSh0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvciwgXCJDTUQrQVwiKTtcbiAgfVxuICAvKipcbiAgICogRmlyc3QgQ01EK0Egc2VsZWN0cyBhbGwgaW5wdXQgY29udGVudCBieSBuYXRpdmUgYmVoYXZpb3VyLFxuICAgKiBuZXh0IENNRCtBIGtleXByZXNzIHNlbGVjdHMgYWxsIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGhhbmRsZUNvbW1hbmRBKGUpIHtcbiAgICBpZiAodGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCksIGQuaXNOYXRpdmVJbnB1dChlLnRhcmdldCkgJiYgIXRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrKGUudGFyZ2V0KS5pbnB1dHM7XG4gICAgaWYgKG8ubGVuZ3RoID4gMSAmJiAhdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5uZWVkVG9TZWxlY3RBbGwpIHtcbiAgICAgIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubmVlZFRvU2VsZWN0QWxsID8gKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5zZWxlY3RBbGxCbG9ja3MoKSwgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPSAhMSwgdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gPSAhMSwgdGhpcy5FZGl0b3IuQ29udmVyc2lvblRvb2xiYXIuY2xvc2UoKSkgOiB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEJsb2NrQnlJbmRleCgpLCB0aGlzLm5lZWRUb1NlbGVjdEFsbCA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IEFsbCBCbG9ja3NcbiAgICogRWFjaCBCbG9jayBoYXMgc2VsZWN0ZWQgc2V0dGVyIHRoYXQgbWFrZXMgQmxvY2sgY29weWFibGVcbiAgICovXG4gIHNlbGVjdEFsbEJsb2NrcygpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5zYXZlKCksIG0uZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIHRoaXMuYWxsQmxvY2tzU2VsZWN0ZWQgPSAhMCwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG59XG5jbGFzcyB2ZSBleHRlbmRzIFMge1xuICAvKipcbiAgICogQWxsb3dlZCBjYXJldCBwb3NpdGlvbnMgaW4gaW5wdXRcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcmV0dXJucyB7e1NUQVJUOiBzdHJpbmcsIEVORDogc3RyaW5nLCBERUZBVUxUOiBzdHJpbmd9fVxuICAgKi9cbiAgZ2V0IHBvc2l0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgU1RBUlQ6IFwic3RhcnRcIixcbiAgICAgIEVORDogXCJlbmRcIixcbiAgICAgIERFRkFVTFQ6IFwiZGVmYXVsdFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRWxlbWVudHMgc3R5bGVzIHRoYXQgY2FuIGJlIHVzZWZ1bCBmb3IgQ2FyZXQgTW9kdWxlXG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hhZG93Q2FyZXQ6IFwiY2R4LXNoYWRvdy1jYXJldFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0J3MgZGVlcGVzdCBmaXJzdCBub2RlIGFuZCBjaGVja3MgaWYgb2Zmc2V0IGlzIHplcm9cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNBdFN0YXJ0KCkge1xuICAgIGNvbnN0IGUgPSBtLmdldCgpLCB0ID0gZC5nZXREZWVwZXN0Tm9kZSh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLmN1cnJlbnRJbnB1dCk7XG4gICAgbGV0IG8gPSBlLmZvY3VzTm9kZTtcbiAgICBpZiAoZC5pc05hdGl2ZUlucHV0KHQpKVxuICAgICAgcmV0dXJuIHQuc2VsZWN0aW9uRW5kID09PSAwO1xuICAgIGlmICghZS5hbmNob3JOb2RlKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBpID0gby50ZXh0Q29udGVudC5zZWFyY2goL1xcUy8pO1xuICAgIGkgPT09IC0xICYmIChpID0gMCk7XG4gICAgbGV0IG4gPSBlLmZvY3VzT2Zmc2V0O1xuICAgIHJldHVybiBvLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBvLmNoaWxkTm9kZXMubGVuZ3RoICYmIChvLmNoaWxkTm9kZXNbbl0gPyAobyA9IG8uY2hpbGROb2Rlc1tuXSwgbiA9IDApIDogKG8gPSBvLmNoaWxkTm9kZXNbbiAtIDFdLCBuID0gby50ZXh0Q29udGVudC5sZW5ndGgpKSwgKGQuaXNMaW5lQnJlYWtUYWcodCkgfHwgZC5pc0VtcHR5KHQpKSAmJiB0aGlzLmdldEhpZ2hlckxldmVsU2libGluZ3MobywgXCJsZWZ0XCIpLmV2ZXJ5KChsKSA9PiB7XG4gICAgICBjb25zdCBjID0gZC5pc0xpbmVCcmVha1RhZyhsKSwgdSA9IGwuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGQuaXNMaW5lQnJlYWtUYWcobC5jaGlsZHJlblswXSksIGggPSBjIHx8IHU7XG4gICAgICByZXR1cm4gZC5pc0VtcHR5KGwpICYmICFoO1xuICAgIH0pICYmIG4gPT09IGkgPyAhMCA6IHQgPT09IG51bGwgfHwgbyA9PT0gdCAmJiBuIDw9IGk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCdzIGRlZXBlc3QgbGFzdCBub2RlIGFuZCBjaGVja3MgaWYgb2Zmc2V0IGlzIGxhc3Qgbm9kZSB0ZXh0IGxlbmd0aFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0F0RW5kKCkge1xuICAgIGNvbnN0IGUgPSBtLmdldCgpO1xuICAgIGxldCB0ID0gZS5mb2N1c05vZGU7XG4gICAgY29uc3QgbyA9IGQuZ2V0RGVlcGVzdE5vZGUodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay5jdXJyZW50SW5wdXQsICEwKTtcbiAgICBpZiAoZC5pc05hdGl2ZUlucHV0KG8pKVxuICAgICAgcmV0dXJuIG8uc2VsZWN0aW9uRW5kID09PSBvLnZhbHVlLmxlbmd0aDtcbiAgICBpZiAoIWUuZm9jdXNOb2RlKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBpID0gZS5mb2N1c09mZnNldDtcbiAgICBpZiAodC5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUgJiYgdC5jaGlsZE5vZGVzLmxlbmd0aCAmJiAodC5jaGlsZE5vZGVzW2kgLSAxXSA/ICh0ID0gdC5jaGlsZE5vZGVzW2kgLSAxXSwgaSA9IHQudGV4dENvbnRlbnQubGVuZ3RoKSA6ICh0ID0gdC5jaGlsZE5vZGVzWzBdLCBpID0gMCkpLCBkLmlzTGluZUJyZWFrVGFnKG8pIHx8IGQuaXNFbXB0eShvKSkge1xuICAgICAgY29uc3QgciA9IHRoaXMuZ2V0SGlnaGVyTGV2ZWxTaWJsaW5ncyh0LCBcInJpZ2h0XCIpO1xuICAgICAgaWYgKHIuZXZlcnkoKGwsIGMpID0+IGMgPT09IHIubGVuZ3RoIC0gMSAmJiBkLmlzTGluZUJyZWFrVGFnKGwpIHx8IGQuaXNFbXB0eShsKSAmJiAhZC5pc0xpbmVCcmVha1RhZyhsKSkgJiYgaSA9PT0gdC50ZXh0Q29udGVudC5sZW5ndGgpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgY29uc3QgbiA9IG8udGV4dENvbnRlbnQucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgICByZXR1cm4gdCA9PT0gbyAmJiBpID49IG4ubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgZ2V0cyBCbG9jayBpbnN0YW5jZSBhbmQgcHV0cyBjYXJldCB0byB0aGUgdGV4dCBub2RlIHdpdGggb2Zmc2V0XG4gICAqIFRoZXJlIHR3byB3YXlzIHRoYXQgbWV0aG9kIGFwcGxpZXMgY2FyZXQgcG9zaXRpb246XG4gICAqICAgLSBmaXJzdCBmb3VuZCB0ZXh0IG5vZGU6IHNldHMgYXQgdGhlIGJlZ2lubmluZywgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXRcbiAgICogICAtIGxhc3QgZm91bmQgdGV4dCBub2RlOiBzZXRzIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUuIEFsc28sIHlvdSBjYW4gY3VzdG9taXplIHRoZSBiZWhhdmlvdXJcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayBjbGFzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiB3aGVyZSB0byBzZXQgY2FyZXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGRlZmF1bHQgLSBsZWF2ZSBkZWZhdWx0IGJlaGF2aW91ciBhbmQgYXBwbHkgb2Zmc2V0IGlmIGl0J3MgcGFzc2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBjYXJldCBvZmZzZXQgcmVnYXJkaW5nIHRvIHRoZSB0ZXh0IG5vZGVcbiAgICovXG4gIHNldFRvQmxvY2soZSwgdCA9IHRoaXMucG9zaXRpb25zLkRFRkFVTFQsIG8gPSAwKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBuO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSB0aGlzLnBvc2l0aW9ucy5TVEFSVDpcbiAgICAgICAgbiA9IGUuZmlyc3RJbnB1dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLkVORDpcbiAgICAgICAgbiA9IGUubGFzdElucHV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG4gPSBlLmN1cnJlbnRJbnB1dDtcbiAgICB9XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBkLmdldERlZXBlc3ROb2RlKG4sIHQgPT09IHRoaXMucG9zaXRpb25zLkVORCksIGEgPSBkLmdldENvbnRlbnRMZW5ndGgocik7XG4gICAgc3dpdGNoICghMCkge1xuICAgICAgY2FzZSB0ID09PSB0aGlzLnBvc2l0aW9ucy5TVEFSVDpcbiAgICAgICAgbyA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0ID09PSB0aGlzLnBvc2l0aW9ucy5FTkQ6XG4gICAgICBjYXNlIG8gPiBhOlxuICAgICAgICBvID0gYTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9lKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0KHIsIG8pO1xuICAgIH0sIDIwKSgpLCBpLnNldEN1cnJlbnRCbG9ja0J5Q2hpbGROb2RlKGUuaG9sZGVyKSwgaS5jdXJyZW50QmxvY2suY3VycmVudElucHV0ID0gbjtcbiAgfVxuICAvKipcbiAgICogU2V0IGNhcmV0IHRvIHRoZSBjdXJyZW50IGlucHV0IG9mIGN1cnJlbnQgQmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IC0gaW5wdXQgd2hlcmUgY2FyZXQgc2hvdWxkIGJlIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGRlZmF1bHQgLSBsZWF2ZSBkZWZhdWx0IGJlaGF2aW91ciBhbmQgYXBwbHkgb2Zmc2V0IGlmIGl0J3MgcGFzc2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBjYXJldCBvZmZzZXQgcmVnYXJkaW5nIHRvIHRoZSB0ZXh0IG5vZGVcbiAgICovXG4gIHNldFRvSW5wdXQoZSwgdCA9IHRoaXMucG9zaXRpb25zLkRFRkFVTFQsIG8gPSAwKSB7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IGkgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlciwgbiA9IGQuZ2V0RGVlcGVzdE5vZGUoZSk7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLlNUQVJUOlxuICAgICAgICB0aGlzLnNldChuLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLkVORDpcbiAgICAgICAgdGhpcy5zZXQobiwgZC5nZXRDb250ZW50TGVuZ3RoKG4pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvICYmIHRoaXMuc2V0KG4sIG8pO1xuICAgIH1cbiAgICBpLmN1cnJlbnRJbnB1dCA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgRG9jdW1lbnQgUmFuZ2UgYW5kIHNldHMgY2FyZXQgdG8gdGhlIGVsZW1lbnQgd2l0aCBvZmZzZXRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0XG4gICAqL1xuICBzZXQoZSwgdCA9IDApIHtcbiAgICBjb25zdCB7IHRvcDogbywgYm90dG9tOiBpIH0gPSBtLnNldEN1cnNvcihlLCB0KSwgeyBpbm5lckhlaWdodDogbiB9ID0gd2luZG93O1xuICAgIG8gPCAwICYmIHdpbmRvdy5zY3JvbGxCeSgwLCBvKSwgaSA+IG4gJiYgd2luZG93LnNjcm9sbEJ5KDAsIGkgLSBuKTtcbiAgfVxuICAvKipcbiAgICogU2V0IENhcmV0IHRvIHRoZSBsYXN0IEJsb2NrXG4gICAqIElmIGxhc3QgYmxvY2sgaXMgbm90IGVtcHR5LCBhcHBlbmQgYW5vdGhlciBlbXB0eSBibG9ja1xuICAgKi9cbiAgc2V0VG9UaGVMYXN0QmxvY2soKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2s7XG4gICAgaWYgKGUpXG4gICAgICBpZiAoZS50b29sLmlzRGVmYXVsdCAmJiBlLmlzRW1wdHkpXG4gICAgICAgIHRoaXMuc2V0VG9CbG9jayhlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydEF0RW5kKCk7XG4gICAgICAgIHRoaXMuc2V0VG9CbG9jayh0KTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBjb250ZW50IGZyYWdtZW50IG9mIGN1cnJlbnQgQmxvY2sgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBCbG9ja1xuICAgKi9cbiAgZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgZSA9IG0uZ2V0KCk7XG4gICAgaWYgKGUucmFuZ2VDb3VudCkge1xuICAgICAgY29uc3QgdCA9IGUuZ2V0UmFuZ2VBdCgwKSwgbyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2suY3VycmVudElucHV0O1xuICAgICAgaWYgKHQuZGVsZXRlQ29udGVudHMoKSwgbylcbiAgICAgICAgaWYgKGQuaXNOYXRpdmVJbnB1dChvKSkge1xuICAgICAgICAgIGNvbnN0IGkgPSBvLCBuID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCByID0gaS52YWx1ZS5zdWJzdHJpbmcoMCwgaS5zZWxlY3Rpb25TdGFydCksIGEgPSBpLnZhbHVlLnN1YnN0cmluZyhpLnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICByZXR1cm4gbi50ZXh0Q29udGVudCA9IGEsIGkudmFsdWUgPSByLCBuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGkgPSB0LmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICByZXR1cm4gaS5zZWxlY3ROb2RlQ29udGVudHMobyksIGkuc2V0U3RhcnQodC5lbmRDb250YWluZXIsIHQuZW5kT2Zmc2V0KSwgaS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0J3MgY2FyZXQgdG8gdGhlIG5leHQgQmxvY2sgb3IgVG9vbGBzIGlucHV0XG4gICAqIEJlZm9yZSBtb3ZpbmcgY2FyZXQsIHdlIHNob3VsZCBjaGVjayBpZiBjYXJldCBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIFBsdWdpbnMgbm9kZVxuICAgKiBVc2luZyB7QGxpbmsgRG9tI2dldERlZXBlc3ROb2RlfSB0byBnZXQgYSBsYXN0IG5vZGUgYW5kIG1hdGNoIHdpdGggY3VycmVudCBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBuYXZpZ2F0ZU5leHQoKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogdCwgbmV4dENvbnRlbnRmdWxCbG9jazogbyB9ID0gZSwgeyBuZXh0SW5wdXQ6IGkgfSA9IHQsIG4gPSB0aGlzLmlzQXRFbmQ7XG4gICAgbGV0IHIgPSBvO1xuICAgIGlmICghciAmJiAhaSkge1xuICAgICAgaWYgKHQudG9vbC5pc0RlZmF1bHQgfHwgIW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIHIgPSBlLmluc2VydEF0RW5kKCk7XG4gICAgfVxuICAgIHJldHVybiBuID8gKGkgPyB0aGlzLnNldFRvSW5wdXQoaSwgdGhpcy5wb3NpdGlvbnMuU1RBUlQpIDogdGhpcy5zZXRUb0Jsb2NrKHIsIHRoaXMucG9zaXRpb25zLlNUQVJUKSwgITApIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIFNldCdzIGNhcmV0IHRvIHRoZSBwcmV2aW91cyBUb29sYHMgaW5wdXQgb3IgQmxvY2tcbiAgICogQmVmb3JlIG1vdmluZyBjYXJldCwgd2Ugc2hvdWxkIGNoZWNrIGlmIGNhcmV0IHBvc2l0aW9uIGlzIHN0YXJ0IG9mIHRoZSBQbHVnaW5zIG5vZGVcbiAgICogVXNpbmcge0BsaW5rIERvbSNnZXREZWVwZXN0Tm9kZX0gdG8gZ2V0IGEgbGFzdCBub2RlIGFuZCBtYXRjaCB3aXRoIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgbmF2aWdhdGVQcmV2aW91cygpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogZSwgcHJldmlvdXNDb250ZW50ZnVsQmxvY2s6IHQgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlcjtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgeyBwcmV2aW91c0lucHV0OiBvIH0gPSBlO1xuICAgIHJldHVybiAhdCAmJiAhbyA/ICExIDogdGhpcy5pc0F0U3RhcnQgPyAobyA/IHRoaXMuc2V0VG9JbnB1dChvLCB0aGlzLnBvc2l0aW9ucy5FTkQpIDogdGhpcy5zZXRUb0Jsb2NrKHQsIHRoaXMucG9zaXRpb25zLkVORCksICEwKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHNoYWRvdyBlbGVtZW50IGFmdGVyIHBhc3NlZCBlbGVtZW50IHdoZXJlIGNhcmV0IGNhbiBiZSBwbGFjZWRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCBhZnRlciB3aGljaCBzaGFkb3cgY2FyZXQgc2hvdWxkIGJlIGluc2VydGVkXG4gICAqL1xuICBjcmVhdGVTaGFkb3coZSkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICB0LmNsYXNzTGlzdC5hZGQodmUuQ1NTLnNoYWRvd0NhcmV0KSwgZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJiZWZvcmVlbmRcIiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmVzIGNhcmV0IHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHdoZXJlIGNhcmV0IHNob3VsZCBiZSByZXN0b3JlZFxuICAgKi9cbiAgcmVzdG9yZUNhcmV0KGUpIHtcbiAgICBjb25zdCB0ID0gZS5xdWVyeVNlbGVjdG9yKGAuJHt2ZS5DU1Muc2hhZG93Q2FyZXR9YCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIG5ldyBtKCkuZXhwYW5kVG9UYWcodCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBpLnNlbGVjdE5vZGUodCksIGkuZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgfSwgNTApO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHBhc3NlZCBjb250ZW50IGF0IGNhcmV0IHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IC0gY29udGVudCB0byBpbnNlcnRcbiAgICovXG4gIGluc2VydENvbnRlbnRBdENhcmV0UG9zaXRpb24oZSkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBpID0gbS5nZXQoKSwgbiA9IG0ucmFuZ2U7XG4gICAgby5pbm5lckhUTUwgPSBlLCBBcnJheS5mcm9tKG8uY2hpbGROb2RlcykuZm9yRWFjaCgobCkgPT4gdC5hcHBlbmRDaGlsZChsKSksIHQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgJiYgdC5hcHBlbmRDaGlsZChuZXcgVGV4dCgpKTtcbiAgICBjb25zdCByID0gdC5sYXN0Q2hpbGQ7XG4gICAgbi5kZWxldGVDb250ZW50cygpLCBuLmluc2VydE5vZGUodCk7XG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgYS5zZXRTdGFydChyLCByLnRleHRDb250ZW50Lmxlbmd0aCksIGkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuYWRkUmFuZ2UoYSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgZmlyc3QtbGV2ZWwgKGZpcnN0IGNoaWxkIG9mIFtjb250ZW50ZWRpdGFibGVdKSBzaWJsaW5ncyBmcm9tIHBhc3NlZCBub2RlXG4gICAqIFRoZW4geW91IGNhbiBjaGVjayBpdCBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIDxkaXYgY29udGVudGVkaXRhYmxlPlxuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxlZnQgZmlyc3QtbGV2ZWwgc2libGluZ3NcbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxibG9ja3F1b3RlPjxhPjxiPmFkYWRkYWQ8L2I+PGE+PGJsb2NrcXVvdGU+ICAgICAgIDwtLSBwYXNzZWQgbm9kZSBmb3IgZXhhbXBsZSA8Yj5cbiAgICogPHA+PC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqIDxwPjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCByaWdodCBmaXJzdC1sZXZlbCBzaWJsaW5nc1xuICAgKiA8cD48L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICogPC9kaXY+XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZyb20gLSBlbGVtZW50IGZyb20gd2hpY2ggc2libGluZ3Mgc2hvdWxkIGJlIHNlYXJjaGVkXG4gICAqIEBwYXJhbSB7J2xlZnQnIHwgJ3JpZ2h0J30gZGlyZWN0aW9uIC0gZGlyZWN0aW9uIG9mIHNlYXJjaFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAgICovXG4gIGdldEhpZ2hlckxldmVsU2libGluZ3MoZSwgdCkge1xuICAgIGxldCBvID0gZTtcbiAgICBjb25zdCBpID0gW107XG4gICAgZm9yICg7IG8ucGFyZW50Tm9kZSAmJiBvLnBhcmVudE5vZGUuY29udGVudEVkaXRhYmxlICE9PSBcInRydWVcIjsgKVxuICAgICAgbyA9IG8ucGFyZW50Tm9kZTtcbiAgICBjb25zdCBuID0gdCA9PT0gXCJsZWZ0XCIgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICAgIGZvciAoOyBvW25dOyApXG4gICAgICBvID0gb1tuXSwgaS5wdXNoKG8pO1xuICAgIHJldHVybiBpO1xuICB9XG59XG5jbGFzcyBWbyBleHRlbmRzIFMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLm9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLm9mZihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdGhpcy5vbk1vdXNlT3ZlciksIHRoaXMubGlzdGVuZXJzLm9mZihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKTtcbiAgICB9LCB0aGlzLm9uTW91c2VPdmVyID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSB0LmdldEJsb2NrQnlDaGlsZE5vZGUoZS5yZWxhdGVkVGFyZ2V0KSB8fCB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrLCBuID0gdC5nZXRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgIGlmICghKCFpIHx8ICFuKSAmJiBuICE9PSBpKSB7XG4gICAgICAgIGlmIChpID09PSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jaykge1xuICAgICAgICAgIG0uZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuc2VsZWN0ZWQgPSAhMCwgbi5zZWxlY3RlZCA9ICEwLCBvLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT09IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrKSB7XG4gICAgICAgICAgaS5zZWxlY3RlZCA9ICExLCBuLnNlbGVjdGVkID0gITEsIG8uY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCksIHRoaXMudG9nZ2xlQmxvY2tzU2VsZWN0ZWRTdGF0ZShpLCBuKSwgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IG47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIHByZXBhcmF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZW5hYmxlQ3Jvc3NCbG9ja1NlbGVjdGlvbihlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB1cCBsaXN0ZW5lcnNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIG1vdXNlIGRvd24gZXZlbnRcbiAgICovXG4gIHdhdGNoU2VsZWN0aW9uKGUpIHtcbiAgICBpZiAoZS5idXR0b24gIT09IF90LkxFRlQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID0gdC5nZXRCbG9jayhlLnRhcmdldCksIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jaywgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHRoaXMub25Nb3VzZU92ZXIpLCB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKTtcbiAgfVxuICAvKipcbiAgICogcmV0dXJuIGJvb2xlYW4gaXMgY3Jvc3MgYmxvY2sgc2VsZWN0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIGdldCBpc0Nyb3NzQmxvY2tTZWxlY3Rpb25TdGFydGVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrICYmICEhdGhpcy5sYXN0U2VsZWN0ZWRCbG9jaztcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIHNlbGVjdGlvbiBzdGF0ZSBvZiB0aGUgbmV4dCBCbG9ja1xuICAgKiBVc2VkIGZvciBDQlMgdmlhIFNoaWZ0ICsgYXJyb3cga2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5leHQgLSBpZiB0cnVlLCB0b2dnbGUgbmV4dCBibG9jay4gUHJldmlvdXMgb3RoZXJ3aXNlXG4gICAqL1xuICB0b2dnbGVCbG9ja1NlbGVjdGVkU3RhdGUoZSA9ICEwKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrIHx8ICh0aGlzLmxhc3RTZWxlY3RlZEJsb2NrID0gdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgPSB0LmN1cnJlbnRCbG9jayksIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID09PSB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrICYmICh0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jay5zZWxlY3RlZCA9ICEwLCBvLmNsZWFyQ2FjaGUoKSwgbS5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSk7XG4gICAgY29uc3QgaSA9IHQuYmxvY2tzLmluZGV4T2YodGhpcy5sYXN0U2VsZWN0ZWRCbG9jaykgKyAoZSA/IDEgOiAtMSksIG4gPSB0LmJsb2Nrc1tpXTtcbiAgICBuICYmICh0aGlzLmxhc3RTZWxlY3RlZEJsb2NrLnNlbGVjdGVkICE9PSBuLnNlbGVjdGVkID8gKG4uc2VsZWN0ZWQgPSAhMCwgby5jbGVhckNhY2hlKCkpIDogKHRoaXMubGFzdFNlbGVjdGVkQmxvY2suc2VsZWN0ZWQgPSAhMSwgby5jbGVhckNhY2hlKCkpLCB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrID0gbiwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpLCBuLmhvbGRlci5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIHNhdmVkIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IHJlYXNvbiAtIGV2ZW50IGNhdXNlZCBjbGVhciBvZiBzZWxlY3Rpb25cbiAgICovXG4gIGNsZWFyKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQmxvY2tTZWxlY3Rpb246IG8sIENhcmV0OiBpIH0gPSB0aGlzLkVkaXRvciwgbiA9IHQuYmxvY2tzLmluZGV4T2YodGhpcy5maXJzdFNlbGVjdGVkQmxvY2spLCByID0gdC5ibG9ja3MuaW5kZXhPZih0aGlzLmxhc3RTZWxlY3RlZEJsb2NrKTtcbiAgICBpZiAoby5hbnlCbG9ja1NlbGVjdGVkICYmIG4gPiAtMSAmJiByID4gLTEpXG4gICAgICBpZiAoZSAmJiBlIGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudClcbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIEIuRE9XTjpcbiAgICAgICAgICBjYXNlIEIuUklHSFQ6XG4gICAgICAgICAgICBpLnNldFRvQmxvY2sodC5ibG9ja3NbTWF0aC5tYXgobiwgcildLCBpLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBCLlVQOlxuICAgICAgICAgIGNhc2UgQi5MRUZUOlxuICAgICAgICAgICAgaS5zZXRUb0Jsb2NrKHQuYmxvY2tzW01hdGgubWluKG4sIHIpXSwgaS5wb3NpdGlvbnMuU1RBUlQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGkuc2V0VG9CbG9jayh0LmJsb2Nrc1tNYXRoLm1heChuLCByKV0sIGkucG9zaXRpb25zLkVORCk7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaS5zZXRUb0Jsb2NrKHQuYmxvY2tzW01hdGgubWF4KG4sIHIpXSwgaS5wb3NpdGlvbnMuRU5EKTtcbiAgICB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayA9IHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIENyb3NzIEJsb2NrIFNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gbW91c2UgZG93biBldmVudFxuICAgKi9cbiAgZW5hYmxlQ3Jvc3NCbG9ja1NlbGVjdGlvbihlKSB7XG4gICAgY29uc3QgeyBVSTogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgbS5pc0NvbGxhcHNlZCB8fCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKSwgdC5ub2Rlcy5yZWRhY3Rvci5jb250YWlucyhlLnRhcmdldCkgPyB0aGlzLndhdGNoU2VsZWN0aW9uKGUpIDogdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZSBibG9ja3Mgc2VsZWN0aW9uIHN0YXRlIGJldHdlZW4gcGFzc2VkIHR3byBibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGZpcnN0QmxvY2sgLSBmaXJzdCBibG9jayBpbiByYW5nZVxuICAgKiBAcGFyYW0ge0Jsb2NrfSBsYXN0QmxvY2sgLSBsYXN0IGJsb2NrIGluIHJhbmdlXG4gICAqL1xuICB0b2dnbGVCbG9ja3NTZWxlY3RlZFN0YXRlKGUsIHQpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogbywgQmxvY2tTZWxlY3Rpb246IGkgfSA9IHRoaXMuRWRpdG9yLCBuID0gby5ibG9ja3MuaW5kZXhPZihlKSwgciA9IG8uYmxvY2tzLmluZGV4T2YodCksIGEgPSBlLnNlbGVjdGVkICE9PSB0LnNlbGVjdGVkO1xuICAgIGZvciAobGV0IGwgPSBNYXRoLm1pbihuLCByKTsgbCA8PSBNYXRoLm1heChuLCByKTsgbCsrKSB7XG4gICAgICBjb25zdCBjID0gby5ibG9ja3NbbF07XG4gICAgICBjICE9PSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayAmJiBjICE9PSAoYSA/IGUgOiB0KSAmJiAoby5ibG9ja3NbbF0uc2VsZWN0ZWQgPSAhby5ibG9ja3NbbF0uc2VsZWN0ZWQsIGkuY2xlYXJDYWNoZSgpKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFpvIGV4dGVuZHMgUyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuaXNTdGFydGVkQXRFZGl0b3IgPSAhMTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIHJlYWQtb25seSBzdGF0ZVxuICAgKlxuICAgKiBpZiBzdGF0ZSBpcyB0cnVlOlxuICAgKiAgLSBkaXNhYmxlIGFsbCBkcmFnLW4tZHJvcCBldmVudCBoYW5kbGVyc1xuICAgKlxuICAgKiBpZiBzdGF0ZSBpcyBmYWxzZTpcbiAgICogIC0gcmVzdG9yZSBkcmFnLW4tZHJvcCBldmVudCBoYW5kbGVyc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5RW5hYmxlZCAtIFwicmVhZCBvbmx5XCIgc3RhdGVcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KGUpIHtcbiAgICBlID8gdGhpcy5kaXNhYmxlTW9kdWxlQmluZGluZ3MoKSA6IHRoaXMuZW5hYmxlTW9kdWxlQmluZGluZ3MoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGRyYWcgZXZlbnRzIGxpc3RlbmVycyB0byBlZGl0b3Igem9uZVxuICAgKi9cbiAgZW5hYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgY29uc3QgeyBVSTogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ub2Rlcy5ob2xkZXIsIFwiZHJvcFwiLCBhc3luYyAodCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRHJvcCh0KTtcbiAgICB9LCAhMCksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUubm9kZXMuaG9sZGVyLCBcImRyYWdzdGFydFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NEcmFnU3RhcnQoKTtcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ub2Rlcy5ob2xkZXIsIFwiZHJhZ292ZXJcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc0RyYWdPdmVyKHQpO1xuICAgIH0sICEwKTtcbiAgfVxuICAvKipcbiAgICogVW5iaW5kIGRyYWctbi1kcm9wIGV2ZW50IGhhbmRsZXJzXG4gICAqL1xuICBkaXNhYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMuY2xlYXJBbGwoKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGRyb3AgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtEcmFnRXZlbnR9IGRyb3BFdmVudCAtIGRyb3AgZXZlbnRcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NEcm9wKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBCbG9ja01hbmFnZXI6IHQsXG4gICAgICBDYXJldDogbyxcbiAgICAgIFBhc3RlOiBpXG4gICAgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGUucHJldmVudERlZmF1bHQoKSwgdC5ibG9ja3MuZm9yRWFjaCgocikgPT4ge1xuICAgICAgci5kcm9wVGFyZ2V0ID0gITE7XG4gICAgfSksIG0uaXNBdEVkaXRvciAmJiAhbS5pc0NvbGxhcHNlZCAmJiB0aGlzLmlzU3RhcnRlZEF0RWRpdG9yICYmIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZGVsZXRlXCIpLCB0aGlzLmlzU3RhcnRlZEF0RWRpdG9yID0gITE7XG4gICAgY29uc3QgbiA9IHQuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgIGlmIChuKVxuICAgICAgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhuLCBvLnBvc2l0aW9ucy5FTkQpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgciA9IHQuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUodC5sYXN0QmxvY2suaG9sZGVyKTtcbiAgICAgIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sociwgby5wb3NpdGlvbnMuRU5EKTtcbiAgICB9XG4gICAgYXdhaXQgaS5wcm9jZXNzRGF0YVRyYW5zZmVyKGUuZGF0YVRyYW5zZmVyLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAqL1xuICBwcm9jZXNzRHJhZ1N0YXJ0KCkge1xuICAgIG0uaXNBdEVkaXRvciAmJiAhbS5pc0NvbGxhcHNlZCAmJiAodGhpcy5pc1N0YXJ0ZWRBdEVkaXRvciA9ICEwKSwgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZHJhZ0V2ZW50IC0gZHJhZyBldmVudFxuICAgKi9cbiAgcHJvY2Vzc0RyYWdPdmVyKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmNsYXNzIEdvIGV4dGVuZHMgUyB7XG4gIC8qKlxuICAgKiBQcmVwYXJlIHRoZSBtb2R1bGVcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIHVzZWQgYnkgdGhlIG1vZGlmaWNhdGlvbiBvYnNlcnZlciBtb2R1bGVcbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gRWRpdG9yIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50c0Rpc3BhdGNoZXIgLSBjb21tb24gRWRpdG9yIGV2ZW50IGJ1c1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KSwgdGhpcy5kaXNhYmxlZCA9ICExLCB0aGlzLmJhdGNoaW5nVGltZW91dCA9IG51bGwsIHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5iYXRjaFRpbWUgPSA0MDAsIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChvKSA9PiB7XG4gICAgICB0aGlzLnJlZGFjdG9yQ2hhbmdlZChvKTtcbiAgICB9KSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKGx0LCAobykgPT4ge1xuICAgICAgdGhpcy5wYXJ0aWN1bGFyQmxvY2tDaGFuZ2VkKG8uZXZlbnQpO1xuICAgIH0pLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oY3QsICgpID0+IHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH0pLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oZHQsICgpID0+IHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgb25DaGFuZ2UgZXZlbnRcbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShcbiAgICAgIHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yLFxuICAgICAge1xuICAgICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgICBzdWJ0cmVlOiAhMCxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogITAsXG4gICAgICAgIGF0dHJpYnV0ZXM6ICEwXG4gICAgICB9XG4gICAgKSwgdGhpcy5kaXNhYmxlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBvbkNoYW5nZSBldmVudFxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCB0aGlzLmRpc2FibGVkID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgb25DaGFuZ2UgZXZlbnQgcGFzc2VkIHRvIEVkaXRvci5qcyBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIHNvbWUgb2Ygb3VyIGN1c3RvbSBjaGFuZ2UgZXZlbnRzXG4gICAqL1xuICBwYXJ0aWN1bGFyQmxvY2tDaGFuZ2VkKGUpIHtcbiAgICB0aGlzLmRpc2FibGVkIHx8ICFEKHRoaXMuY29uZmlnLm9uQ2hhbmdlKSB8fCAodGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUuc2V0KGBibG9jazoke2UuZGV0YWlsLnRhcmdldC5pZH06ZXZlbnQ6JHtlLnR5cGV9YCwgZSksIHRoaXMuYmF0Y2hpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLmJhdGNoaW5nVGltZW91dCksIHRoaXMuYmF0Y2hpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsZXQgdDtcbiAgICAgIHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnNpemUgPT09IDEgPyB0ID0gdGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUudmFsdWVzKCkubmV4dCgpLnZhbHVlIDogdCA9IEFycmF5LmZyb20odGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUudmFsdWVzKCkpLCB0aGlzLmNvbmZpZy5vbkNoYW5nZSAmJiB0aGlzLmNvbmZpZy5vbkNoYW5nZSh0aGlzLkVkaXRvci5BUEkubWV0aG9kcywgdCksIHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLmNsZWFyKCk7XG4gICAgfSwgdGhpcy5iYXRjaFRpbWUpKTtcbiAgfVxuICAvKipcbiAgICogRmlyZWQgb24gZXZlcnkgYmxvY2tzIHdyYXBwZXIgZG9tIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0gbXV0YXRpb25zIC0gbXV0YXRpb25zIGhhcHBlbmVkXG4gICAqL1xuICByZWRhY3RvckNoYW5nZWQoZSkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KE1lLCB7XG4gICAgICBtdXRhdGlvbnM6IGVcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgeHQgPSBjbGFzcyBleHRlbmRzIFMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLk1JTUVfVFlQRSA9IFwiYXBwbGljYXRpb24veC1lZGl0b3ItanNcIiwgdGhpcy50b29sc1RhZ3MgPSB7fSwgdGhpcy50YWdzQnlUb29sID0ge30sIHRoaXMudG9vbHNQYXR0ZXJucyA9IFtdLCB0aGlzLnRvb2xzRmlsZXMgPSB7fSwgdGhpcy5leGNlcHRpb25MaXN0ID0gW10sIHRoaXMucHJvY2Vzc1Rvb2wgPSAocykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZSA9IHMuY3JlYXRlKHt9LCB7fSwgITEpO1xuICAgICAgICBpZiAocy5wYXN0ZUNvbmZpZyA9PT0gITEpIHtcbiAgICAgICAgICB0aGlzLmV4Y2VwdGlvbkxpc3QucHVzaChzLm5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUQoZS5vblBhc3RlKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZ2V0VGFnc0NvbmZpZyhzKSwgdGhpcy5nZXRGaWxlc0NvbmZpZyhzKSwgdGhpcy5nZXRQYXR0ZXJuc0NvbmZpZyhzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgVChcbiAgICAgICAgICBgUGFzdGUgaGFuZGxpbmcgZm9yIMKrJHtzLm5hbWV9wrsgVG9vbCBoYXNuJ3QgYmVlbiBzZXQgdXAgYmVjYXVzZSBvZiB0aGUgZXJyb3JgLFxuICAgICAgICAgIFwid2FyblwiLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmhhbmRsZVBhc3RlRXZlbnQgPSBhc3luYyAocykgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUsIFRvb2xiYXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgICAgIWUuY3VycmVudEJsb2NrIHx8IHRoaXMuaXNOYXRpdmVCZWhhdmlvdXIocy50YXJnZXQpICYmICFzLmNsaXBib2FyZERhdGEudHlwZXMuaW5jbHVkZXMoXCJGaWxlc1wiKSB8fCBlLmN1cnJlbnRCbG9jayAmJiB0aGlzLmV4Y2VwdGlvbkxpc3QuaW5jbHVkZXMoZS5jdXJyZW50QmxvY2submFtZSkgfHwgKHMucHJldmVudERlZmF1bHQoKSwgdGhpcy5wcm9jZXNzRGF0YVRyYW5zZmVyKHMuY2xpcGJvYXJkRGF0YSksIGUuY2xlYXJGb2N1c2VkKCksIHQuY2xvc2UoKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9uUGFzdGUgY2FsbGJhY2sgYW5kIGNvbGxlY3QgdG9vbHNgIHBhc3RlIGNvbmZpZ3VyYXRpb25zXG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIHRoaXMucHJvY2Vzc1Rvb2xzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSByZWFkIG9ubHkgZmxhZyB2YWx1ZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkocykge1xuICAgIHMgPyB0aGlzLnVuc2V0Q2FsbGJhY2soKSA6IHRoaXMuc2V0Q2FsbGJhY2soKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHBhc3RlZCBvciBkcm9wcGVkIGRhdGEgdHJhbnNmZXIgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVRyYW5zZmVyfSBkYXRhVHJhbnNmZXIgLSBwYXN0ZWQgb3IgZHJvcHBlZCBkYXRhIHRyYW5zZmVyIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRHJhZ05Ecm9wIC0gdHJ1ZSBpZiBkYXRhIHRyYW5zZmVyIGNvbWVzIGZyb20gZHJhZyduJ2Ryb3AgZXZlbnRzXG4gICAqL1xuICBhc3luYyBwcm9jZXNzRGF0YVRyYW5zZmVyKHMsIGUgPSAhMSkge1xuICAgIGNvbnN0IHsgVG9vbHM6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gcy50eXBlcztcbiAgICBpZiAoKG8uaW5jbHVkZXMgPyBvLmluY2x1ZGVzKFwiRmlsZXNcIikgOiBvLmNvbnRhaW5zKFwiRmlsZXNcIikpICYmICFWKHRoaXMudG9vbHNGaWxlcykpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGVzKHMuZmlsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuID0gcy5nZXREYXRhKHRoaXMuTUlNRV9UWVBFKSwgciA9IHMuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgbGV0IGEgPSBzLmdldERhdGEoXCJ0ZXh0L2h0bWxcIik7XG4gICAgaWYgKG4pXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmluc2VydEVkaXRvckpTRGF0YShKU09OLnBhcnNlKG4pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgZSAmJiByLnRyaW0oKSAmJiBhLnRyaW0oKSAmJiAoYSA9IFwiPHA+XCIgKyAoYS50cmltKCkgPyBhIDogcikgKyBcIjwvcD5cIik7XG4gICAgY29uc3QgbCA9IE9iamVjdC5rZXlzKHRoaXMudG9vbHNUYWdzKS5yZWR1Y2UoKGgsIGYpID0+IChoW2YudG9Mb3dlckNhc2UoKV0gPSB0aGlzLnRvb2xzVGFnc1tmXS5zYW5pdGl6YXRpb25Db25maWcgPz8ge30sIGgpLCB7fSksIGMgPSBPYmplY3QuYXNzaWduKHt9LCBsLCB0LmdldEFsbElubGluZVRvb2xzU2FuaXRpemVDb25maWcoKSwgeyBicjoge30gfSksIHUgPSBaKGEsIGMpO1xuICAgICF1LnRyaW0oKSB8fCB1LnRyaW0oKSA9PT0gciB8fCAhZC5pc0hUTUxTdHJpbmcodSkgPyBhd2FpdCB0aGlzLnByb2Nlc3NUZXh0KHIpIDogYXdhaXQgdGhpcy5wcm9jZXNzVGV4dCh1LCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGFzdGVkIHRleHQgYW5kIGRpdmlkZSB0aGVtIGludG8gQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gdGV4dCB0byBwcm9jZXNzLiBDYW4gYmUgSFRNTCBvciBwbGFpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0hUTUwgLSBpZiBwYXNzZWQgc3RyaW5nIGlzIEhUTUwsIHRoaXMgcGFyYW1ldGVyIHNob3VsZCBiZSB0cnVlXG4gICAqL1xuICBhc3luYyBwcm9jZXNzVGV4dChzLCBlID0gITEpIHtcbiAgICBjb25zdCB7IENhcmV0OiB0LCBCbG9ja01hbmFnZXI6IG8gfSA9IHRoaXMuRWRpdG9yLCBpID0gZSA/IHRoaXMucHJvY2Vzc0hUTUwocykgOiB0aGlzLnByb2Nlc3NQbGFpbihzKTtcbiAgICBpZiAoIWkubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaVswXS5pc0Jsb2NrID8gdGhpcy5wcm9jZXNzU2luZ2xlQmxvY2soaS5wb3AoKSkgOiB0aGlzLnByb2Nlc3NJbmxpbmVQYXN0ZShpLnBvcCgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgciA9IG8uY3VycmVudEJsb2NrICYmIG8uY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIG8uY3VycmVudEJsb2NrLmlzRW1wdHk7XG4gICAgaS5tYXAoXG4gICAgICBhc3luYyAoYSwgbCkgPT4gdGhpcy5pbnNlcnRCbG9jayhhLCBsID09PSAwICYmIHIpXG4gICAgKSwgby5jdXJyZW50QmxvY2sgJiYgdC5zZXRUb0Jsb2NrKG8uY3VycmVudEJsb2NrLCB0LnBvc2l0aW9ucy5FTkQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb25QYXN0ZSBjYWxsYmFjayBoYW5kbGVyXG4gICAqL1xuICBzZXRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vbih0aGlzLkVkaXRvci5VSS5ub2Rlcy5ob2xkZXIsIFwicGFzdGVcIiwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogVW5zZXQgb25QYXN0ZSBjYWxsYmFjayBoYW5kbGVyXG4gICAqL1xuICB1bnNldENhbGxiYWNrKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZih0aGlzLkVkaXRvci5VSS5ub2Rlcy5ob2xkZXIsIFwicGFzdGVcIiwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuZCBwcm9jZXNzIHRvb2xgcyBwYXN0ZSBjb25maWdzXG4gICAqL1xuICBwcm9jZXNzVG9vbHMoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHM7XG4gICAgQXJyYXkuZnJvbShzLnZhbHVlcygpKS5mb3JFYWNoKHRoaXMucHJvY2Vzc1Rvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGFncyBuYW1lIGxpc3QgZnJvbSBlaXRoZXIgdGFnIG5hbWUgb3Igc2FuaXRpemF0aW9uIGNvbmZpZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBvYmplY3R9IHRhZ09yU2FuaXRpemVDb25maWcgLSB0YWcgbmFtZSBvciBzYW5pdGl6ZSBjb25maWcgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGFycmF5IG9mIHRhZ3MuXG4gICAqL1xuICBjb2xsZWN0VGFnTmFtZXMocykge1xuICAgIHJldHVybiBKKHMpID8gW3NdIDogaihzKSA/IE9iamVjdC5rZXlzKHMpIDogW107XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0YWdzIHRvIHN1YnN0aXR1dGUgYnkgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIEJsb2NrVG9vbCBvYmplY3RcbiAgICovXG4gIGdldFRhZ3NDb25maWcocykge1xuICAgIGlmIChzLnBhc3RlQ29uZmlnID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gcy5wYXN0ZUNvbmZpZy50YWdzIHx8IFtdLCB0ID0gW107XG4gICAgZS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5jb2xsZWN0VGFnTmFtZXMobyk7XG4gICAgICB0LnB1c2goLi4uaSksIGkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudG9vbHNUYWdzLCBuKSkge1xuICAgICAgICAgIFQoXG4gICAgICAgICAgICBgUGFzdGUgaGFuZGxlciBmb3Igwqske3MubmFtZX3CuyBUb29sIG9uIMKrJHtufcK7IHRhZyBpcyBza2lwcGVkIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSB1c2VkIGJ5IMKrJHt0aGlzLnRvb2xzVGFnc1tuXS50b29sLm5hbWV9wrsgVG9vbC5gLFxuICAgICAgICAgICAgXCJ3YXJuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gaihvKSA/IG9bbl0gOiBudWxsO1xuICAgICAgICB0aGlzLnRvb2xzVGFnc1tuLnRvVXBwZXJDYXNlKCldID0ge1xuICAgICAgICAgIHRvb2w6IHMsXG4gICAgICAgICAgc2FuaXRpemF0aW9uQ29uZmlnOiByXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy50YWdzQnlUb29sW3MubmFtZV0gPSB0Lm1hcCgobykgPT4gby50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGZpbGVzYCB0eXBlcyBhbmQgZXh0ZW5zaW9ucyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRGaWxlc0NvbmZpZyhzKSB7XG4gICAgaWYgKHMucGFzdGVDb25maWcgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZmlsZXM6IGUgPSB7fSB9ID0gcy5wYXN0ZUNvbmZpZztcbiAgICBsZXQgeyBleHRlbnNpb25zOiB0LCBtaW1lVHlwZXM6IG8gfSA9IGU7XG4gICAgIXQgJiYgIW8gfHwgKHQgJiYgIUFycmF5LmlzQXJyYXkodCkgJiYgKFQoYMKrZXh0ZW5zaW9uc8K7IHByb3BlcnR5IG9mIHRoZSBvbkRyb3AgY29uZmlnIGZvciDCqyR7cy5uYW1lfcK7IFRvb2wgc2hvdWxkIGJlIGFuIGFycmF5YCksIHQgPSBbXSksIG8gJiYgIUFycmF5LmlzQXJyYXkobykgJiYgKFQoYMKrbWltZVR5cGVzwrsgcHJvcGVydHkgb2YgdGhlIG9uRHJvcCBjb25maWcgZm9yIMKrJHtzLm5hbWV9wrsgVG9vbCBzaG91bGQgYmUgYW4gYXJyYXlgKSwgbyA9IFtdKSwgbyAmJiAobyA9IG8uZmlsdGVyKChpKSA9PiBEdChpKSA/ICEwIDogKFQoYE1JTUUgdHlwZSB2YWx1ZSDCqyR7aX3CuyBmb3IgdGhlIMKrJHtzLm5hbWV9wrsgVG9vbCBpcyBub3QgYSB2YWxpZCBNSU1FIHR5cGVgLCBcIndhcm5cIiksICExKSkpLCB0aGlzLnRvb2xzRmlsZXNbcy5uYW1lXSA9IHtcbiAgICAgIGV4dGVuc2lvbnM6IHQgfHwgW10sXG4gICAgICBtaW1lVHlwZXM6IG8gfHwgW11cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IFJlZ0V4cCBwYXR0ZXJucyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRQYXR0ZXJuc0NvbmZpZyhzKSB7XG4gICAgcy5wYXN0ZUNvbmZpZyA9PT0gITEgfHwgIXMucGFzdGVDb25maWcucGF0dGVybnMgfHwgVihzLnBhc3RlQ29uZmlnLnBhdHRlcm5zKSB8fCBPYmplY3QuZW50cmllcyhzLnBhc3RlQ29uZmlnLnBhdHRlcm5zKS5mb3JFYWNoKChbZSwgdF0pID0+IHtcbiAgICAgIHQgaW5zdGFuY2VvZiBSZWdFeHAgfHwgVChcbiAgICAgICAgYFBhdHRlcm4gJHt0fSBmb3Igwqske3MubmFtZX3CuyBUb29sIGlzIHNraXBwZWQgYmVjYXVzZSBpdCBzaG91bGQgYmUgYSBSZWdleHAgaW5zdGFuY2UuYCxcbiAgICAgICAgXCJ3YXJuXCJcbiAgICAgICksIHRoaXMudG9vbHNQYXR0ZXJucy5wdXNoKHtcbiAgICAgICAga2V5OiBlLFxuICAgICAgICBwYXR0ZXJuOiB0LFxuICAgICAgICB0b29sOiBzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBiZWhhdmlvciBzdWl0cyBiZXR0ZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgY29udGVudCBoYXMgYmVlbiBwYXN0ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc05hdGl2ZUJlaGF2aW91cihzKSB7XG4gICAgcmV0dXJuIGQuaXNOYXRpdmVJbnB1dChzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGZpbGVzIGZyb20gZGF0YSB0cmFuc2ZlciBvYmplY3QgYW5kIGluc2VydCByZWxhdGVkIFRvb2xzXG4gICAqXG4gICAqIEBwYXJhbSB7RmlsZUxpc3R9IGl0ZW1zIC0gcGFzdGVkIG9yIGRyb3BwZWQgaXRlbXNcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NGaWxlcyhzKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCB0O1xuICAgIHQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20ocykubWFwKChuKSA9PiB0aGlzLnByb2Nlc3NGaWxlKG4pKVxuICAgICksIHQgPSB0LmZpbHRlcigobikgPT4gISFuKTtcbiAgICBjb25zdCBpID0gZS5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgZS5jdXJyZW50QmxvY2suaXNFbXB0eTtcbiAgICB0LmZvckVhY2goXG4gICAgICAobiwgcikgPT4ge1xuICAgICAgICBlLnBhc3RlKG4udHlwZSwgbi5ldmVudCwgciA9PT0gMCAmJiBpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgZmlsZSBhbmQgZmluZCBUb29sIHRvIGhhbmRsZSBpdFxuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGUgLSBmaWxlIHRvIHByb2Nlc3NcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NGaWxlKHMpIHtcbiAgICBjb25zdCBlID0gUnQocyksIHQgPSBPYmplY3QuZW50cmllcyh0aGlzLnRvb2xzRmlsZXMpLmZpbmQoKFtuLCB7IG1pbWVUeXBlczogciwgZXh0ZW5zaW9uczogYSB9XSkgPT4ge1xuICAgICAgY29uc3QgW2wsIGNdID0gcy50eXBlLnNwbGl0KFwiL1wiKSwgdSA9IGEuZmluZCgoZikgPT4gZi50b0xvd2VyQ2FzZSgpID09PSBlLnRvTG93ZXJDYXNlKCkpLCBoID0gci5maW5kKChmKSA9PiB7XG4gICAgICAgIGNvbnN0IFt2LCBwXSA9IGYuc3BsaXQoXCIvXCIpO1xuICAgICAgICByZXR1cm4gdiA9PT0gbCAmJiAocCA9PT0gYyB8fCBwID09PSBcIipcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXUgfHwgISFoO1xuICAgIH0pO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbb10gPSB0O1xuICAgIHJldHVybiB7XG4gICAgICBldmVudDogdGhpcy5jb21wb3NlUGFzdGVFdmVudChcImZpbGVcIiwge1xuICAgICAgICBmaWxlOiBzXG4gICAgICB9KSxcbiAgICAgIHR5cGU6IG9cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBIVE1MIHN0cmluZyB0byBibG9ja3MgYW5kIHJldHVybiBpdCBhcyBhcnJheSBvZiBCbG9jayBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbm5lckhUTUwgLSBodG1sIHN0cmluZyB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQYXN0ZURhdGFbXX1cbiAgICovXG4gIHByb2Nlc3NIVE1MKHMpIHtcbiAgICBjb25zdCB7IFRvb2xzOiBlIH0gPSB0aGlzLkVkaXRvciwgdCA9IGQubWFrZShcIkRJVlwiKTtcbiAgICByZXR1cm4gdC5pbm5lckhUTUwgPSBzLCB0aGlzLmdldE5vZGVzKHQpLm1hcCgoaSkgPT4ge1xuICAgICAgbGV0IG4sIHIgPSBlLmRlZmF1bHRUb29sLCBhID0gITE7XG4gICAgICBzd2l0Y2ggKGkubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgbiA9IGQubWFrZShcImRpdlwiKSwgbi5hcHBlbmRDaGlsZChpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICBuID0gaSwgYSA9ICEwLCB0aGlzLnRvb2xzVGFnc1tuLnRhZ05hbWVdICYmIChyID0gdGhpcy50b29sc1RhZ3Nbbi50YWdOYW1lXS50b29sKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdGFnczogbCB9ID0gci5wYXN0ZUNvbmZpZyB8fCB7IHRhZ3M6IFtdIH0sIGMgPSBsLnJlZHVjZSgoZiwgdikgPT4gKHRoaXMuY29sbGVjdFRhZ05hbWVzKHYpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgY29uc3QgXyA9IGoodikgPyB2W2tdIDogbnVsbDtcbiAgICAgICAgZltrLnRvTG93ZXJDYXNlKCldID0gXyB8fCB7fTtcbiAgICAgIH0pLCBmKSwge30pLCB1ID0gT2JqZWN0LmFzc2lnbih7fSwgYywgci5iYXNlU2FuaXRpemVDb25maWcpO1xuICAgICAgaWYgKG4udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInRhYmxlXCIpIHtcbiAgICAgICAgY29uc3QgZiA9IFoobi5vdXRlckhUTUwsIHUpO1xuICAgICAgICBuID0gZC5tYWtlKFwiZGl2XCIsIHZvaWQgMCwge1xuICAgICAgICAgIGlubmVySFRNTDogZlxuICAgICAgICB9KS5maXJzdENoaWxkO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG4uaW5uZXJIVE1MID0gWihuLmlubmVySFRNTCwgdSk7XG4gICAgICBjb25zdCBoID0gdGhpcy5jb21wb3NlUGFzdGVFdmVudChcInRhZ1wiLCB7XG4gICAgICAgIGRhdGE6IG5cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogbixcbiAgICAgICAgaXNCbG9jazogYSxcbiAgICAgICAgdG9vbDogci5uYW1lLFxuICAgICAgICBldmVudDogaFxuICAgICAgfTtcbiAgICB9KS5maWx0ZXIoKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBkLmlzRW1wdHkoaS5jb250ZW50KSwgciA9IGQuaXNTaW5nbGVUYWcoaS5jb250ZW50KTtcbiAgICAgIHJldHVybiAhbiB8fCByO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdCBwbGFpbiB0ZXh0IGJ5IG5ldyBsaW5lIHN5bWJvbHMgYW5kIHJldHVybiBpdCBhcyBhcnJheSBvZiBCbG9jayBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFpbiAtIHN0cmluZyB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQYXN0ZURhdGFbXX1cbiAgICovXG4gIHByb2Nlc3NQbGFpbihzKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QmxvY2s6IGUgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0ID0gZTtcbiAgICByZXR1cm4gcy5zcGxpdCgvXFxyP1xcbi8pLmZpbHRlcigobykgPT4gby50cmltKCkpLm1hcCgobykgPT4ge1xuICAgICAgY29uc3QgaSA9IGQubWFrZShcImRpdlwiKTtcbiAgICAgIGkudGV4dENvbnRlbnQgPSBvO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJ0YWdcIiwge1xuICAgICAgICBkYXRhOiBpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IGksXG4gICAgICAgIHRvb2w6IHQsXG4gICAgICAgIGlzQmxvY2s6ICExLFxuICAgICAgICBldmVudDogblxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBwYXN0ZSBvZiBzaW5nbGUgQmxvY2sgdG9vbCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVEYXRhfSBkYXRhVG9JbnNlcnQgLSBkYXRhIG9mIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc1NpbmdsZUJsb2NrKHMpIHtcbiAgICBjb25zdCB7IENhcmV0OiBlLCBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogbyB9ID0gdDtcbiAgICBpZiAoIW8gfHwgcy50b29sICE9PSBvLm5hbWUgfHwgIWQuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMocy5jb250ZW50LmlubmVySFRNTCkpIHtcbiAgICAgIHRoaXMuaW5zZXJ0QmxvY2socywgKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8udG9vbC5pc0RlZmF1bHQpICYmIG8uaXNFbXB0eSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihzLmNvbnRlbnQuaW5uZXJIVE1MKTtcbiAgfVxuICAvKipcbiAgICogUHJvY2VzcyBwYXN0ZSB0byBzaW5nbGUgQmxvY2s6XG4gICAqIDEuIEZpbmQgcGF0dGVybnNgIG1hdGNoZXNcbiAgICogMi4gSW5zZXJ0IG5ldyBibG9jayBpZiBpdCBpcyBub3QgdGhlIHNhbWUgdHlwZSBhcyBjdXJyZW50IG9uZVxuICAgKiAzLiBKdXN0IGluc2VydCB0ZXh0IGlmIHRoZXJlIGlzIG5vIHN1YnN0aXR1dGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZURhdGF9IGRhdGFUb0luc2VydCAtIGRhdGEgb2YgQmxvY2sgdG8gaW5zZXJ0XG4gICAqL1xuICBhc3luYyBwcm9jZXNzSW5saW5lUGFzdGUocykge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlLCBDYXJldDogdCB9ID0gdGhpcy5FZGl0b3IsIHsgY29udGVudDogbyB9ID0gcztcbiAgICBpZiAoZS5jdXJyZW50QmxvY2sgJiYgZS5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgby50ZXh0Q29udGVudC5sZW5ndGggPCB4dC5QQVRURVJOX1BST0NFU1NJTkdfTUFYX0xFTkdUSCkge1xuICAgICAgY29uc3QgbiA9IGF3YWl0IHRoaXMucHJvY2Vzc1BhdHRlcm4oby50ZXh0Q29udGVudCk7XG4gICAgICBpZiAobikge1xuICAgICAgICBjb25zdCByID0gZS5jdXJyZW50QmxvY2sgJiYgZS5jdXJyZW50QmxvY2sudG9vbC5pc0RlZmF1bHQgJiYgZS5jdXJyZW50QmxvY2suaXNFbXB0eSwgYSA9IGUucGFzdGUobi50b29sLCBuLmV2ZW50LCByKTtcbiAgICAgICAgdC5zZXRUb0Jsb2NrKGEsIHQucG9zaXRpb25zLkVORCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUuY3VycmVudEJsb2NrICYmIGUuY3VycmVudEJsb2NrLmN1cnJlbnRJbnB1dCkge1xuICAgICAgY29uc3QgbiA9IGUuY3VycmVudEJsb2NrLnRvb2wuYmFzZVNhbml0aXplQ29uZmlnO1xuICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXG4gICAgICAgIFwiaW5zZXJ0SFRNTFwiLFxuICAgICAgICAhMSxcbiAgICAgICAgWihvLmlubmVySFRNTCwgbilcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmluc2VydEJsb2NrKHMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcGF0dGVybnNgIG1hdGNoZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0ZXh0IHRvIHByb2Nlc3NcbiAgICogQHJldHVybnMge1Byb21pc2U8e2V2ZW50OiBQYXN0ZUV2ZW50LCB0b29sOiBzdHJpbmd9Pn1cbiAgICovXG4gIGFzeW5jIHByb2Nlc3NQYXR0ZXJuKHMpIHtcbiAgICBjb25zdCBlID0gdGhpcy50b29sc1BhdHRlcm5zLmZpbmQoKG8pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBvLnBhdHRlcm4uZXhlYyhzKTtcbiAgICAgIHJldHVybiBpID8gcyA9PT0gaS5zaGlmdCgpIDogITE7XG4gICAgfSk7XG4gICAgcmV0dXJuIGUgPyB7XG4gICAgICBldmVudDogdGhpcy5jb21wb3NlUGFzdGVFdmVudChcInBhdHRlcm5cIiwge1xuICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICBkYXRhOiBzXG4gICAgICB9KSxcbiAgICAgIHRvb2w6IGUudG9vbC5uYW1lXG4gICAgfSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHBhc3RlZCBCbG9jayBjb250ZW50IHRvIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRGF0YX0gZGF0YSAtIGRhdGEgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuUmVwbGFjZUN1cnJlbnRCbG9jayAtIGlmIHRydWUgYW5kIGlzIGN1cnJlbnQgQmxvY2sgaXMgZW1wdHksIHdpbGwgcmVwbGFjZSBjdXJyZW50IEJsb2NrXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgaW5zZXJ0QmxvY2socywgZSA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIENhcmV0OiBvIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IGkgfSA9IHQ7XG4gICAgbGV0IG47XG4gICAgaWYgKGUgJiYgaSAmJiBpLmlzRW1wdHkpIHtcbiAgICAgIG4gPSB0LnBhc3RlKHMudG9vbCwgcy5ldmVudCwgITApLCBvLnNldFRvQmxvY2sobiwgby5wb3NpdGlvbnMuRU5EKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbiA9IHQucGFzdGUocy50b29sLCBzLmV2ZW50KSwgby5zZXRUb0Jsb2NrKG4sIG8ucG9zaXRpb25zLkVORCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBkYXRhIHBhc3NlZCBhcyBhcHBsaWNhdGlvbi94LWVkaXRvci1qcyBKU09OXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJsb2NrcyDigJQgQmxvY2tzJyBkYXRhIHRvIGluc2VydFxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGluc2VydEVkaXRvckpTRGF0YShzKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUsIENhcmV0OiB0LCBUb29sczogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaHQoXG4gICAgICBzLFxuICAgICAgKG4pID0+IG8uYmxvY2tUb29scy5nZXQobikuc2FuaXRpemVDb25maWdcbiAgICApLmZvckVhY2goKHsgdG9vbDogbiwgZGF0YTogciB9LCBhKSA9PiB7XG4gICAgICBsZXQgbCA9ICExO1xuICAgICAgYSA9PT0gMCAmJiAobCA9IGUuY3VycmVudEJsb2NrICYmIGUuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIGUuY3VycmVudEJsb2NrLmlzRW1wdHkpO1xuICAgICAgY29uc3QgYyA9IGUuaW5zZXJ0KHtcbiAgICAgICAgdG9vbDogbixcbiAgICAgICAgZGF0YTogcixcbiAgICAgICAgcmVwbGFjZTogbFxuICAgICAgfSk7XG4gICAgICB0LnNldFRvQmxvY2soYywgdC5wb3NpdGlvbnMuRU5EKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggbm9kZXMgZnJvbSBFbGVtZW50IG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gY3VycmVudCBub2RlXG4gICAqIEBwYXJhbSB7Tm9kZVtdfSBub2RlcyAtIHByb2Nlc3NlZCBub2Rlc1xuICAgKiBAcGFyYW0ge05vZGV9IGRlc3ROb2RlIC0gZGVzdGluYXRpb24gbm9kZVxuICAgKi9cbiAgcHJvY2Vzc0VsZW1lbnROb2RlKHMsIGUsIHQpIHtcbiAgICBjb25zdCBvID0gT2JqZWN0LmtleXModGhpcy50b29sc1RhZ3MpLCBpID0gcywgeyB0b29sOiBuIH0gPSB0aGlzLnRvb2xzVGFnc1tpLnRhZ05hbWVdIHx8IHt9LCByID0gdGhpcy50YWdzQnlUb29sW24gPT0gbnVsbCA/IHZvaWQgMCA6IG4ubmFtZV0gfHwgW10sIGEgPSBvLmluY2x1ZGVzKGkudGFnTmFtZSksIGwgPSBkLmJsb2NrRWxlbWVudHMuaW5jbHVkZXMoaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpLCBjID0gQXJyYXkuZnJvbShpLmNoaWxkcmVuKS5zb21lKFxuICAgICAgKHsgdGFnTmFtZTogaCB9KSA9PiBvLmluY2x1ZGVzKGgpICYmICFyLmluY2x1ZGVzKGgpXG4gICAgKSwgdSA9IEFycmF5LmZyb20oaS5jaGlsZHJlbikuc29tZShcbiAgICAgICh7IHRhZ05hbWU6IGggfSkgPT4gZC5ibG9ja0VsZW1lbnRzLmluY2x1ZGVzKGgudG9Mb3dlckNhc2UoKSlcbiAgICApO1xuICAgIGlmICghbCAmJiAhYSAmJiAhYylcbiAgICAgIHJldHVybiB0LmFwcGVuZENoaWxkKGkpLCBbLi4uZSwgdF07XG4gICAgaWYgKGEgJiYgIWMgfHwgbCAmJiAhdSAmJiAhYylcbiAgICAgIHJldHVybiBbLi4uZSwgdCwgaV07XG4gIH1cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGRpdmlkZSBIVE1MIHN0cmluZyB0byB0d28gdHlwZXMgb2Ygbm9kZXM6XG4gICAqIDEuIEJsb2NrIGVsZW1lbnRcbiAgICogMi4gRG9jdW1lbnQgRnJhZ21lbnRzIGNvbnRhaW5lZCB0ZXh0IGFuZCBtYXJrdXAgdGFncyBsaWtlIGEsIGIsIGkgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHdyYXBwZXIgLSB3cmFwcGVyIG9mIHBhc3RlciBIVE1MIGNvbnRlbnRcbiAgICogQHJldHVybnMge05vZGVbXX1cbiAgICovXG4gIGdldE5vZGVzKHMpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbShzLmNoaWxkTm9kZXMpO1xuICAgIGxldCB0O1xuICAgIGNvbnN0IG8gPSAoaSwgbikgPT4ge1xuICAgICAgaWYgKGQuaXNFbXB0eShuKSAmJiAhZC5pc1NpbmdsZVRhZyhuKSlcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICBjb25zdCByID0gaVtpLmxlbmd0aCAtIDFdO1xuICAgICAgbGV0IGEgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgc3dpdGNoIChyICYmIGQuaXNGcmFnbWVudChyKSAmJiAoYSA9IGkucG9wKCkpLCBuLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgaWYgKHQgPSB0aGlzLnByb2Nlc3NFbGVtZW50Tm9kZShuLCBpLCBhKSwgdClcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOlxuICAgICAgICAgIHJldHVybiBhLmFwcGVuZENoaWxkKG4pLCBbLi4uaSwgYV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFsuLi5pLCBhXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbLi4uaSwgLi4uQXJyYXkuZnJvbShuLmNoaWxkTm9kZXMpLnJlZHVjZShvLCBbXSldO1xuICAgIH07XG4gICAgcmV0dXJuIGUucmVkdWNlKG8sIFtdKTtcbiAgfVxuICAvKipcbiAgICogQ29tcG9zZSBwYXN0ZSBldmVudCB3aXRoIHBhc3NlZCB0eXBlIGFuZCBkZXRhaWxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7UGFzdGVFdmVudERldGFpbH0gZGV0YWlsIC0gZXZlbnQgZGV0YWlsXG4gICAqL1xuICBjb21wb3NlUGFzdGVFdmVudChzLCBlKSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChzLCB7XG4gICAgICBkZXRhaWw6IGVcbiAgICB9KTtcbiAgfVxufTtcbmxldCB3dCA9IHh0O1xud3QuUEFUVEVSTl9QUk9DRVNTSU5HX01BWF9MRU5HVEggPSA0NTA7XG5jbGFzcyBxbyBleHRlbmRzIFMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnRvb2xzRG9udFN1cHBvcnRSZWFkT25seSA9IFtdLCB0aGlzLnJlYWRPbmx5RW5hYmxlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0YXRlIG9mIHJlYWQgb25seSBtb2RlXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogU2V0IGluaXRpYWwgc3RhdGVcbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgY29uc3QgeyBUb29sczogZSB9ID0gdGhpcy5FZGl0b3IsIHsgYmxvY2tUb29sczogdCB9ID0gZSwgbyA9IFtdO1xuICAgIEFycmF5LmZyb20odC5lbnRyaWVzKCkpLmZvckVhY2goKFtpLCBuXSkgPT4ge1xuICAgICAgbi5pc1JlYWRPbmx5U3VwcG9ydGVkIHx8IG8ucHVzaChpKTtcbiAgICB9KSwgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkgPSBvLCB0aGlzLmNvbmZpZy5yZWFkT25seSAmJiBvLmxlbmd0aCA+IDAgJiYgdGhpcy50aHJvd0NyaXRpY2FsRXJyb3IoKSwgdGhpcy50b2dnbGUodGhpcy5jb25maWcucmVhZE9ubHkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgcmVhZC1vbmx5IG1vZGUgb3IgdG9nZ2xlIGN1cnJlbnQgc3RhdGVcbiAgICogQ2FsbCBhbGwgTW9kdWxlcyBgdG9nZ2xlUmVhZE9ubHlgIG1ldGhvZCBhbmQgcmUtcmVuZGVyIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gKG9wdGlvbmFsKSByZWFkLW9ubHkgc3RhdGUgb3IgdG9nZ2xlXG4gICAqL1xuICBhc3luYyB0b2dnbGUoZSA9ICF0aGlzLnJlYWRPbmx5RW5hYmxlZCkge1xuICAgIGUgJiYgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkubGVuZ3RoID4gMCAmJiB0aGlzLnRocm93Q3JpdGljYWxFcnJvcigpO1xuICAgIGNvbnN0IHQgPSB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgICB0aGlzLnJlYWRPbmx5RW5hYmxlZCA9IGU7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuRWRpdG9yKVxuICAgICAgdGhpcy5FZGl0b3JbaV0udG9nZ2xlUmVhZE9ubHkgJiYgdGhpcy5FZGl0b3JbaV0udG9nZ2xlUmVhZE9ubHkoZSk7XG4gICAgaWYgKHQgPT09IGUpXG4gICAgICByZXR1cm4gdGhpcy5yZWFkT25seUVuYWJsZWQ7XG4gICAgY29uc3QgbyA9IGF3YWl0IHRoaXMuRWRpdG9yLlNhdmVyLnNhdmUoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmNsZWFyKCksIGF3YWl0IHRoaXMuRWRpdG9yLlJlbmRlcmVyLnJlbmRlcihvLmJsb2NrcyksIHRoaXMucmVhZE9ubHlFbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgYWJvdXQgdG9vbHMgd2hpY2ggZG9uJ3Qgc3VwcG9ydCByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgdGhyb3dDcml0aWNhbEVycm9yKCkge1xuICAgIHRocm93IG5ldyBhdChcbiAgICAgIGBUbyBlbmFibGUgcmVhZC1vbmx5IG1vZGUgYWxsIGNvbm5lY3RlZCB0b29scyBzaG91bGQgc3VwcG9ydCBpdC4gVG9vbHMgJHt0aGlzLnRvb2xzRG9udFN1cHBvcnRSZWFkT25seS5qb2luKFwiLCBcIil9IGRvbid0IHN1cHBvcnQgcmVhZC1vbmx5IG1vZGUuYFxuICAgICk7XG4gIH1cbn1cbmNsYXNzIHBlIGV4dGVuZHMgUyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITEsIHRoaXMuU0NST0xMX1NQRUVEID0gMywgdGhpcy5IRUlHSFRfT0ZfU0NST0xMX1pPTkUgPSA0MCwgdGhpcy5CT1RUT01fU0NST0xMX1pPTkUgPSAxLCB0aGlzLlRPUF9TQ1JPTExfWk9ORSA9IDIsIHRoaXMuTUFJTl9NT1VTRV9CVVRUT04gPSAwLCB0aGlzLm1vdXNlZG93biA9ICExLCB0aGlzLmlzU2Nyb2xsaW5nID0gITEsIHRoaXMuaW5TY3JvbGxab25lID0gbnVsbCwgdGhpcy5zdGFydFggPSAwLCB0aGlzLnN0YXJ0WSA9IDAsIHRoaXMubW91c2VYID0gMCwgdGhpcy5tb3VzZVkgPSAwLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZCA9IFtdLCB0aGlzLmxpc3RlbmVySWRzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIENTUyBjbGFzc2VzIGZvciB0aGUgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge3t3cmFwcGVyOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmxheTogXCJjb2RleC1lZGl0b3Itb3ZlcmxheVwiLFxuICAgICAgb3ZlcmxheUNvbnRhaW5lcjogXCJjb2RleC1lZGl0b3Itb3ZlcmxheV9fY29udGFpbmVyXCIsXG4gICAgICByZWN0OiBcImNvZGV4LWVkaXRvci1vdmVybGF5X19yZWN0YW5nbGVcIixcbiAgICAgIHRvcFNjcm9sbFpvbmU6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX3Njcm9sbC16b25lLS10b3BcIixcbiAgICAgIGJvdHRvbVNjcm9sbFpvbmU6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX3Njcm9sbC16b25lLS1ib3R0b21cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBQcmVwYXJhdGlvblxuICAgKiBDcmVhdGluZyByZWN0IGFuZCBoYW5nIGhhbmRsZXJzXG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIHRoaXMuZW5hYmxlTW9kdWxlQmluZGluZ3MoKTtcbiAgfVxuICAvKipcbiAgICogSW5pdCByZWN0IHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVggLSBYIGNvb3JkIG9mIG1vdXNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWSAtIFkgY29vcmQgb2YgbW91c2VcbiAgICovXG4gIHN0YXJ0U2VsZWN0aW9uKGUsIHQpIHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCB0IC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICBvLmNsb3Nlc3QoYC4ke3RoaXMuRWRpdG9yLlRvb2xiYXIuQ1NTLnRvb2xiYXJ9YCkgfHwgKHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFsbEJsb2Nrc1NlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5zdGFja09mU2VsZWN0ZWQgPSBbXSk7XG4gICAgY29uc3QgbiA9IFtcbiAgICAgIGAuJHtGLkNTUy5jb250ZW50fWAsXG4gICAgICBgLiR7dGhpcy5FZGl0b3IuVG9vbGJhci5DU1MudG9vbGJhcn1gLFxuICAgICAgYC4ke3RoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuQ1NTLmlubGluZVRvb2xiYXJ9YFxuICAgIF0sIHIgPSBvLmNsb3Nlc3QoXCIuXCIgKyB0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yV3JhcHBlciksIGEgPSBuLnNvbWUoKGwpID0+ICEhby5jbG9zZXN0KGwpKTtcbiAgICAhciB8fCBhIHx8ICh0aGlzLm1vdXNlZG93biA9ICEwLCB0aGlzLnN0YXJ0WCA9IGUsIHRoaXMuc3RhcnRZID0gdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBwYXJhbXMgdG8gZW5kIHNlbGVjdGlvblxuICAgKi9cbiAgZW5kU2VsZWN0aW9uKCkge1xuICAgIHRoaXMubW91c2Vkb3duID0gITEsIHRoaXMuc3RhcnRYID0gMCwgdGhpcy5zdGFydFkgPSAwLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9XG4gIC8qKlxuICAgKiBpcyBSZWN0U2VsZWN0aW9uIEFjdGl2YXRlZFxuICAgKi9cbiAgaXNSZWN0QWN0aXZhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzUmVjdFNlbGVjdGlvbkFjdGl2YXRlZDtcbiAgfVxuICAvKipcbiAgICogTWFyayB0aGF0IHNlbGVjdGlvbiBpcyBlbmRcbiAgICovXG4gIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgTW9kdWxlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVyc1xuICAgKi9cbiAgZW5hYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgY29uc3QgeyBjb250YWluZXI6IGUgfSA9IHRoaXMuZ2VuSFRNTCgpO1xuICAgIHRoaXMubGlzdGVuZXJzLm9uKGUsIFwibW91c2Vkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NNb3VzZURvd24odCk7XG4gICAgfSwgITEpLCB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudC5ib2R5LCBcIm1vdXNlbW92ZVwiLCBUZSgodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzTW91c2VNb3ZlKHQpO1xuICAgIH0sIDEwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlTGVhdmUoKTtcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24od2luZG93LCBcInNjcm9sbFwiLCBUZSgodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzU2Nyb2xsKHQpO1xuICAgIH0sIDEwKSwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlVXAoKTtcbiAgICB9LCAhMSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIGV2ZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBwYXlsb2FkXG4gICAqL1xuICBwcm9jZXNzTW91c2VEb3duKGUpIHtcbiAgICBpZiAoZS5idXR0b24gIT09IHRoaXMuTUFJTl9NT1VTRV9CVVRUT04pXG4gICAgICByZXR1cm47XG4gICAgZS50YXJnZXQuY2xvc2VzdChkLmFsbElucHV0c1NlbGVjdG9yKSAhPT0gbnVsbCB8fCB0aGlzLnN0YXJ0U2VsZWN0aW9uKGUucGFnZVgsIGUucGFnZVkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbW92ZSBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgcGF5bG9hZFxuICAgKi9cbiAgcHJvY2Vzc01vdXNlTW92ZShlKSB7XG4gICAgdGhpcy5jaGFuZ2luZ1JlY3RhbmdsZShlKSwgdGhpcy5zY3JvbGxCeVpvbmVzKGUuY2xpZW50WSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBsZWF2ZVxuICAgKi9cbiAgcHJvY2Vzc01vdXNlTGVhdmUoKSB7XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpLCB0aGlzLmVuZFNlbGVjdGlvbigpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBtb3VzZSBldmVudCBwYXlsb2FkXG4gICAqL1xuICBwcm9jZXNzU2Nyb2xsKGUpIHtcbiAgICB0aGlzLmNoYW5naW5nUmVjdGFuZ2xlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgdXBcbiAgICovXG4gIHByb2Nlc3NNb3VzZVVwKCkge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5lbmRTZWxlY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogU2Nyb2xsIElmIG1vdXNlIGluIHNjcm9sbCB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRZIC0gWSBjb29yZCBvZiBtb3VzZVxuICAgKi9cbiAgc2Nyb2xsQnlab25lcyhlKSB7XG4gICAgaWYgKHRoaXMuaW5TY3JvbGxab25lID0gbnVsbCwgZSA8PSB0aGlzLkhFSUdIVF9PRl9TQ1JPTExfWk9ORSAmJiAodGhpcy5pblNjcm9sbFpvbmUgPSB0aGlzLlRPUF9TQ1JPTExfWk9ORSksIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgLSBlIDw9IHRoaXMuSEVJR0hUX09GX1NDUk9MTF9aT05FICYmICh0aGlzLmluU2Nyb2xsWm9uZSA9IHRoaXMuQk9UVE9NX1NDUk9MTF9aT05FKSwgIXRoaXMuaW5TY3JvbGxab25lKSB7XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTY3JvbGxpbmcgfHwgKHRoaXMuc2Nyb2xsVmVydGljYWwodGhpcy5pblNjcm9sbFpvbmUgPT09IHRoaXMuVE9QX1NDUk9MTF9aT05FID8gLXRoaXMuU0NST0xMX1NQRUVEIDogdGhpcy5TQ1JPTExfU1BFRUQpLCB0aGlzLmlzU2Nyb2xsaW5nID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmVxdWlyZWQgSFRNTCBlbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgRWxlbWVudD59XG4gICAqL1xuICBnZW5IVE1MKCkge1xuICAgIGNvbnN0IHsgVUk6IGUgfSA9IHRoaXMuRWRpdG9yLCB0ID0gZS5ub2Rlcy5ob2xkZXIucXVlcnlTZWxlY3RvcihcIi5cIiArIGUuQ1NTLmVkaXRvcldyYXBwZXIpLCBvID0gZC5tYWtlKFwiZGl2XCIsIHBlLkNTUy5vdmVybGF5LCB7fSksIGkgPSBkLm1ha2UoXCJkaXZcIiwgcGUuQ1NTLm92ZXJsYXlDb250YWluZXIsIHt9KSwgbiA9IGQubWFrZShcImRpdlwiLCBwZS5DU1MucmVjdCwge30pO1xuICAgIHJldHVybiBpLmFwcGVuZENoaWxkKG4pLCBvLmFwcGVuZENoaWxkKGkpLCB0LmFwcGVuZENoaWxkKG8pLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUgPSBuLCB7XG4gICAgICBjb250YWluZXI6IHQsXG4gICAgICBvdmVybGF5OiBvXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGVzIHNjcm9sbGluZyBpZiBibG9ja1NlbGVjdGlvbiBpcyBhY3RpdmUgYW5kIG1vdXNlIGlzIGluIHNjcm9sbCB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZCAtIHNwZWVkIG9mIHNjcm9sbGluZ1xuICAgKi9cbiAgc2Nyb2xsVmVydGljYWwoZSkge1xuICAgIGlmICghKHRoaXMuaW5TY3JvbGxab25lICYmIHRoaXMubW91c2Vkb3duKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBlKSwgdGhpcy5tb3VzZVkgKz0gd2luZG93LnBhZ2VZT2Zmc2V0IC0gdCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNjcm9sbFZlcnRpY2FsKGUpO1xuICAgIH0sIDApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgaW4gdGhlIHJlY3RhbmdsZSBhbmQgaXRzIGVmZmVjdFxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gbW91c2UgZXZlbnRcbiAgICovXG4gIGNoYW5naW5nUmVjdGFuZ2xlKGUpIHtcbiAgICBpZiAoIXRoaXMubW91c2Vkb3duKVxuICAgICAgcmV0dXJuO1xuICAgIGUucGFnZVkgIT09IHZvaWQgMCAmJiAodGhpcy5tb3VzZVggPSBlLnBhZ2VYLCB0aGlzLm1vdXNlWSA9IGUucGFnZVkpO1xuICAgIGNvbnN0IHsgcmlnaHRQb3M6IHQsIGxlZnRQb3M6IG8sIGluZGV4OiBpIH0gPSB0aGlzLmdlbkluZm9Gb3JNb3VzZVNlbGVjdGlvbigpLCBuID0gdGhpcy5zdGFydFggPiB0ICYmIHRoaXMubW91c2VYID4gdCwgciA9IHRoaXMuc3RhcnRYIDwgbyAmJiB0aGlzLm1vdXNlWCA8IG87XG4gICAgdGhpcy5yZWN0Q3Jvc3Nlc0Jsb2NrcyA9ICEobiB8fCByKSwgdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQgfHwgKHRoaXMucmVjdENyb3NzZXNCbG9ja3MgPSAhMSwgdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQgPSAhMCwgdGhpcy5zaHJpbmtSZWN0YW5nbGVUb1BvaW50KCksIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKSwgdGhpcy51cGRhdGVSZWN0YW5nbGVTaXplKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSwgaSAhPT0gdm9pZCAwICYmICh0aGlzLnRyeVNlbGVjdE5leHRCbG9jayhpKSwgdGhpcy5pbnZlcnNlU2VsZWN0aW9uKCksIG0uZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBTaHJpbmsgcmVjdCB0byBzaW5ndWxhciBwb2ludFxuICAgKi9cbiAgc2hyaW5rUmVjdGFuZ2xlVG9Qb2ludCgpIHtcbiAgICB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnRvcCA9IGAke3RoaXMuc3RhcnRZIC0gd2luZG93LnBhZ2VZT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmJvdHRvbSA9IGBjYWxjKDEwMCUgLSAke3RoaXMuc3RhcnRZIC0gd2luZG93LnBhZ2VZT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5zdGFydFggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3Qgb3IgdW5zZWxlY3QgYWxsIG9mIGJsb2NrcyBpbiBhcnJheSBpZiByZWN0IGlzIG91dCBvciBpbiBzZWxlY3RhYmxlIGFyZWFcbiAgICovXG4gIGludmVyc2VTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgodGhpcy5zdGFja09mU2VsZWN0ZWRbMF0pLnNlbGVjdGVkO1xuICAgIGlmICh0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmICF0KVxuICAgICAgZm9yIChjb25zdCBvIG9mIHRoaXMuc3RhY2tPZlNlbGVjdGVkKVxuICAgICAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5zZWxlY3RCbG9ja0J5SW5kZXgobyk7XG4gICAgaWYgKCF0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmIHQpXG4gICAgICBmb3IgKGNvbnN0IG8gb2YgdGhpcy5zdGFja09mU2VsZWN0ZWQpXG4gICAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnVuU2VsZWN0QmxvY2tCeUluZGV4KG8pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIHNpemUgb2YgcmVjdGFuZ2xlXG4gICAqL1xuICB1cGRhdGVSZWN0YW5nbGVTaXplKCkge1xuICAgIHRoaXMubW91c2VZID49IHRoaXMuc3RhcnRZID8gKHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGApIDogKHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGApLCB0aGlzLm1vdXNlWCA+PSB0aGlzLnN0YXJ0WCA/ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5tb3VzZVggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgKSA6ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUucmlnaHQgPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WCAtIHdpbmRvdy5wYWdlWE9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5tb3VzZVggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgKTtcbiAgfVxuICAvKipcbiAgICogQ29sbGVjdHMgaW5mb3JtYXRpb24gbmVlZGVkIHRvIGRldGVybWluZSB0aGUgYmVoYXZpb3Igb2YgdGhlIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBpbmRleCAtIGluZGV4IG5leHQgQmxvY2ssIGxlZnRQb3MgLSBzdGFydCBvZiBsZWZ0IGJvcmRlciBvZiBCbG9jaywgcmlnaHRQb3MgLSByaWdodCBib3JkZXJcbiAgICovXG4gIGdlbkluZm9Gb3JNb3VzZVNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCAvIDIsIG8gPSB0aGlzLm1vdXNlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCwgaSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodCwgbyksIG4gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShpKTtcbiAgICBsZXQgcjtcbiAgICBuICE9PSB2b2lkIDAgJiYgKHIgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmZpbmRJbmRleCgoaCkgPT4gaC5ob2xkZXIgPT09IG4uaG9sZGVyKSk7XG4gICAgY29uc3QgYSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2suaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBGLkNTUy5jb250ZW50KSwgbCA9IE51bWJlci5wYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS53aWR0aCwgMTApIC8gMiwgYyA9IHQgLSBsLCB1ID0gdCArIGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiByLFxuICAgICAgbGVmdFBvczogYyxcbiAgICAgIHJpZ2h0UG9zOiB1XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IGJsb2NrIHdpdGggaW5kZXggaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggb2YgYmxvY2sgaW4gcmVkYWN0b3JcbiAgICovXG4gIGFkZEJsb2NrSW5TZWxlY3Rpb24oZSkge1xuICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uc2VsZWN0QmxvY2tCeUluZGV4KGUpLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5wdXNoKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgYmxvY2sgdG8gdGhlIHNlbGVjdGlvbiBhbmQgZGV0ZXJtaW5lcyB3aGljaCBibG9ja3Mgc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmRleCAtIGluZGV4IG9mIG5ldyBibG9jayBpbiB0aGUgcmVhY3RvclxuICAgKi9cbiAgdHJ5U2VsZWN0TmV4dEJsb2NrKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbdGhpcy5zdGFja09mU2VsZWN0ZWQubGVuZ3RoIC0gMV0gPT09IGUsIG8gPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5sZW5ndGgsIGkgPSAxLCBuID0gLTEsIHIgPSAwO1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gLSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMl0gPiAwO1xuICAgIGxldCBsID0gcjtcbiAgICBvID4gMSAmJiAobCA9IGEgPyBpIDogbik7XG4gICAgY29uc3QgYyA9IGUgPiB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gJiYgbCA9PT0gaSwgdSA9IGUgPCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gJiYgbCA9PT0gbiwgZiA9ICEoYyB8fCB1IHx8IGwgPT09IHIpO1xuICAgIGlmICghZiAmJiAoZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSB8fCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gPT09IHZvaWQgMCkpIHtcbiAgICAgIGxldCBrID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdICsgMSB8fCBlO1xuICAgICAgZm9yIChrOyBrIDw9IGU7IGsrKylcbiAgICAgICAgdGhpcy5hZGRCbG9ja0luU2VsZWN0aW9uKGspO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWYgJiYgZSA8IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSkge1xuICAgICAgZm9yIChsZXQgayA9IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSAtIDE7IGsgPj0gZTsgay0tKVxuICAgICAgICB0aGlzLmFkZEJsb2NrSW5TZWxlY3Rpb24oayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdiA9IG8gLSAxLCBwO1xuICAgIGZvciAoZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSA/IHAgPSAoKSA9PiBlID4gdGhpcy5zdGFja09mU2VsZWN0ZWRbdl0gOiBwID0gKCkgPT4gZSA8IHRoaXMuc3RhY2tPZlNlbGVjdGVkW3ZdOyBwKCk7IClcbiAgICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgJiYgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24udW5TZWxlY3RCbG9ja0J5SW5kZXgodGhpcy5zdGFja09mU2VsZWN0ZWRbdl0pLCB0aGlzLnN0YWNrT2ZTZWxlY3RlZC5wb3AoKSwgdi0tO1xuICB9XG59XG5jbGFzcyBKbyBleHRlbmRzIFMge1xuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gUmVuZGVyZXJCbG9ja3NcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSB0b29sIG5hbWVcbiAgICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgLSB0b29sIGRhdGFcbiAgICovXG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBibG9ja3M6IFtcbiAgICogICB7XG4gICAqICAgICBpZCAgIDogJ29EZS1FVnJHV0EnLFxuICAgKiAgICAgdHlwZSA6ICdwYXJhZ3JhcGgnLFxuICAgKiAgICAgZGF0YSA6IHtcbiAgICogICAgICAgdGV4dCA6ICdIZWxsbyBmcm9tIENvZGV4ISdcbiAgICogICAgIH1cbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIGlkICAgOiAnTGQ1QkpqSkNIcycsXG4gICAqICAgICB0eXBlIDogJ3BhcmFncmFwaCcsXG4gICAqICAgICBkYXRhIDoge1xuICAgKiAgICAgICB0ZXh0IDogJ0xlYXZlIGZlZWRiYWNrIGlmIHlvdSBsaWtlIGl0ISdcbiAgICogICAgIH1cbiAgICogICB9LFxuICAgKiBdXG4gICAqL1xuICAvKipcbiAgICogTWFrZSBwbHVnaW4gYmxvY2tzIGZyb20gYXJyYXkgb2YgcGx1Z2luYHMgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge091dHB1dEJsb2NrRGF0YVtdfSBibG9ja3MgLSBibG9ja3MgdG8gcmVuZGVyXG4gICAqL1xuICBhc3luYyByZW5kZXIoZSkge1xuICAgIGNvbnN0IHQgPSBlLm1hcCgoaSkgPT4gKHsgZnVuY3Rpb246ICgpID0+IHRoaXMuaW5zZXJ0QmxvY2soaSkgfSkpO1xuICAgIHRoaXMuRWRpdG9yLk1vZGlmaWNhdGlvbnNPYnNlcnZlci5kaXNhYmxlKCk7XG4gICAgY29uc3QgbyA9IGF3YWl0IG90KHQpO1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5Nb2RpZmljYXRpb25zT2JzZXJ2ZXIuZW5hYmxlKCksIHRoaXMuRWRpdG9yLlVJLmNoZWNrRW1wdGluZXNzKCksIG87XG4gIH1cbiAgLyoqXG4gICAqIEdldCBwbHVnaW4gaW5zdGFuY2VcbiAgICogQWRkIHBsdWdpbiBpbnN0YW5jZSB0byBCbG9ja01hbmFnZXJcbiAgICogSW5zZXJ0IGJsb2NrIHRvIHdvcmtpbmcgem9uZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSAtIEJsb2NrIGRhdGEgdG8gaW5zZXJ0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgaW5zZXJ0QmxvY2soZSkge1xuICAgIHZhciBsO1xuICAgIGNvbnN0IHsgVG9vbHM6IHQsIEJsb2NrTWFuYWdlcjogbyB9ID0gdGhpcy5FZGl0b3IsIHsgdHlwZTogaSwgZGF0YTogbiwgdHVuZXM6IHIsIGlkOiBhIH0gPSBlO1xuICAgIGlmICh0LmF2YWlsYWJsZS5oYXMoaSkpXG4gICAgICB0cnkge1xuICAgICAgICBvLmluc2VydCh7XG4gICAgICAgICAgaWQ6IGEsXG4gICAgICAgICAgdG9vbDogaSxcbiAgICAgICAgICBkYXRhOiBuLFxuICAgICAgICAgIHR1bmVzOiByXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoYykge1xuICAgICAgICB0aHJvdyBUKGBCbG9jayDCqyR7aX3CuyBza2lwcGVkIGJlY2F1c2Ugb2YgcGx1Z2lucyBlcnJvcmAsIFwid2FyblwiLCB7XG4gICAgICAgICAgZGF0YTogbixcbiAgICAgICAgICBlcnJvcjogY1xuICAgICAgICB9KSwgRXJyb3IoYyk7XG4gICAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBjID0ge1xuICAgICAgICBzYXZlZERhdGE6IHtcbiAgICAgICAgICBpZDogYSxcbiAgICAgICAgICB0eXBlOiBpLFxuICAgICAgICAgIGRhdGE6IG5cbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IGlcbiAgICAgIH07XG4gICAgICBpZiAodC51bmF2YWlsYWJsZS5oYXMoaSkpIHtcbiAgICAgICAgY29uc3QgZiA9IChsID0gdC51bmF2YWlsYWJsZS5nZXQoaSkudG9vbGJveFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwudGl0bGU7XG4gICAgICAgIGMudGl0bGUgPSBmIHx8IGMudGl0bGU7XG4gICAgICB9XG4gICAgICBjb25zdCB1ID0gby5pbnNlcnQoe1xuICAgICAgICBpZDogYSxcbiAgICAgICAgdG9vbDogdC5zdHViVG9vbCxcbiAgICAgICAgZGF0YTogY1xuICAgICAgfSk7XG4gICAgICB1LnN0cmV0Y2hlZCA9ICEwLCBUKGBUb29sIMKrJHtpfcK7IGlzIG5vdCBmb3VuZC4gQ2hlY2sgJ3Rvb2xzJyBwcm9wZXJ0eSBhdCB5b3VyIGluaXRpYWwgRWRpdG9yLmpzIGNvbmZpZy5gLCBcIndhcm5cIik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBRbyBleHRlbmRzIFMge1xuICAvKipcbiAgICogQ29tcG9zZXMgbmV3IGNoYWluIG9mIFByb21pc2VzIHRvIGZpcmUgdGhlbSBhbHRlcm5hdGVsbHlcbiAgICpcbiAgICogQHJldHVybnMge091dHB1dERhdGF9XG4gICAqL1xuICBhc3luYyBzYXZlKCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBlLCBUb29sczogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSBlLmJsb2NrcywgaSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBvLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaS5wdXNoKHRoaXMuZ2V0U2F2ZWREYXRhKGEpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGF3YWl0IFByb21pc2UuYWxsKGkpLCByID0gYXdhaXQgaHQobiwgKGEpID0+IHQuYmxvY2tUb29scy5nZXQoYSkuc2FuaXRpemVDb25maWcpO1xuICAgICAgcmV0dXJuIHRoaXMubWFrZU91dHB1dChyKTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICBLKFwiU2F2aW5nIGZhaWxlZCBkdWUgdG8gdGhlIEVycm9yICVvXCIsIFwiZXJyb3JcIiwgbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTYXZlcyBhbmQgdmFsaWRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gRWRpdG9yJ3MgVG9vbFxuICAgKiBAcmV0dXJucyB7VmFsaWRhdGVkRGF0YX0gLSBUb29sJ3MgdmFsaWRhdGVkIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldFNhdmVkRGF0YShlKSB7XG4gICAgY29uc3QgdCA9IGF3YWl0IGUuc2F2ZSgpLCBvID0gdCAmJiBhd2FpdCBlLnZhbGlkYXRlKHQuZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnQsXG4gICAgICBpc1ZhbGlkOiBvXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBvdXRwdXQgb2JqZWN0IHdpdGggc2F2ZWQgZGF0YSwgdGltZSBhbmQgdmVyc2lvbiBvZiBlZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtWYWxpZGF0ZWREYXRhfSBhbGxFeHRyYWN0ZWREYXRhIC0gZGF0YSBleHRyYWN0ZWQgZnJvbSBCbG9ja3NcbiAgICogQHJldHVybnMge091dHB1dERhdGF9XG4gICAqL1xuICBtYWtlT3V0cHV0KGUpIHtcbiAgICBsZXQgdCA9IDA7XG4gICAgY29uc3QgbyA9IFtdO1xuICAgIHJldHVybiBUKFwiW0VkaXRvci5qcyBzYXZpbmddOlwiLCBcImdyb3VwQ29sbGFwc2VkXCIpLCBlLmZvckVhY2goKHsgaWQ6IGksIHRvb2w6IG4sIGRhdGE6IHIsIHR1bmVzOiBhLCB0aW1lOiBsLCBpc1ZhbGlkOiBjIH0pID0+IHtcbiAgICAgIGlmICh0ICs9IGwsIFQoYCR7bi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG4uc2xpY2UoMSl9YCwgXCJncm91cFwiKSwgYylcbiAgICAgICAgVChyKSwgVCh2b2lkIDAsIFwiZ3JvdXBFbmRcIik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgVChgQmxvY2sgwqske259wrsgc2tpcHBlZCBiZWNhdXNlIHNhdmVkIGRhdGEgaXMgaW52YWxpZGApLCBUKHZvaWQgMCwgXCJncm91cEVuZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT09IHRoaXMuRWRpdG9yLlRvb2xzLnN0dWJUb29sKSB7XG4gICAgICAgIG8ucHVzaChyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIHR5cGU6IG4sXG4gICAgICAgIGRhdGE6IHIsXG4gICAgICAgIC4uLiFWKGEpICYmIHtcbiAgICAgICAgICB0dW5lczogYVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgby5wdXNoKHUpO1xuICAgIH0pLCBUKFwiVG90YWxcIiwgXCJsb2dcIiwgdCksIFQodm9pZCAwLCBcImdyb3VwRW5kXCIpLCB7XG4gICAgICB0aW1lOiArLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBibG9ja3M6IG8sXG4gICAgICB2ZXJzaW9uOiBcIjIuMjcuMlwiXG4gICAgfTtcbiAgfVxufVxudmFyIE5lID0ge30sIGVpID0ge1xuICBnZXQgZXhwb3J0cygpIHtcbiAgICByZXR1cm4gTmU7XG4gIH0sXG4gIHNldCBleHBvcnRzKHMpIHtcbiAgICBOZSA9IHM7XG4gIH1cbn07XG4oZnVuY3Rpb24ocywgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIHMuZXhwb3J0cyA9IG8oKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGkobikge1xuICAgICAgICBpZiAob1tuXSlcbiAgICAgICAgICByZXR1cm4gb1tuXS5leHBvcnRzO1xuICAgICAgICB2YXIgciA9IG9bbl0gPSB7IGk6IG4sIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gdFtuXS5jYWxsKHIuZXhwb3J0cywgciwgci5leHBvcnRzLCBpKSwgci5sID0gITAsIHIuZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLm0gPSB0LCBpLmMgPSBvLCBpLmQgPSBmdW5jdGlvbihuLCByLCBhKSB7XG4gICAgICAgIGkubyhuLCByKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBhIH0pO1xuICAgICAgfSwgaS5yID0gZnVuY3Rpb24obikge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCBpLnQgPSBmdW5jdGlvbihuLCByKSB7XG4gICAgICAgIGlmICgxICYgciAmJiAobiA9IGkobikpLCA4ICYgciB8fCA0ICYgciAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIG4gJiYgbi5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB2YXIgYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaS5yKGEpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBuIH0pLCAyICYgciAmJiB0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIGZvciAodmFyIGwgaW4gbilcbiAgICAgICAgICAgIGkuZChhLCBsLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuW2NdO1xuICAgICAgICAgICAgfS5iaW5kKG51bGwsIGwpKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LCBpLm4gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciByID0gbiAmJiBuLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbi5kZWZhdWx0O1xuICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpLmQociwgXCJhXCIsIHIpLCByO1xuICAgICAgfSwgaS5vID0gZnVuY3Rpb24obiwgcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHIpO1xuICAgICAgfSwgaS5wID0gXCIvXCIsIGkoaS5zID0gNCk7XG4gICAgfShbZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgdmFyIG4gPSBpKDEpLCByID0gaSgyKTtcbiAgICAgIHR5cGVvZiAociA9IHIuX19lc01vZHVsZSA/IHIuZGVmYXVsdCA6IHIpID09IFwic3RyaW5nXCIgJiYgKHIgPSBbW3QuaSwgciwgXCJcIl1dKTtcbiAgICAgIHZhciBhID0geyBpbnNlcnQ6IFwiaGVhZFwiLCBzaW5nbGV0b246ICExIH07XG4gICAgICBuKHIsIGEpLCB0LmV4cG9ydHMgPSByLmxvY2FscyB8fCB7fTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgbiwgciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gISEod2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpKSwgbjtcbiAgICAgIH0sIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHkgPSB7fTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICBpZiAoeVt4XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoeCk7XG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHcgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdyA9IHcuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIHcgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB5W3hdID0gdztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHlbeF07XG4gICAgICAgIH07XG4gICAgICB9KCksIGwgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGMoeSkge1xuICAgICAgICBmb3IgKHZhciB4ID0gLTEsIHcgPSAwOyB3IDwgbC5sZW5ndGg7IHcrKylcbiAgICAgICAgICBpZiAobFt3XS5pZGVudGlmaWVyID09PSB5KSB7XG4gICAgICAgICAgICB4ID0gdztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1KHksIHgpIHtcbiAgICAgICAgZm9yICh2YXIgdyA9IHt9LCBNID0gW10sIFIgPSAwOyBSIDwgeS5sZW5ndGg7IFIrKykge1xuICAgICAgICAgIHZhciBiID0geVtSXSwgZyA9IHguYmFzZSA/IGJbMF0gKyB4LmJhc2UgOiBiWzBdLCBFID0gd1tnXSB8fCAwLCBDID0gXCJcIi5jb25jYXQoZywgXCIgXCIpLmNvbmNhdChFKTtcbiAgICAgICAgICB3W2ddID0gRSArIDE7XG4gICAgICAgICAgdmFyIE8gPSBjKEMpLCBJID0geyBjc3M6IGJbMV0sIG1lZGlhOiBiWzJdLCBzb3VyY2VNYXA6IGJbM10gfTtcbiAgICAgICAgICBPICE9PSAtMSA/IChsW09dLnJlZmVyZW5jZXMrKywgbFtPXS51cGRhdGVyKEkpKSA6IGwucHVzaCh7IGlkZW50aWZpZXI6IEMsIHVwZGF0ZXI6IEEoSSwgeCksIHJlZmVyZW5jZXM6IDEgfSksIE0ucHVzaChDKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGgoeSkge1xuICAgICAgICB2YXIgeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKSwgdyA9IHkuYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgaWYgKHcubm9uY2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBNID0gaS5uYztcbiAgICAgICAgICBNICYmICh3Lm5vbmNlID0gTSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHcpLmZvckVhY2goZnVuY3Rpb24oYikge1xuICAgICAgICAgIHguc2V0QXR0cmlidXRlKGIsIHdbYl0pO1xuICAgICAgICB9KSwgdHlwZW9mIHkuaW5zZXJ0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB5Lmluc2VydCh4KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIFIgPSBhKHkuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICAgIFIuYXBwZW5kQ2hpbGQoeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICB2YXIgZiwgdiA9IChmID0gW10sIGZ1bmN0aW9uKHksIHgpIHtcbiAgICAgICAgcmV0dXJuIGZbeV0gPSB4LCBmLmZpbHRlcihCb29sZWFuKS5qb2luKGBcbmApO1xuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiBwKHksIHgsIHcsIE0pIHtcbiAgICAgICAgdmFyIFIgPSB3ID8gXCJcIiA6IE0ubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQoTS5tZWRpYSwgXCIge1wiKS5jb25jYXQoTS5jc3MsIFwifVwiKSA6IE0uY3NzO1xuICAgICAgICBpZiAoeS5zdHlsZVNoZWV0KVxuICAgICAgICAgIHkuc3R5bGVTaGVldC5jc3NUZXh0ID0gdih4LCBSKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShSKSwgZyA9IHkuY2hpbGROb2RlcztcbiAgICAgICAgICBnW3hdICYmIHkucmVtb3ZlQ2hpbGQoZ1t4XSksIGcubGVuZ3RoID8geS5pbnNlcnRCZWZvcmUoYiwgZ1t4XSkgOiB5LmFwcGVuZENoaWxkKGIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBrKHksIHgsIHcpIHtcbiAgICAgICAgdmFyIE0gPSB3LmNzcywgUiA9IHcubWVkaWEsIGIgPSB3LnNvdXJjZU1hcDtcbiAgICAgICAgaWYgKFIgPyB5LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIFIpIDogeS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKSwgYiAmJiBidG9hICYmIChNICs9IGBcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsYC5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoYikpKSksIFwiICovXCIpKSwgeS5zdHlsZVNoZWV0KVxuICAgICAgICAgIHkuc3R5bGVTaGVldC5jc3NUZXh0ID0gTTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yICg7IHkuZmlyc3RDaGlsZDsgKVxuICAgICAgICAgICAgeS5yZW1vdmVDaGlsZCh5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIHkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoTSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgXyA9IG51bGwsIE4gPSAwO1xuICAgICAgZnVuY3Rpb24gQSh5LCB4KSB7XG4gICAgICAgIHZhciB3LCBNLCBSO1xuICAgICAgICBpZiAoeC5zaW5nbGV0b24pIHtcbiAgICAgICAgICB2YXIgYiA9IE4rKztcbiAgICAgICAgICB3ID0gXyB8fCAoXyA9IGgoeCkpLCBNID0gcC5iaW5kKG51bGwsIHcsIGIsICExKSwgUiA9IHAuYmluZChudWxsLCB3LCBiLCAhMCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHcgPSBoKHgpLCBNID0gay5iaW5kKG51bGwsIHcsIHgpLCBSID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgICBpZiAoZy5wYXJlbnROb2RlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGcpO1xuICAgICAgICAgICAgfSkodyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE0oeSksIGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgaWYgKGcuY3NzID09PSB5LmNzcyAmJiBnLm1lZGlhID09PSB5Lm1lZGlhICYmIGcuc291cmNlTWFwID09PSB5LnNvdXJjZU1hcClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgTSh5ID0gZyk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBSKCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbih5LCB4KSB7XG4gICAgICAgICh4ID0geCB8fCB7fSkuc2luZ2xldG9uIHx8IHR5cGVvZiB4LnNpbmdsZXRvbiA9PSBcImJvb2xlYW5cIiB8fCAoeC5zaW5nbGV0b24gPSByKCkpO1xuICAgICAgICB2YXIgdyA9IHUoeSA9IHkgfHwgW10sIHgpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oTSkge1xuICAgICAgICAgIGlmIChNID0gTSB8fCBbXSwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKE0pID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIFIgPSAwOyBSIDwgdy5sZW5ndGg7IFIrKykge1xuICAgICAgICAgICAgICB2YXIgYiA9IGMod1tSXSk7XG4gICAgICAgICAgICAgIGxbYl0ucmVmZXJlbmNlcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgZyA9IHUoTSwgeCksIEUgPSAwOyBFIDwgdy5sZW5ndGg7IEUrKykge1xuICAgICAgICAgICAgICB2YXIgQyA9IGMod1tFXSk7XG4gICAgICAgICAgICAgIGxbQ10ucmVmZXJlbmNlcyA9PT0gMCAmJiAobFtDXS51cGRhdGVyKCksIGwuc3BsaWNlKEMsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHcgPSBnO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgKG8gPSBpKDMpKCExKSkucHVzaChbdC5pLCBgLmNlLXBhcmFncmFwaCB7XG4gICAgbGluZS1oZWlnaHQ6IDEuNmVtO1xuICAgIG91dGxpbmU6IG5vbmU7XG59XG5cbi5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6OmJlZm9yZXtcbiAgY29udGVudDogYXR0cihkYXRhLXBsYWNlaG9sZGVyKTtcbiAgY29sb3I6ICM3MDc2ODQ7XG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gIG9wYWNpdHk6IDA7XG59XG5cbi8qKiBTaG93IHBsYWNlaG9sZGVyIGF0IHRoZSBmaXJzdCBwYXJhZ3JhcGggaWYgRWRpdG9yIGlzIGVtcHR5ICovXG4uY29kZXgtZWRpdG9yLS1lbXB0eSAuY2UtYmxvY2s6Zmlyc3QtY2hpbGQgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTo6YmVmb3JlIHtcbiAgb3BhY2l0eTogMTtcbn1cblxuLmNvZGV4LWVkaXRvci0tdG9vbGJveC1vcGVuZWQgLmNlLWJsb2NrOmZpcnN0LWNoaWxkIC5jZS1wYXJhZ3JhcGhbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6OmJlZm9yZSxcbi5jb2RleC1lZGl0b3ItLWVtcHR5IC5jZS1ibG9jazpmaXJzdC1jaGlsZCAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXJdOmVtcHR5OmZvY3VzOjpiZWZvcmUge1xuICBvcGFjaXR5OiAwO1xufVxuXG4uY2UtcGFyYWdyYXBoIHA6Zmlyc3Qtb2YtdHlwZXtcbiAgICBtYXJnaW4tdG9wOiAwO1xufVxuXG4uY2UtcGFyYWdyYXBoIHA6bGFzdC1vZi10eXBle1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG59XG5gLCBcIlwiXSksIHQuZXhwb3J0cyA9IG87XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICByZXR1cm4gci50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICB2YXIgbCA9IGZ1bmN0aW9uKGMsIHUpIHtcbiAgICAgICAgICAgICAgdmFyIGggPSBjWzFdIHx8IFwiXCIsIGYgPSBjWzNdO1xuICAgICAgICAgICAgICBpZiAoIWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICAgIGlmICh1ICYmIHR5cGVvZiBidG9hID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gKGsgPSBmLCBfID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoaykpKSksIE4gPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChfKSwgXCIvKiMgXCIuY29uY2F0KE4sIFwiICovXCIpKSwgcCA9IGYuc291cmNlcy5tYXAoZnVuY3Rpb24oQSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoZi5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChBLCBcIiAqL1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2hdLmNvbmNhdChwKS5jb25jYXQoW3ZdKS5qb2luKGBcbmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBrLCBfLCBOO1xuICAgICAgICAgICAgICByZXR1cm4gW2hdLmpvaW4oYFxuYCk7XG4gICAgICAgICAgICB9KGEsIG4pO1xuICAgICAgICAgICAgcmV0dXJuIGFbMl0gPyBcIkBtZWRpYSBcIi5jb25jYXQoYVsyXSwgXCIge1wiKS5jb25jYXQobCwgXCJ9XCIpIDogbDtcbiAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB9LCByLmkgPSBmdW5jdGlvbihhLCBsLCBjKSB7XG4gICAgICAgICAgdHlwZW9mIGEgPT0gXCJzdHJpbmdcIiAmJiAoYSA9IFtbbnVsbCwgYSwgXCJcIl1dKTtcbiAgICAgICAgICB2YXIgdSA9IHt9O1xuICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCB0aGlzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgICAgIHZhciBmID0gdGhpc1toXVswXTtcbiAgICAgICAgICAgICAgZiAhPSBudWxsICYmICh1W2ZdID0gITApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgYS5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBbXS5jb25jYXQoYVt2XSk7XG4gICAgICAgICAgICBjICYmIHVbcFswXV0gfHwgKGwgJiYgKHBbMl0gPyBwWzJdID0gXCJcIi5jb25jYXQobCwgXCIgYW5kIFwiKS5jb25jYXQocFsyXSkgOiBwWzJdID0gbCksIHIucHVzaChwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICBpLnIobyksIGkuZChvLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSksIGkoMCk7XG4gICAgICBmdW5jdGlvbiBuKGwsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IDA7IHUgPCBjLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgdmFyIGggPSBjW3VdO1xuICAgICAgICAgIGguZW51bWVyYWJsZSA9IGguZW51bWVyYWJsZSB8fCAhMSwgaC5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGggJiYgKGgud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLCBoLmtleSwgaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHIobCwgYywgdSkge1xuICAgICAgICByZXR1cm4gYyAmJiBuKGwucHJvdG90eXBlLCBjKSwgdSAmJiBuKGwsIHUpLCBsO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBCYXNlIFBhcmFncmFwaCBCbG9jayBmb3IgdGhlIEVkaXRvci5qcy5cbiAgICAgICAqIFJlcHJlc2VudHMgc2ltcGxlIHBhcmFncmFwaFxuICAgICAgICpcbiAgICAgICAqIEBhdXRob3IgQ29kZVggKHRlYW1AY29kZXguc28pXG4gICAgICAgKiBAY29weXJpZ2h0IENvZGVYIDIwMThcbiAgICAgICAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICAgICAgICovXG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBsKGMpIHtcbiAgICAgICAgICB2YXIgdSA9IGMuZGF0YSwgaCA9IGMuY29uZmlnLCBmID0gYy5hcGksIHYgPSBjLnJlYWRPbmx5O1xuICAgICAgICAgIChmdW5jdGlvbihwLCBrKSB7XG4gICAgICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgaykpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgfSkodGhpcywgbCksIHRoaXMuYXBpID0gZiwgdGhpcy5yZWFkT25seSA9IHYsIHRoaXMuX0NTUyA9IHsgYmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jaywgd3JhcHBlcjogXCJjZS1wYXJhZ3JhcGhcIiB9LCB0aGlzLnJlYWRPbmx5IHx8ICh0aGlzLm9uS2V5VXAgPSB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSksIHRoaXMuX3BsYWNlaG9sZGVyID0gaC5wbGFjZWhvbGRlciA/IGgucGxhY2Vob2xkZXIgOiBsLkRFRkFVTFRfUExBQ0VIT0xERVIsIHRoaXMuX2RhdGEgPSB7fSwgdGhpcy5fZWxlbWVudCA9IHRoaXMuZHJhd1ZpZXcoKSwgdGhpcy5fcHJlc2VydmVCbGFuayA9IGgucHJlc2VydmVCbGFuayAhPT0gdm9pZCAwICYmIGgucHJlc2VydmVCbGFuaywgdGhpcy5kYXRhID0gdTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcihsLCBudWxsLCBbeyBrZXk6IFwiREVGQVVMVF9QTEFDRUhPTERFUlwiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9IH1dKSwgcihsLCBbeyBrZXk6IFwib25LZXlVcFwiLCB2YWx1ZTogZnVuY3Rpb24oYykge1xuICAgICAgICAgIGMuY29kZSAhPT0gXCJCYWNrc3BhY2VcIiAmJiBjLmNvZGUgIT09IFwiRGVsZXRlXCIgfHwgdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudCA9PT0gXCJcIiAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJkcmF3Vmlld1wiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO1xuICAgICAgICAgIHJldHVybiBjLmNsYXNzTGlzdC5hZGQodGhpcy5fQ1NTLndyYXBwZXIsIHRoaXMuX0NTUy5ibG9jayksIGMuY29udGVudEVkaXRhYmxlID0gITEsIGMuZGF0YXNldC5wbGFjZWhvbGRlciA9IHRoaXMuYXBpLmkxOG4udCh0aGlzLl9wbGFjZWhvbGRlciksIHRoaXMucmVhZE9ubHkgfHwgKGMuY29udGVudEVkaXRhYmxlID0gITAsIGMuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXlVcCkpLCBjO1xuICAgICAgICB9IH0sIHsga2V5OiBcInJlbmRlclwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwibWVyZ2VcIiwgdmFsdWU6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICB2YXIgdSA9IHsgdGV4dDogdGhpcy5kYXRhLnRleHQgKyBjLnRleHQgfTtcbiAgICAgICAgICB0aGlzLmRhdGEgPSB1O1xuICAgICAgICB9IH0sIHsga2V5OiBcInZhbGlkYXRlXCIsIHZhbHVlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuICEoYy50ZXh0LnRyaW0oKSA9PT0gXCJcIiAmJiAhdGhpcy5fcHJlc2VydmVCbGFuayk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2F2ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYykge1xuICAgICAgICAgIHJldHVybiB7IHRleHQ6IGMuaW5uZXJIVE1MIH07XG4gICAgICAgIH0gfSwgeyBrZXk6IFwib25QYXN0ZVwiLCB2YWx1ZTogZnVuY3Rpb24oYykge1xuICAgICAgICAgIHZhciB1ID0geyB0ZXh0OiBjLmRldGFpbC5kYXRhLmlubmVySFRNTCB9O1xuICAgICAgICAgIHRoaXMuZGF0YSA9IHU7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwiZGF0YVwiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5fZWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEudGV4dCA9IGMsIHRoaXMuX2RhdGE7XG4gICAgICAgIH0sIHNldDogZnVuY3Rpb24oYykge1xuICAgICAgICAgIHRoaXMuX2RhdGEgPSBjIHx8IHt9LCB0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCB8fCBcIlwiO1xuICAgICAgICB9IH1dLCBbeyBrZXk6IFwiY29udmVyc2lvbkNvbmZpZ1wiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IGV4cG9ydDogXCJ0ZXh0XCIsIGltcG9ydDogXCJ0ZXh0XCIgfTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJzYW5pdGl6ZVwiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IHRleHQ6IHsgYnI6ICEwIH0gfTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJpc1JlYWRPbmx5U3VwcG9ydGVkXCIsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9IH0sIHsga2V5OiBcInBhc3RlQ29uZmlnXCIsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdGFnczogW1wiUFwiXSB9O1xuICAgICAgICB9IH0sIHsga2V5OiBcInRvb2xib3hcIiwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4geyBpY29uOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOVY3LjJDOCA3LjA4OTU0IDguMDg5NTQgNyA4LjIgN0wxMiA3TTE2IDlWNy4yQzE2IDcuMDg5NTQgMTUuOTEwNSA3IDE1LjggN0wxMiA3TTEyIDdMMTIgMTdNMTIgMTdIMTBNMTIgMTdIMTRcIi8+PC9zdmc+JywgdGl0bGU6IFwiVGV4dFwiIH07XG4gICAgICAgIH0gfV0pLCBsO1xuICAgICAgfSgpO1xuICAgIH1dKS5kZWZhdWx0O1xuICB9KTtcbn0pKGVpKTtcbmNvbnN0IHRpID0gLyogQF9fUFVSRV9fICovIHhlKE5lKTtcbmNsYXNzICRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21tYW5kTmFtZSA9IFwiYm9sZFwiLCB0aGlzLkNTUyA9IHtcbiAgICAgIGJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbFwiLFxuICAgICAgYnV0dG9uQWN0aXZlOiBcImNlLWlubGluZS10b29sLS1hY3RpdmVcIixcbiAgICAgIGJ1dHRvbk1vZGlmaWVyOiBcImNlLWlubGluZS10b29sLS1ib2xkXCJcbiAgICB9LCB0aGlzLm5vZGVzID0ge1xuICAgICAgYnV0dG9uOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgUnVsZVxuICAgKiBMZWF2ZSA8Yj4gdGFnc1xuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYjoge31cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYnV0dG9uIGZvciBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIHRoaXMubm9kZXMuYnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvbiwgdGhpcy5DU1MuYnV0dG9uTW9kaWZpZXIpLCB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSBFbywgdGhpcy5ub2Rlcy5idXR0b247XG4gIH1cbiAgLyoqXG4gICAqIFdyYXAgcmFuZ2Ugd2l0aCA8Yj4gdGFnXG4gICAqL1xuICBzdXJyb3VuZCgpIHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmROYW1lKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgc2VsZWN0aW9uIGFuZCBzZXQgYWN0aXZhdGVkIHN0YXRlIHRvIGJ1dHRvbiBpZiB0aGVyZSBhcmUgPGI+IHRhZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNoZWNrU3RhdGUoKSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKHRoaXMuY29tbWFuZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuQ1NTLmJ1dHRvbkFjdGl2ZSwgZSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHNob3J0Y3V0XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIHJldHVybiBcIkNNRCtCXCI7XG4gIH1cbn1cbiRlLmlzSW5saW5lID0gITA7XG4kZS50aXRsZSA9IFwiQm9sZFwiO1xuY2xhc3MgV2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbW1hbmROYW1lID0gXCJpdGFsaWNcIiwgdGhpcy5DU1MgPSB7XG4gICAgICBidXR0b246IFwiY2UtaW5saW5lLXRvb2xcIixcbiAgICAgIGJ1dHRvbkFjdGl2ZTogXCJjZS1pbmxpbmUtdG9vbC0tYWN0aXZlXCIsXG4gICAgICBidXR0b25Nb2RpZmllcjogXCJjZS1pbmxpbmUtdG9vbC0taXRhbGljXCJcbiAgICB9LCB0aGlzLm5vZGVzID0ge1xuICAgICAgYnV0dG9uOiBudWxsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIFJ1bGVcbiAgICogTGVhdmUgPGk+IHRhZ3NcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGk6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJ1dHRvbiBmb3IgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCB0aGlzLm5vZGVzLmJ1dHRvbi50eXBlID0gXCJidXR0b25cIiwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b24sIHRoaXMuQ1NTLmJ1dHRvbk1vZGlmaWVyKSwgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0gU28sIHRoaXMubm9kZXMuYnV0dG9uO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwIHJhbmdlIHdpdGggPGk+IHRhZ1xuICAgKi9cbiAgc3Vycm91bmQoKSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHNlbGVjdGlvbiBhbmQgc2V0IGFjdGl2YXRlZCBzdGF0ZSB0byBidXR0b24gaWYgdGhlcmUgYXJlIDxpPiB0YWdcbiAgICovXG4gIGNoZWNrU3RhdGUoKSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKHRoaXMuY29tbWFuZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuQ1NTLmJ1dHRvbkFjdGl2ZSwgZSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHNob3J0Y3V0XG4gICAqL1xuICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgcmV0dXJuIFwiQ01EK0lcIjtcbiAgfVxufVxuV2UuaXNJbmxpbmUgPSAhMDtcbldlLnRpdGxlID0gXCJJdGFsaWNcIjtcbmNsYXNzIFllIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5jb21tYW5kTGluayA9IFwiY3JlYXRlTGlua1wiLCB0aGlzLmNvbW1hbmRVbmxpbmsgPSBcInVubGlua1wiLCB0aGlzLkVOVEVSX0tFWSA9IDEzLCB0aGlzLkNTUyA9IHtcbiAgICAgIGJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbFwiLFxuICAgICAgYnV0dG9uQWN0aXZlOiBcImNlLWlubGluZS10b29sLS1hY3RpdmVcIixcbiAgICAgIGJ1dHRvbk1vZGlmaWVyOiBcImNlLWlubGluZS10b29sLS1saW5rXCIsXG4gICAgICBidXR0b25Vbmxpbms6IFwiY2UtaW5saW5lLXRvb2wtLXVubGlua1wiLFxuICAgICAgaW5wdXQ6IFwiY2UtaW5saW5lLXRvb2wtaW5wdXRcIixcbiAgICAgIGlucHV0U2hvd2VkOiBcImNlLWlubGluZS10b29sLWlucHV0LS1zaG93ZWRcIlxuICAgIH0sIHRoaXMubm9kZXMgPSB7XG4gICAgICBidXR0b246IG51bGwsXG4gICAgICBpbnB1dDogbnVsbFxuICAgIH0sIHRoaXMuaW5wdXRPcGVuZWQgPSAhMSwgdGhpcy50b29sYmFyID0gZS50b29sYmFyLCB0aGlzLmlubGluZVRvb2xiYXIgPSBlLmlubGluZVRvb2xiYXIsIHRoaXMubm90aWZpZXIgPSBlLm5vdGlmaWVyLCB0aGlzLmkxOG4gPSBlLmkxOG4sIHRoaXMuc2VsZWN0aW9uID0gbmV3IG0oKTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIFJ1bGVcbiAgICogTGVhdmUgPGE+IHRhZ3NcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IHtcbiAgICAgICAgaHJlZjogITAsXG4gICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgcmVsOiBcIm5vZm9sbG93XCJcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYnV0dG9uIGZvciBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIHRoaXMubm9kZXMuYnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvbiwgdGhpcy5DU1MuYnV0dG9uTW9kaWZpZXIpLCB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSBxZSwgdGhpcy5ub2Rlcy5idXR0b247XG4gIH1cbiAgLyoqXG4gICAqIElucHV0IGZvciB0aGUgbGlua1xuICAgKi9cbiAgcmVuZGVyQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgdGhpcy5ub2Rlcy5pbnB1dC5wbGFjZWhvbGRlciA9IHRoaXMuaTE4bi50KFwiQWRkIGEgbGlua1wiKSwgdGhpcy5ub2Rlcy5pbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmlucHV0KSwgdGhpcy5ub2Rlcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgZS5rZXlDb2RlID09PSB0aGlzLkVOVEVSX0tFWSAmJiB0aGlzLmVudGVyUHJlc3NlZChlKTtcbiAgICB9KSwgdGhpcy5ub2Rlcy5pbnB1dDtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBvbiB0aGUgSW5saW5lIFRvb2xiYXIgaWNvblxuICAgKlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtIHJhbmdlIHRvIHdyYXAgd2l0aCBsaW5rXG4gICAqL1xuICBzdXJyb3VuZChlKSB7XG4gICAgaWYgKGUpIHtcbiAgICAgIHRoaXMuaW5wdXRPcGVuZWQgPyAodGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLnNlbGVjdGlvbi5yZW1vdmVGYWtlQmFja2dyb3VuZCgpKSA6ICh0aGlzLnNlbGVjdGlvbi5zZXRGYWtlQmFja2dyb3VuZCgpLCB0aGlzLnNlbGVjdGlvbi5zYXZlKCkpO1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VsZWN0aW9uLmZpbmRQYXJlbnRUYWcoXCJBXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uZXhwYW5kVG9UYWcodCksIHRoaXMudW5saW5rKCksIHRoaXMuY2xvc2VBY3Rpb25zKCksIHRoaXMuY2hlY2tTdGF0ZSgpLCB0aGlzLnRvb2xiYXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRvZ2dsZUFjdGlvbnMoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgc2VsZWN0aW9uIGFuZCBzZXQgYWN0aXZhdGVkIHN0YXRlIHRvIGJ1dHRvbiBpZiB0aGVyZSBhcmUgPGE+IHRhZ1xuICAgKi9cbiAgY2hlY2tTdGF0ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zZWxlY3Rpb24uZmluZFBhcmVudFRhZyhcIkFcIik7XG4gICAgaWYgKGUpIHtcbiAgICAgIHRoaXMubm9kZXMuYnV0dG9uLmlubmVySFRNTCA9IE9vLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvblVubGluayksIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYnV0dG9uQWN0aXZlKSwgdGhpcy5vcGVuQWN0aW9ucygpO1xuICAgICAgY29uc3QgdCA9IGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgIHRoaXMubm9kZXMuaW5wdXQudmFsdWUgPSB0ICE9PSBcIm51bGxcIiA/IHQgOiBcIlwiLCB0aGlzLnNlbGVjdGlvbi5zYXZlKCk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSBxZSwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5idXR0b25VbmxpbmspLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLmJ1dHRvbkFjdGl2ZSk7XG4gICAgcmV0dXJuICEhZTtcbiAgfVxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIHdpdGggSW5saW5lIFRvb2xiYXIgY2xvc2luZ1xuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jbG9zZUFjdGlvbnMoKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgc2hvcnRjdXRcbiAgICovXG4gIGdldCBzaG9ydGN1dCgpIHtcbiAgICByZXR1cm4gXCJDTUQrS1wiO1xuICB9XG4gIC8qKlxuICAgKiBTaG93L2Nsb3NlIGxpbmsgaW5wdXRcbiAgICovXG4gIHRvZ2dsZUFjdGlvbnMoKSB7XG4gICAgdGhpcy5pbnB1dE9wZW5lZCA/IHRoaXMuY2xvc2VBY3Rpb25zKCExKSA6IHRoaXMub3BlbkFjdGlvbnMoITApO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZWRGb2N1cyAtIG9uIGxpbmsgY3JlYXRpb24gd2UgbmVlZCB0byBmb2N1cyBpbnB1dC4gT24gZWRpdGluZyAtIG5vcGUuXG4gICAqL1xuICBvcGVuQWN0aW9ucyhlID0gITEpIHtcbiAgICB0aGlzLm5vZGVzLmlucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuaW5wdXRTaG93ZWQpLCBlICYmIHRoaXMubm9kZXMuaW5wdXQuZm9jdXMoKSwgdGhpcy5pbnB1dE9wZW5lZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyU2F2ZWRTZWxlY3Rpb24g4oCUIHdlIGRvbid0IG5lZWQgdG8gY2xlYXIgc2F2ZWQgc2VsZWN0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRvZ2dsZS1jbGlja3Mgb24gdGhlIGljb24gb2Ygb3BlbmVkIFRvb2xiYXJcbiAgICovXG4gIGNsb3NlQWN0aW9ucyhlID0gITApIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBuZXcgbSgpO1xuICAgICAgdC5zYXZlKCksIHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlRmFrZUJhY2tncm91bmQoKSwgdC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMubm9kZXMuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5pbnB1dFNob3dlZCksIHRoaXMubm9kZXMuaW5wdXQudmFsdWUgPSBcIlwiLCBlICYmIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2F2ZWQoKSwgdGhpcy5pbnB1dE9wZW5lZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBFbnRlciBwcmVzc2VkIG9uIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBlbnRlciBrZXlkb3duIGV2ZW50XG4gICAqL1xuICBlbnRlclByZXNzZWQoZSkge1xuICAgIGxldCB0ID0gdGhpcy5ub2Rlcy5pbnB1dC52YWx1ZSB8fCBcIlwiO1xuICAgIGlmICghdC50cmltKCkpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy51bmxpbmsoKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmNsb3NlQWN0aW9ucygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVVUkwodCkpIHtcbiAgICAgIHRoaXMubm90aWZpZXIuc2hvdyh7XG4gICAgICAgIG1lc3NhZ2U6IFwiUGFzdGVkIGxpbmsgaXMgbm90IHZhbGlkLlwiLFxuICAgICAgICBzdHlsZTogXCJlcnJvclwiXG4gICAgICB9KSwgVChcIkluY29ycmVjdCBMaW5rIHBhc3RlZFwiLCBcIndhcm5cIiwgdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgPSB0aGlzLnByZXBhcmVMaW5rKHQpLCB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLnJlbW92ZUZha2VCYWNrZ3JvdW5kKCksIHRoaXMuaW5zZXJ0TGluayh0KSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLnNlbGVjdGlvbi5jb2xsYXBzZVRvRW5kKCksIHRoaXMuaW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3RzIGlmIHBhc3NlZCBzdHJpbmcgaXMgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZVVSTChlKSB7XG4gICAgcmV0dXJuICEvXFxzLy50ZXN0KGUpO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGxpbmsgYmVmb3JlIGluamVjdGlvblxuICAgKiAtIHNhbml0aXplXG4gICAqIC0gYWRkIHByb3RvY29sIGZvciBsaW5rcyBsaWtlICdnb29nbGUuY29tJ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluayAtIHJhdyB1c2VyIGlucHV0XG4gICAqL1xuICBwcmVwYXJlTGluayhlKSB7XG4gICAgcmV0dXJuIGUgPSBlLnRyaW0oKSwgZSA9IHRoaXMuYWRkUHJvdG9jb2woZSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCAnaHR0cCcgcHJvdG9jb2wgdG8gdGhlIGxpbmtzIGxpa2UgJ3ZjLnJ1JywgJ2dvb2dsZS5jb20nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIC0gc3RyaW5nIHRvIHByb2Nlc3NcbiAgICovXG4gIGFkZFByb3RvY29sKGUpIHtcbiAgICBpZiAoL14oXFx3Kyk6KFxcL1xcLyk/Ly50ZXN0KGUpKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgdCA9IC9eXFwvW14vXFxzXS8udGVzdChlKSwgbyA9IGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIiNcIiwgaSA9IC9eXFwvXFwvW14vXFxzXS8udGVzdChlKTtcbiAgICByZXR1cm4gIXQgJiYgIW8gJiYgIWkgJiYgKGUgPSBcImh0dHA6Ly9cIiArIGUpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIDxhPiB0YWcgd2l0aCBcImhyZWZcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluayAtIFwiaHJlZlwiIHZhbHVlXG4gICAqL1xuICBpbnNlcnRMaW5rKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZWxlY3Rpb24uZmluZFBhcmVudFRhZyhcIkFcIik7XG4gICAgdCAmJiB0aGlzLnNlbGVjdGlvbi5leHBhbmRUb1RhZyh0KSwgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kTGluaywgITEsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIDxhPiB0YWdcbiAgICovXG4gIHVubGluaygpIHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmRVbmxpbmspO1xuICB9XG59XG5ZZS5pc0lubGluZSA9ICEwO1xuWWUudGl0bGUgPSBcIkxpbmtcIjtcbmNsYXNzIHl0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gY29uc3RydWN0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gc3R1YiB0b29sIGRhdGFcbiAgICogQHBhcmFtIG9wdGlvbnMuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiBlLCBhcGk6IHQgfSkge1xuICAgIHRoaXMuQ1NTID0ge1xuICAgICAgd3JhcHBlcjogXCJjZS1zdHViXCIsXG4gICAgICBpbmZvOiBcImNlLXN0dWJfX2luZm9cIixcbiAgICAgIHRpdGxlOiBcImNlLXN0dWJfX3RpdGxlXCIsXG4gICAgICBzdWJ0aXRsZTogXCJjZS1zdHViX19zdWJ0aXRsZVwiXG4gICAgfSwgdGhpcy5hcGkgPSB0LCB0aGlzLnRpdGxlID0gZS50aXRsZSB8fCB0aGlzLmFwaS5pMThuLnQoXCJFcnJvclwiKSwgdGhpcy5zdWJ0aXRsZSA9IHRoaXMuYXBpLmkxOG4udChcIlRoZSBibG9jayBjYW4gbm90IGJlIGRpc3BsYXllZCBjb3JyZWN0bHkuXCIpLCB0aGlzLnNhdmVkRGF0YSA9IGUuc2F2ZWREYXRhLCB0aGlzLndyYXBwZXIgPSB0aGlzLm1ha2UoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzdHViIGhvbGRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIG9yaWdpbmFsIFRvb2wgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2tUb29sRGF0YX1cbiAgICovXG4gIHNhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F2ZWREYXRhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVG9vbCBodG1sIG1hcmt1cFxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBtYWtlKCkge1xuICAgIGNvbnN0IGUgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1Mud3JhcHBlciksIHQgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCI1MlwiIGhlaWdodD1cIjUyXCIgdmlld0JveD1cIjAgMCA1MiA1MlwiPjxwYXRoIGZpbGw9XCIjRDc2QjZCXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiIGQ9XCJNMjYgNTJDMTEuNjQgNTIgMCA0MC4zNiAwIDI2UzExLjY0IDAgMjYgMHMyNiAxMS42NCAyNiAyNi0xMS42NCAyNi0yNiAyNnptMC0zLjI1YzEyLjU2NCAwIDIyLjc1LTEwLjE4NiAyMi43NS0yMi43NVMzOC41NjQgMy4yNSAyNiAzLjI1IDMuMjUgMTMuNDM2IDMuMjUgMjYgMTMuNDM2IDQ4Ljc1IDI2IDQ4Ljc1ek0xNS43MDggMzMuMDQyYTIuMTY3IDIuMTY3IDAgMSAxIDAtNC4zMzQgMi4xNjcgMi4xNjcgMCAwIDEgMCA0LjMzNHptMjMuODM0IDBhMi4xNjcgMi4xNjcgMCAxIDEgMC00LjMzNCAyLjE2NyAyLjE2NyAwIDAgMSAwIDQuMzM0em0tMTUuODc1IDUuNDUyYTEuMDgzIDEuMDgzIDAgMSAxLTEuODM0LTEuMTU1YzEuMzMxLTIuMTE0IDMuNDktMy4xNzkgNi4zMzQtMy4xNzkgMi44NDQgMCA1LjAwMiAxLjA2NSA2LjMzMyAzLjE4YTEuMDgzIDEuMDgzIDAgMSAxLTEuODMzIDEuMTU0Yy0uOTEzLTEuNDUtMi4zNjYtMi4xNjctNC41LTIuMTY3cy0zLjU4Ny43MTctNC41IDIuMTY3elwiLz48L3N2Zz4nLCBvID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLmluZm8pLCBpID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnRpdGxlLCB7XG4gICAgICB0ZXh0Q29udGVudDogdGhpcy50aXRsZVxuICAgIH0pLCBuID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnN1YnRpdGxlLCB7XG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5zdWJ0aXRsZVxuICAgIH0pO1xuICAgIHJldHVybiBlLmlubmVySFRNTCA9IHQsIG8uYXBwZW5kQ2hpbGQoaSksIG8uYXBwZW5kQ2hpbGQobiksIGUuYXBwZW5kQ2hpbGQobyksIGU7XG4gIH1cbn1cbnl0LmlzUmVhZE9ubHlTdXBwb3J0ZWQgPSAhMDtcbmNsYXNzIG9pIGV4dGVuZHMgVWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSB5ZS5JbmxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGl0bGUgZm9yIElubGluZSBUb29sIGlmIHNwZWNpZmllZCBieSB1c2VyXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtqZS5UaXRsZV07XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgbmV3IElubGluZVRvb2wgaW5zdGFuY2UgZnJvbSBjb25zdHJ1Y3RhYmxlXG4gICAqL1xuICBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdGFibGUoe1xuICAgICAgYXBpOiB0aGlzLmFwaS5nZXRNZXRob2RzRm9yVG9vbCh0aGlzKSxcbiAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5nc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBpaSBleHRlbmRzIFVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0geWUuVHVuZTtcbiAgfVxuICAvKipcbiAgICogQ29uc3RydWN0cyBuZXcgQmxvY2tUdW5lIGluc3RhbmNlIGZyb20gY29uc3RydWN0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFR1bmUgZGF0YVxuICAgKiBAcGFyYW0gYmxvY2sgLSBCbG9jayBBUEkgb2JqZWN0XG4gICAqL1xuICBjcmVhdGUoZSwgdCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RhYmxlKHtcbiAgICAgIGFwaTogdGhpcy5hcGkuZ2V0TWV0aG9kc0ZvclRvb2wodGhpcyksXG4gICAgICBjb25maWc6IHRoaXMuc2V0dGluZ3MsXG4gICAgICBibG9jazogdCxcbiAgICAgIGRhdGE6IGVcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVSBleHRlbmRzIE1hcCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrIFRvb2xzIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBibG9ja1Rvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzQmxvY2soKSk7XG4gICAgcmV0dXJuIG5ldyBVKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIElubGluZSBUb29scyBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgaW5saW5lVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+IHQuaXNJbmxpbmUoKSk7XG4gICAgcmV0dXJuIG5ldyBVKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrIFR1bmVzIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBibG9ja1R1bmVzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzVHVuZSgpKTtcbiAgICByZXR1cm4gbmV3IFUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW50ZXJuYWwgVG9vbHMgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0IGludGVybmFsVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+IHQuaXNJbnRlcm5hbCk7XG4gICAgcmV0dXJuIG5ldyBVKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2xzIGNvbGxlY3Rpb24gcHJvdmlkZWQgYnkgdXNlclxuICAgKi9cbiAgZ2V0IGV4dGVybmFsVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IEFycmF5LmZyb20odGhpcy5lbnRyaWVzKCkpLmZpbHRlcigoWywgdF0pID0+ICF0LmlzSW50ZXJuYWwpO1xuICAgIHJldHVybiBuZXcgVShlKTtcbiAgfVxufVxudmFyIG5pID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIEV0ID0gKHMsIGUsIHQsIG8pID0+IHtcbiAgZm9yICh2YXIgaSA9IG8gPiAxID8gdm9pZCAwIDogbyA/IHNpKGUsIHQpIDogZSwgbiA9IHMubGVuZ3RoIC0gMSwgcjsgbiA+PSAwOyBuLS0pXG4gICAgKHIgPSBzW25dKSAmJiAoaSA9IChvID8gcihlLCB0LCBpKSA6IHIoaSkpIHx8IGkpO1xuICByZXR1cm4gbyAmJiBpICYmIG5pKGUsIHQsIGkpLCBpO1xufTtcbmNsYXNzIEtlIGV4dGVuZHMgVWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSB5ZS5CbG9jaywgdGhpcy5pbmxpbmVUb29scyA9IG5ldyBVKCksIHRoaXMudHVuZXMgPSBuZXcgVSgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG5ldyBUb29sIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gVG9vbCBkYXRhXG4gICAqIEBwYXJhbSBibG9jayAtIEJsb2NrQVBJIGZvciBjdXJyZW50IEJsb2NrXG4gICAqIEBwYXJhbSByZWFkT25seSAtIFRydWUgaWYgRWRpdG9yIGlzIGluIHJlYWQtb25seSBtb2RlXG4gICAqL1xuICBjcmVhdGUoZSwgdCwgbykge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RhYmxlKHtcbiAgICAgIGRhdGE6IGUsXG4gICAgICBibG9jazogdCxcbiAgICAgIHJlYWRPbmx5OiBvLFxuICAgICAgYXBpOiB0aGlzLmFwaS5nZXRNZXRob2RzRm9yVG9vbCh0aGlzKSxcbiAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5nc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkIGJ5IFRvb2xcbiAgICovXG4gIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGVbc2UuSXNSZWFkT25seVN1cHBvcnRlZF0gPT09ICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgVG9vbCBzdXBwb3J0cyBsaW5lYnJlYWtzXG4gICAqL1xuICBnZXQgaXNMaW5lQnJlYWtzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW3NlLklzRW5hYmxlZExpbmVCcmVha3NdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2wgdG9vbGJveCBjb25maWd1cmF0aW9uIChpbnRlcm5hbCBvciB1c2VyLXNwZWNpZmllZCkuXG4gICAqXG4gICAqIE1lcmdlcyBpbnRlcm5hbCBhbmQgdXNlci1kZWZpbmVkIHRvb2xib3ggY29uZmlncyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICAgKlxuICAgKiAtIElmIGJvdGggaW50ZXJuYWwgYW5kIHVzZXItZGVmaW5lZCB0b29sYm94IGNvbmZpZ3MgYXJlIGFycmF5cyB0aGVpciBpdGVtcyBhcmUgbWVyZ2VkLlxuICAgKiBMZW5ndGggb2YgdGhlIHNlY29uZCBvbmUgaXMga2VwdC5cbiAgICpcbiAgICogLSBJZiBib3RoIGFyZSBvYmplY3RzIHRoZWlyIHByb3BlcnRpZXMgYXJlIG1lcmdlZC5cbiAgICpcbiAgICogLSBJZiBvbmUgaXMgYW4gb2JqZWN0IGFuZCBhbm90aGVyIGlzIGFuIGFycmF5IHRoYW4gaW50ZXJuYWwgY29uZmlnIGlzIHJlcGxhY2VkIHdpdGggdXNlci1kZWZpbmVkXG4gICAqIGNvbmZpZy4gVGhpcyBpcyBtYWRlIHRvIGFsbG93IHVzZXIgdG8gb3ZlcnJpZGUgZGVmYXVsdCB0b29sJ3MgdG9vbGJveCByZXByZXNlbnRhdGlvbiAoc2luZ2xlL211bHRpcGxlIGVudHJpZXMpXG4gICAqL1xuICBnZXQgdG9vbGJveCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb25zdHJ1Y3RhYmxlW3NlLlRvb2xib3hdLCB0ID0gdGhpcy5jb25maWdbbWUuVG9vbGJveF07XG4gICAgaWYgKCFWKGUpICYmIHQgIT09ICExKVxuICAgICAgcmV0dXJuIHQgPyBBcnJheS5pc0FycmF5KGUpID8gQXJyYXkuaXNBcnJheSh0KSA/IHQubWFwKChvLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgICByZXR1cm4gbiA/IHtcbiAgICAgICAgICAuLi5uLFxuICAgICAgICAgIC4uLm9cbiAgICAgICAgfSA6IG87XG4gICAgICB9KSA6IFt0XSA6IEFycmF5LmlzQXJyYXkodCkgPyB0IDogW1xuICAgICAgICB7XG4gICAgICAgICAgLi4uZSxcbiAgICAgICAgICAuLi50XG4gICAgICAgIH1cbiAgICAgIF0gOiBBcnJheS5pc0FycmF5KGUpID8gZSA6IFtlXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIGNvbnZlcnNpb24gY29uZmlndXJhdGlvblxuICAgKi9cbiAgZ2V0IGNvbnZlcnNpb25Db25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtzZS5Db252ZXJzaW9uQ29uZmlnXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBlbmFibGVkIGlubGluZSB0b29scyBmb3IgVG9vbFxuICAgKi9cbiAgZ2V0IGVuYWJsZWRJbmxpbmVUb29scygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdbbWUuRW5hYmxlZElubGluZVRvb2xzXSB8fCAhMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBlbmFibGVkIHR1bmVzIGZvciBUb29sXG4gICAqL1xuICBnZXQgZW5hYmxlZEJsb2NrVHVuZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnW21lLkVuYWJsZWRCbG9ja1R1bmVzXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIHBhc3RlIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW3NlLlBhc3RlQ29uZmlnXSA/PyB7fTtcbiAgfVxuICBnZXQgc2FuaXRpemVDb25maWcoKSB7XG4gICAgY29uc3QgZSA9IHN1cGVyLnNhbml0aXplQ29uZmlnLCB0ID0gdGhpcy5iYXNlU2FuaXRpemVDb25maWc7XG4gICAgaWYgKFYoZSkpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBvID0ge307XG4gICAgZm9yIChjb25zdCBpIGluIGUpXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIGkpKSB7XG4gICAgICAgIGNvbnN0IG4gPSBlW2ldO1xuICAgICAgICBqKG4pID8gb1tpXSA9IE9iamVjdC5hc3NpZ24oe30sIHQsIG4pIDogb1tpXSA9IG47XG4gICAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgZ2V0IGJhc2VTYW5pdGl6ZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pbmxpbmVUb29scy52YWx1ZXMoKSkuZm9yRWFjaCgodCkgPT4gT2JqZWN0LmFzc2lnbihlLCB0LnNhbml0aXplQ29uZmlnKSksIEFycmF5LmZyb20odGhpcy50dW5lcy52YWx1ZXMoKSkuZm9yRWFjaCgodCkgPT4gT2JqZWN0LmFzc2lnbihlLCB0LnNhbml0aXplQ29uZmlnKSksIGU7XG4gIH1cbn1cbkV0KFtcbiAgYWVcbl0sIEtlLnByb3RvdHlwZSwgXCJzYW5pdGl6ZUNvbmZpZ1wiLCAxKTtcbkV0KFtcbiAgYWVcbl0sIEtlLnByb3RvdHlwZSwgXCJiYXNlU2FuaXRpemVDb25maWdcIiwgMSk7XG5jbGFzcyByaSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIGNvbmZpZyAtIHRvb2xzIGNvbmZpZ1xuICAgKiBAcGFyYW0gZWRpdG9yQ29uZmlnIC0gRWRpdG9ySlMgY29uZmlnXG4gICAqIEBwYXJhbSBhcGkgLSBFZGl0b3JKUyBBUEkgbW9kdWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0LCBvKSB7XG4gICAgdGhpcy5hcGkgPSBvLCB0aGlzLmNvbmZpZyA9IGUsIHRoaXMuZWRpdG9yQ29uZmlnID0gdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIG9iamVjdCBiYXNlZCBvbiBpdCdzIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB0b29sIG5hbWVcbiAgICovXG4gIGdldChlKSB7XG4gICAgY29uc3QgeyBjbGFzczogdCwgaXNJbnRlcm5hbDogbyA9ICExLCAuLi5pIH0gPSB0aGlzLmNvbmZpZ1tlXSwgbiA9IHRoaXMuZ2V0Q29uc3RydWN0b3IodCk7XG4gICAgcmV0dXJuIG5ldyBuKHtcbiAgICAgIG5hbWU6IGUsXG4gICAgICBjb25zdHJ1Y3RhYmxlOiB0LFxuICAgICAgY29uZmlnOiBpLFxuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGlzRGVmYXVsdDogZSA9PT0gdGhpcy5lZGl0b3JDb25maWcuZGVmYXVsdEJsb2NrLFxuICAgICAgZGVmYXVsdFBsYWNlaG9sZGVyOiB0aGlzLmVkaXRvckNvbmZpZy5wbGFjZWhvbGRlcixcbiAgICAgIGlzSW50ZXJuYWw6IG9cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhcHByb3ByaWF0ZSBUb29sIG9iamVjdCBjb25zdHJ1Y3RvciBmb3IgVG9vbCBjb25zdHJ1Y3RhYmxlXG4gICAqXG4gICAqIEBwYXJhbSBjb25zdHJ1Y3RhYmxlIC0gVG9vbHMgY29uc3RydWN0YWJsZVxuICAgKi9cbiAgZ2V0Q29uc3RydWN0b3IoZSkge1xuICAgIHN3aXRjaCAoITApIHtcbiAgICAgIGNhc2UgZVtqZS5Jc0lubGluZV06XG4gICAgICAgIHJldHVybiBvaTtcbiAgICAgIGNhc2UgZVt2dC5Jc1R1bmVdOlxuICAgICAgICByZXR1cm4gaWk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gS2U7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCdCB7XG4gIC8qKlxuICAgKiBNb3ZlRG93blR1bmUgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtBUEl9IGFwaSDigJQgRWRpdG9yJ3MgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5DU1MgPSB7XG4gICAgICBhbmltYXRpb246IFwid29iYmxlXCJcbiAgICB9LCB0aGlzLmFwaSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFR1bmUncyBhcHBlYXJhbmNlIGluIGJsb2NrIHNldHRpbmdzIG1lbnVcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogcHQsXG4gICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiTW92ZSBkb3duXCIpLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5oYW5kbGVDbGljaygpLFxuICAgICAgbmFtZTogXCJtb3ZlLWRvd25cIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3Mgb24gJ21vdmUgZG93bicgYnV0dG9uXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksIHQgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KGUgKyAxKTtcbiAgICBpZiAoIXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbW92ZSBCbG9jayBkb3duIHNpbmNlIGl0IGlzIGFscmVhZHkgdGhlIGxhc3RcIik7XG4gICAgY29uc3QgbyA9IHQuaG9sZGVyLCBpID0gby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgbiA9IE1hdGguYWJzKHdpbmRvdy5pbm5lckhlaWdodCAtIG8ub2Zmc2V0SGVpZ2h0KTtcbiAgICBpLnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCAmJiAobiA9IHdpbmRvdy5zY3JvbGxZICsgby5vZmZzZXRIZWlnaHQpLCB3aW5kb3cuc2Nyb2xsVG8oMCwgbiksIHRoaXMuYXBpLmJsb2Nrcy5tb3ZlKGUgKyAxKSwgdGhpcy5hcGkudG9vbGJhci50b2dnbGVCbG9ja1NldHRpbmdzKCEwKTtcbiAgfVxufVxuQnQuaXNUdW5lID0gITA7XG5jbGFzcyBDdCB7XG4gIC8qKlxuICAgKiBEZWxldGVUdW5lIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7QVBJfSBhcGkgLSBFZGl0b3IncyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlIH0pIHtcbiAgICB0aGlzLmFwaSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFR1bmUncyBhcHBlYXJhbmNlIGluIGJsb2NrIHNldHRpbmdzIG1lbnVcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogQ28sXG4gICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiRGVsZXRlXCIpLFxuICAgICAgbmFtZTogXCJkZWxldGVcIixcbiAgICAgIGNvbmZpcm1hdGlvbjoge1xuICAgICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiQ2xpY2sgdG8gZGVsZXRlXCIpLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiB0aGlzLmhhbmRsZUNsaWNrKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYmxvY2sgY29uZGl0aW9ucyBwYXNzZWRcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMuYXBpLmJsb2Nrcy5kZWxldGUoKTtcbiAgfVxufVxuQ3QuaXNUdW5lID0gITA7XG5jbGFzcyBUdCB7XG4gIC8qKlxuICAgKiBNb3ZlVXBUdW5lIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7QVBJfSBhcGkgLSBFZGl0b3IncyBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgYXBpOiBlIH0pIHtcbiAgICB0aGlzLkNTUyA9IHtcbiAgICAgIGFuaW1hdGlvbjogXCJ3b2JibGVcIlxuICAgIH0sIHRoaXMuYXBpID0gZTtcbiAgfVxuICAvKipcbiAgICogVHVuZSdzIGFwcGVhcmFuY2UgaW4gYmxvY2sgc2V0dGluZ3MgbWVudVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBCbyxcbiAgICAgIHRpdGxlOiB0aGlzLmFwaS5pMThuLnQoXCJNb3ZlIHVwXCIpLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5oYW5kbGVDbGljaygpLFxuICAgICAgbmFtZTogXCJtb3ZlLXVwXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGN1cnJlbnQgYmxvY2sgdXBcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgdCA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgoZSksIG8gPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KGUgLSAxKTtcbiAgICBpZiAoZSA9PT0gMCB8fCAhdCB8fCAhbylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBtb3ZlIEJsb2NrIHVwIHNpbmNlIGl0IGlzIGFscmVhZHkgdGhlIGZpcnN0XCIpO1xuICAgIGNvbnN0IGkgPSB0LmhvbGRlciwgbiA9IG8uaG9sZGVyLCByID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYSA9IG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGw7XG4gICAgYS50b3AgPiAwID8gbCA9IE1hdGguYWJzKHIudG9wKSAtIE1hdGguYWJzKGEudG9wKSA6IGwgPSBNYXRoLmFicyhyLnRvcCkgKyBhLmhlaWdodCwgd2luZG93LnNjcm9sbEJ5KDAsIC0xICogbCksIHRoaXMuYXBpLmJsb2Nrcy5tb3ZlKGUgLSAxKSwgdGhpcy5hcGkudG9vbGJhci50b2dnbGVCbG9ja1NldHRpbmdzKCEwKTtcbiAgfVxufVxuVHQuaXNUdW5lID0gITA7XG52YXIgYWkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGxpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgY2kgPSAocywgZSwgdCwgbykgPT4ge1xuICBmb3IgKHZhciBpID0gbyA+IDEgPyB2b2lkIDAgOiBvID8gbGkoZSwgdCkgOiBlLCBuID0gcy5sZW5ndGggLSAxLCByOyBuID49IDA7IG4tLSlcbiAgICAociA9IHNbbl0pICYmIChpID0gKG8gPyByKGUsIHQsIGkpIDogcihpKSkgfHwgaSk7XG4gIHJldHVybiBvICYmIGkgJiYgYWkoZSwgdCwgaSksIGk7XG59O1xuY2xhc3MgU3QgZXh0ZW5kcyBTIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5zdHViVG9vbCA9IFwic3R1YlwiLCB0aGlzLnRvb2xzQXZhaWxhYmxlID0gbmV3IFUoKSwgdGhpcy50b29sc1VuYXZhaWxhYmxlID0gbmV3IFUoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhdmFpbGFibGUgVG9vbHNcbiAgICovXG4gIGdldCBhdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHNBdmFpbGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdW5hdmFpbGFibGUgVG9vbHNcbiAgICovXG4gIGdldCB1bmF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sc1VuYXZhaWxhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbHMgZm9yIHRoZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgZ2V0IGlubGluZVRvb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZS5pbmxpbmVUb29scztcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGVkaXRvciBibG9jayB0b29sc1xuICAgKi9cbiAgZ2V0IGJsb2NrVG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlLmJsb2NrVG9vbHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhdmFpbGFibGUgQmxvY2sgVHVuZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gLSBvYmplY3Qgb2YgSW5saW5lIFRvb2wncyBjbGFzc2VzXG4gICAqL1xuICBnZXQgYmxvY2tUdW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGUuYmxvY2tUdW5lcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0IFRvb2wgb2JqZWN0XG4gICAqL1xuICBnZXQgZGVmYXVsdFRvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tUb29scy5nZXQodGhpcy5jb25maWcuZGVmYXVsdEJsb2NrKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbnRlcm5hbCB0b29sc1xuICAgKi9cbiAgZ2V0IGludGVybmFsKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZS5pbnRlcm5hbFRvb2xzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGluc3RhbmNlcyB2aWEgcGFzc2VkIG9yIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUb29scygpLCB0aGlzLmNvbmZpZy50b29scyA9IFNlKHt9LCB0aGlzLmludGVybmFsVG9vbHMsIHRoaXMuY29uZmlnLnRvb2xzKSwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbmZpZywgXCJ0b29sc1wiKSB8fCBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy50b29scykubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBzdGFydCB3aXRob3V0IHRvb2xzXCIpO1xuICAgIGNvbnN0IGUgPSB0aGlzLnByZXBhcmVDb25maWcoKTtcbiAgICB0aGlzLmZhY3RvcnkgPSBuZXcgcmkoZSwgdGhpcy5jb25maWcsIHRoaXMuRWRpdG9yLkFQSSk7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0TGlzdE9mUHJlcGFyZUZ1bmN0aW9ucyhlKTtcbiAgICBpZiAodC5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgYXdhaXQgb3QodCwgKG8pID0+IHtcbiAgICAgIHRoaXMudG9vbFByZXBhcmVNZXRob2RTdWNjZXNzKG8pO1xuICAgIH0sIChvKSA9PiB7XG4gICAgICB0aGlzLnRvb2xQcmVwYXJlTWV0aG9kRmFsbGJhY2sobyk7XG4gICAgfSksIHRoaXMucHJlcGFyZUJsb2NrVG9vbHMoKTtcbiAgfVxuICBnZXRBbGxJbmxpbmVUb29sc1Nhbml0aXplQ29uZmlnKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlubGluZVRvb2xzLnZhbHVlcygpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKGUsIHQuc2FuaXRpemVDb25maWcpO1xuICAgIH0pLCBlO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBlYWNoIFRvb2wgcmVzZXQgbWV0aG9kIHRvIGNsZWFuIHVwIGFueXRoaW5nIHNldCBieSBUb29sXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5hdmFpbGFibGUpLmZvckVhY2goYXN5bmMgKGUpID0+IHtcbiAgICAgIEQoZS5yZXNldCkgJiYgYXdhaXQgZS5yZXNldCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGludGVybmFsIHRvb2xzXG4gICAqIEluY2x1ZGVzIEJvbGQsIEl0YWxpYywgTGluayBhbmQgUGFyYWdyYXBoXG4gICAqL1xuICBnZXQgaW50ZXJuYWxUb29scygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYm9sZDoge1xuICAgICAgICBjbGFzczogJGUsXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgaXRhbGljOiB7XG4gICAgICAgIGNsYXNzOiBXZSxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBsaW5rOiB7XG4gICAgICAgIGNsYXNzOiBZZSxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgY2xhc3M6IHRpLFxuICAgICAgICBpbmxpbmVUb29sYmFyOiAhMCxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBzdHViOiB7XG4gICAgICAgIGNsYXNzOiB5dCxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBtb3ZlVXA6IHtcbiAgICAgICAgY2xhc3M6IFR0LFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIGRlbGV0ZToge1xuICAgICAgICBjbGFzczogQ3QsXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgbW92ZURvd246IHtcbiAgICAgICAgY2xhc3M6IEJ0LFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRvb2wgcHJlcGFyZSBtZXRob2Qgc3VjY2VzcyBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGFwcGVuZCB0b29sIHRvIGF2YWlsYWJsZSBsaXN0XG4gICAqL1xuICB0b29sUHJlcGFyZU1ldGhvZFN1Y2Nlc3MoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmZhY3RvcnkuZ2V0KGUudG9vbE5hbWUpO1xuICAgIGlmICh0LmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnN0IGkgPSBbXCJyZW5kZXJcIiwgXCJzdXJyb3VuZFwiLCBcImNoZWNrU3RhdGVcIl0uZmlsdGVyKChuKSA9PiAhdC5jcmVhdGUoKVtuXSk7XG4gICAgICBpZiAoaS5sZW5ndGgpIHtcbiAgICAgICAgVChcbiAgICAgICAgICBgSW5jb3JyZWN0IElubGluZSBUb29sOiAke3QubmFtZX0uIFNvbWUgb2YgcmVxdWlyZWQgbWV0aG9kcyBpcyBub3QgaW1wbGVtZW50ZWQgJW9gLFxuICAgICAgICAgIFwid2FyblwiLFxuICAgICAgICAgIGlcbiAgICAgICAgKSwgdGhpcy50b29sc1VuYXZhaWxhYmxlLnNldCh0Lm5hbWUsIHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudG9vbHNBdmFpbGFibGUuc2V0KHQubmFtZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvb2wgcHJlcGFyZSBtZXRob2QgZmFpbCBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGFwcGVuZCB0b29sIHRvIHVuYXZhaWxhYmxlIGxpc3RcbiAgICovXG4gIHRvb2xQcmVwYXJlTWV0aG9kRmFsbGJhY2soZSkge1xuICAgIHRoaXMudG9vbHNVbmF2YWlsYWJsZS5zZXQoZS50b29sTmFtZSwgdGhpcy5mYWN0b3J5LmdldChlLnRvb2xOYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIHByZXBhcmUgZnVuY3Rpb24gb2YgcGx1Z2lucyB3aXRoIHVzZXIgb3IgZGVmYXVsdCBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IG5lZWRzIHRvIGJlIGZpcmVkIHNlcXVlbnRpYWxseVxuICAgKiBAcGFyYW0gY29uZmlnIC0gdG9vbHMgY29uZmlnXG4gICAqL1xuICBnZXRMaXN0T2ZQcmVwYXJlRnVuY3Rpb25zKGUpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLCBpXSkgPT4ge1xuICAgICAgdC5wdXNoKHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICBmdW5jdGlvbjogRChpLmNsYXNzLnByZXBhcmUpID8gaS5jbGFzcy5wcmVwYXJlIDogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG9vbE5hbWU6IG8sXG4gICAgICAgICAgY29uZmlnOiBpLmNvbmZpZ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgdDtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgSW5saW5lIFRvb2xzIGFuZCBCbG9jayBUdW5lcyBmb3IgQmxvY2sgVG9vbFxuICAgKi9cbiAgcHJlcGFyZUJsb2NrVG9vbHMoKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmJsb2NrVG9vbHMudmFsdWVzKCkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuYXNzaWduSW5saW5lVG9vbHNUb0Jsb2NrVG9vbChlKSwgdGhpcy5hc3NpZ25CbG9ja1R1bmVzVG9CbG9ja1Rvb2woZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbiBlbmFibGVkIElubGluZSBUb29scyBmb3IgQmxvY2sgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIEJsb2NrIFRvb2xcbiAgICovXG4gIGFzc2lnbklubGluZVRvb2xzVG9CbG9ja1Rvb2woZSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyICE9PSAhMSkge1xuICAgICAgaWYgKGUuZW5hYmxlZElubGluZVRvb2xzID09PSAhMCkge1xuICAgICAgICBlLmlubGluZVRvb2xzID0gbmV3IFUoXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyKSA/IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIubWFwKCh0KSA9PiBbdCwgdGhpcy5pbmxpbmVUb29scy5nZXQodCldKSA6IEFycmF5LmZyb20odGhpcy5pbmxpbmVUb29scy5lbnRyaWVzKCkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEFycmF5LmlzQXJyYXkoZS5lbmFibGVkSW5saW5lVG9vbHMpICYmIChlLmlubGluZVRvb2xzID0gbmV3IFUoXG4gICAgICAgIGUuZW5hYmxlZElubGluZVRvb2xzLm1hcCgodCkgPT4gW3QsIHRoaXMuaW5saW5lVG9vbHMuZ2V0KHQpXSlcbiAgICAgICkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgQmxvY2sgVHVuZXMgZm9yIEJsb2NrIFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wg4oCUIEJsb2NrIFRvb2xcbiAgICovXG4gIGFzc2lnbkJsb2NrVHVuZXNUb0Jsb2NrVG9vbChlKSB7XG4gICAgaWYgKGUuZW5hYmxlZEJsb2NrVHVuZXMgIT09ICExKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlLmVuYWJsZWRCbG9ja1R1bmVzKSkge1xuICAgICAgICBjb25zdCB0ID0gbmV3IFUoXG4gICAgICAgICAgZS5lbmFibGVkQmxvY2tUdW5lcy5tYXAoKG8pID0+IFtvLCB0aGlzLmJsb2NrVHVuZXMuZ2V0KG8pXSlcbiAgICAgICAgKTtcbiAgICAgICAgZS50dW5lcyA9IG5ldyBVKFsuLi50LCAuLi50aGlzLmJsb2NrVHVuZXMuaW50ZXJuYWxUb29sc10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy50dW5lcykpIHtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBVKFxuICAgICAgICAgIHRoaXMuY29uZmlnLnR1bmVzLm1hcCgobykgPT4gW28sIHRoaXMuYmxvY2tUdW5lcy5nZXQobyldKVxuICAgICAgICApO1xuICAgICAgICBlLnR1bmVzID0gbmV3IFUoWy4uLnQsIC4uLnRoaXMuYmxvY2tUdW5lcy5pbnRlcm5hbFRvb2xzXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUudHVuZXMgPSB0aGlzLmJsb2NrVHVuZXMuaW50ZXJuYWxUb29scztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIFRvb2xzIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyBhbmQgdGhyb3cgRXJyb3IgZm9yIHVzZXIgaWYgaXQgaXMgaW52YWxpZFxuICAgKi9cbiAgdmFsaWRhdGVUb29scygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5jb25maWcudG9vbHMpXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlnLnRvb2xzLCBlKSkge1xuICAgICAgICBpZiAoZSBpbiB0aGlzLmludGVybmFsVG9vbHMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5jb25maWcudG9vbHNbZV07XG4gICAgICAgIGlmICghRCh0KSAmJiAhRCh0LmNsYXNzKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBUb29sIMKrJHtlfcK7IG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBmdW5jdGlvbiBpbiB0aGUgwqtjbGFzc8K7IHByb3BlcnR5YFxuICAgICAgICAgICk7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVuaWZ5IHRvb2xzIGNvbmZpZ1xuICAgKi9cbiAgcHJlcGFyZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChjb25zdCB0IGluIHRoaXMuY29uZmlnLnRvb2xzKVxuICAgICAgaih0aGlzLmNvbmZpZy50b29sc1t0XSkgPyBlW3RdID0gdGhpcy5jb25maWcudG9vbHNbdF0gOiBlW3RdID0geyBjbGFzczogdGhpcy5jb25maWcudG9vbHNbdF0gfTtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuY2koW1xuICBhZVxuXSwgU3QucHJvdG90eXBlLCBcImdldEFsbElubGluZVRvb2xzU2FuaXRpemVDb25maWdcIiwgMSk7XG5jb25zdCBkaSA9IGA6cm9vdHstLXNlbGVjdGlvbkNvbG9yOiAjZTFmMmZmOy0taW5saW5lU2VsZWN0aW9uQ29sb3I6ICNkNGVjZmY7LS1iZy1saWdodDogI2VmZjJmNTstLWdyYXlUZXh0OiAjNzA3Njg0Oy0tY29sb3ItZGFyazogIzFEMjAyQjstLWNvbG9yLWFjdGl2ZS1pY29uOiAjMzg4QUU1Oy0tY29sb3ItZ3JheS1ib3JkZXI6IHJnYmEoMjAxLCAyMDEsIDIwNCwgLjQ4KTstLWNvbnRlbnQtd2lkdGg6IDY1MHB4Oy0tbmFycm93LW1vZGUtcmlnaHQtcGFkZGluZzogNTBweDstLXRvb2xib3gtYnV0dG9ucy1zaXplOiAyNnB4Oy0tdG9vbGJveC1idXR0b25zLXNpemUtLW1vYmlsZTogMzZweDstLWljb24tc2l6ZTogMjBweDstLWljb24tc2l6ZS0tbW9iaWxlOiAyOHB4Oy0tYmxvY2stcGFkZGluZy12ZXJ0aWNhbDogLjRlbTstLWNvbG9yLWxpbmUtZ3JheTogI0VGRjBGMSB9LmNvZGV4LWVkaXRvcntwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ei1pbmRleDoxfS5jb2RleC1lZGl0b3IgLmhpZGUsLmNvZGV4LWVkaXRvcl9fcmVkYWN0b3ItLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNvZGV4LWVkaXRvcl9fcmVkYWN0b3IgW2NvbnRlbnRlZGl0YWJsZV06ZW1wdHk6YWZ0ZXJ7Y29udGVudDpcIlxcXFxmZWZmXCJ9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cgLmNvZGV4LWVkaXRvcl9fcmVkYWN0b3J7bWFyZ2luLXJpZ2h0OjUwcHh9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jb2RleC1lZGl0b3JfX3JlZGFjdG9ye21hcmdpbi1sZWZ0OjUwcHg7bWFyZ2luLXJpZ2h0OjB9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0Oi01cHh9fS5jb2RleC1lZGl0b3JfX2xvYWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MzB2aH0uY29kZXgtZWRpdG9yX19sb2FkZXI6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6NTAlO3dpZHRoOjMwcHg7aGVpZ2h0OjMwcHg7bWFyZ2luLXRvcDotMTVweDttYXJnaW4tbGVmdDotMTVweDtib3JkZXItcmFkaXVzOjUwJTtib3JkZXI6MnB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDstd2Via2l0LWFuaW1hdGlvbjplZGl0b3ItbG9hZGVyLXNwaW4gLjhzIGluZmluaXRlIGxpbmVhcjthbmltYXRpb246ZWRpdG9yLWxvYWRlci1zcGluIC44cyBpbmZpbml0ZSBsaW5lYXI7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtfS5jb2RleC1lZGl0b3ItY29weWFibGV7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjFweDt3aWR0aDoxcHg7dG9wOi00MDAlO29wYWNpdHk6LjAwMX0uY29kZXgtZWRpdG9yLW92ZXJsYXl7cG9zaXRpb246Zml4ZWQ7dG9wOjBweDtsZWZ0OjBweDtyaWdodDowcHg7Ym90dG9tOjBweDt6LWluZGV4Ojk5OTtwb2ludGVyLWV2ZW50czpub25lO292ZXJmbG93OmhpZGRlbn0uY29kZXgtZWRpdG9yLW92ZXJsYXlfX2NvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTtwb2ludGVyLWV2ZW50czphdXRvO3otaW5kZXg6MH0uY29kZXgtZWRpdG9yLW92ZXJsYXlfX3JlY3RhbmdsZXtwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czpub25lO2JhY2tncm91bmQtY29sb3I6IzJlYWFkYzMzO2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnR9LmNvZGV4LWVkaXRvciBzdmd7bWF4LWhlaWdodDoxMDAlfS5jb2RleC1lZGl0b3IgcGF0aHtzdHJva2U6Y3VycmVudENvbG9yfTo6LW1vei1zZWxlY3Rpb257YmFja2dyb3VuZC1jb2xvcjojZDRlY2ZmfTo6c2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6I2Q0ZWNmZn0uY29kZXgtZWRpdG9yLS10b29sYm94LW9wZW5lZCBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmZvY3VzOmJlZm9yZXtvcGFjaXR5OjAhaW1wb3J0YW50fUAtd2Via2l0LWtleWZyYW1lcyBlZGl0b3ItbG9hZGVyLXNwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIGVkaXRvci1sb2FkZXItc3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fS5jZS1zY3JvbGwtbG9ja2Vke292ZXJmbG93OmhpZGRlbn0uY2Utc2Nyb2xsLWxvY2tlZC0taGFyZHtvdmVyZmxvdzpoaWRkZW47dG9wOmNhbGMoLTEgKiB2YXIoLS13aW5kb3ctc2Nyb2xsLW9mZnNldCkpO3Bvc2l0aW9uOmZpeGVkO3dpZHRoOjEwMCV9LmNlLXRvb2xiYXJ7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7dG9wOjA7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2U7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlO3dpbGwtY2hhbmdlOm9wYWNpdHksdG9wO2Rpc3BsYXk6bm9uZX0uY2UtdG9vbGJhci0tb3BlbmVke2Rpc3BsYXk6YmxvY2t9LmNlLXRvb2xiYXJfX2NvbnRlbnR7bWF4LXdpZHRoOjY1MHB4O21hcmdpbjowIGF1dG87cG9zaXRpb246cmVsYXRpdmV9LmNlLXRvb2xiYXJfX3BsdXN7Y29sb3I6IzFkMjAyYjtjdXJzb3I6cG9pbnRlcjt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6N3B4O2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3BsdXN7d2lkdGg6MzZweDtoZWlnaHQ6MzZweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS10b29sYmFyX19wbHVzOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNlLXRvb2xiYXJfX3BsdXMtLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjU7LXdlYmtpdC1hbmltYXRpb246Ym91bmNlSW4gLjc1cyAxO2FuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHN9LmNlLXRvb2xiYXJfX3BsdXMtc2hvcnRjdXR7b3BhY2l0eTouNjt3b3JkLXNwYWNpbmc6LTJweDttYXJnaW4tdG9wOjVweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19wbHVze3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6Mjtwb3NpdGlvbjpzdGF0aWN9LmNlLXRvb2xiYXJfX3BsdXMtLWxlZnQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6MTVweDttYXJnaW4tbGVmdDowfS5jZS10b29sYmFyX19wbHVzLS1yaWdodC1vcmllbnRlZDpiZWZvcmV7bGVmdDphdXRvO3JpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6MH19LmNlLXRvb2xiYXJfX2FjdGlvbnN7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTAwJTtvcGFjaXR5OjA7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwYWRkaW5nLXJpZ2h0OjVweH0uY2UtdG9vbGJhcl9fYWN0aW9ucy0tb3BlbmVke29wYWNpdHk6MX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0OmF1dG99fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG57Y29sb3I6IzFkMjAyYjt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6N3B4O2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO21hcmdpbi1sZWZ0OjNweDtjdXJzb3I6cG9pbnRlcjt1c2VyLXNlbGVjdDpub25lfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bnt3aWR0aDozNnB4O2hlaWdodDozNnB4fX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjV9fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjU7LXdlYmtpdC1hbmltYXRpb246Ym91bmNlSW4gLjc1cyAxO2FuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHN9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue3dpZHRoOjI0cHh9fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWhpZGRlbntkaXNwbGF5Om5vbmV9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6Mjtwb3NpdGlvbjpzdGF0aWN9LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0tbGVmdC1vcmllbnRlZDpiZWZvcmV7bGVmdDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0tcmlnaHQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6YXV0bztyaWdodDoxNXB4O21hcmdpbi1sZWZ0OjB9fS5jZS10b29sYmFyX19wbHVzIHN2ZywuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuIHN2Z3t3aWR0aDoyNHB4O2hlaWdodDoyNHB4fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS10b29sYmFyX19wbHVze2xlZnQ6NXB4fX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdyAuY2UtdG9vbGJveCAuY2UtcG9wb3ZlcntyaWdodDowO2xlZnQ6YXV0bztsZWZ0OmluaXRpYWx9fS5jZS1pbmxpbmUtdG9vbGJhcnstLXktb2Zmc2V0OiA4cHg7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI0U4RThFQjstd2Via2l0LWJveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4IHJnYmEoMTMsMjAsMzMsLjEzKTtib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCAjMGQxNDIxMjE7Ym9yZGVyLXJhZGl1czo2cHg7ei1pbmRleDoyOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSg4cHgpIHNjYWxlKC45NCk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKSB0cmFuc2xhdGVZKDhweCkgc2NhbGUoLjk0KTtvcGFjaXR5OjA7dmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjI1cyBlYXNlLC13ZWJraXQtdHJhbnNmb3JtIC4xNXMgZWFzZTt0cmFuc2l0aW9uOm9wYWNpdHkgLjI1cyBlYXNlLC13ZWJraXQtdHJhbnNmb3JtIC4xNXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMTVzIGVhc2Usb3BhY2l0eSAuMjVzIGVhc2U7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjE1cyBlYXNlLG9wYWNpdHkgLjI1cyBlYXNlLC13ZWJraXQtdHJhbnNmb3JtIC4xNXMgZWFzZTt3aWxsLWNoYW5nZTp0cmFuc2Zvcm0sb3BhY2l0eTt0b3A6MDtsZWZ0OjA7ei1pbmRleDozfS5jZS1pbmxpbmUtdG9vbGJhci0tbGVmdC1vcmllbnRlZDpiZWZvcmV7bGVmdDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLWlubGluZS10b29sYmFyLS1yaWdodC1vcmllbnRlZDpiZWZvcmV7bGVmdDphdXRvO3JpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6MH0uY2UtaW5saW5lLXRvb2xiYXItLXNob3dlZHtvcGFjaXR5OjE7dmlzaWJpbGl0eTp2aXNpYmxlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKX0uY2UtaW5saW5lLXRvb2xiYXItLWxlZnQtb3JpZW50ZWR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMjNweCkgdHJhbnNsYXRlWSg4cHgpIHNjYWxlKC45NCk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtMjNweCkgdHJhbnNsYXRlWSg4cHgpIHNjYWxlKC45NCl9LmNlLWlubGluZS10b29sYmFyLS1sZWZ0LW9yaWVudGVkLmNlLWlubGluZS10b29sYmFyLS1zaG93ZWR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMjNweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtMjNweCl9LmNlLWlubGluZS10b29sYmFyLS1yaWdodC1vcmllbnRlZHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKDhweCkgc2NhbGUoLjk0KTt0cmFuc2Zvcm06dHJhbnNsYXRlKC0xMDAlKSB0cmFuc2xhdGVZKDhweCkgc2NhbGUoLjk0KTttYXJnaW4tbGVmdDoyM3B4fS5jZS1pbmxpbmUtdG9vbGJhci0tcmlnaHQtb3JpZW50ZWQuY2UtaW5saW5lLXRvb2xiYXItLXNob3dlZHstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC0xMDAlKX0uY2UtaW5saW5lLXRvb2xiYXIgW2hpZGRlbl17ZGlzcGxheTpub25lIWltcG9ydGFudH0uY2UtaW5saW5lLXRvb2xiYXJfX3RvZ2dsZXItYW5kLWJ1dHRvbi13cmFwcGVye2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7d2lkdGg6MTAwJTtwYWRkaW5nOjAgNnB4fS5jZS1pbmxpbmUtdG9vbGJhcl9fYnV0dG9uc3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd257ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjZweDttYXJnaW46MCA2cHggMCAtNnB4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2N1cnNvcjpwb2ludGVyO2JvcmRlci1yaWdodDoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bjpob3ZlcntiYWNrZ3JvdW5kOiNlZmYyZjV9fS5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1jb250ZW50LC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tYXJyb3d7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleH0uY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLWNvbnRlbnQgc3ZnLC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tYXJyb3cgc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9LmNlLWlubGluZS10b29sYmFyX19zaG9ydGN1dHtvcGFjaXR5Oi42O3dvcmQtc3BhY2luZzotM3B4O21hcmdpbi10b3A6M3B4fS5jZS1pbmxpbmUtdG9vbHtkaXNwbGF5Oi13ZWJraXQtaW5saW5lLWJveDtkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5OmlubGluZS1mbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cGFkZGluZzo2cHggMXB4O2N1cnNvcjpwb2ludGVyO2JvcmRlcjowO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3ZlcnRpY2FsLWFsaWduOmJvdHRvbTtjb2xvcjppbmhlcml0O21hcmdpbjowO2JvcmRlci1yYWRpdXM6MDtsaW5lLWhlaWdodDpub3JtYWx9LmNlLWlubGluZS10b29sIHN2Z3t3aWR0aDoyMHB4O2hlaWdodDoyMHB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLWlubGluZS10b29sIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLWlubGluZS10b29sOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNlLWlubGluZS10b29sLS1hY3RpdmV7Y29sb3I6IzM4OGFlNX0uY2UtaW5saW5lLXRvb2wtLWZvY3VzZWR7YmFja2dyb3VuZDpyZ2JhKDM0LDE4NiwyNTUsLjA4KSFpbXBvcnRhbnR9LmNlLWlubGluZS10b29sLS1mb2N1c2Vkey13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDAgMHB4IDFweCByZ2JhKDcsMTYxLDIyNywuMDgpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4ICMwN2ExZTMxNH0uY2UtaW5saW5lLXRvb2wtLWZvY3VzZWQtYW5pbWF0ZWR7LXdlYmtpdC1hbmltYXRpb24tbmFtZTpidXR0b25DbGlja2VkO2FuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246LjI1czthbmltYXRpb24tZHVyYXRpb246LjI1c30uY2UtaW5saW5lLXRvb2wtLWxpbmsgLmljb24tLXVubGluaywuY2UtaW5saW5lLXRvb2wtLXVubGluayAuaWNvbi0tbGlua3tkaXNwbGF5Om5vbmV9LmNlLWlubGluZS10b29sLS11bmxpbmsgLmljb24tLXVubGlua3tkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tYm90dG9tOi0xcHh9LmNlLWlubGluZS10b29sLWlucHV0e291dGxpbmU6bm9uZTtib3JkZXI6MDtib3JkZXItcmFkaXVzOjAgMCA0cHggNHB4O21hcmdpbjowO2ZvbnQtc2l6ZToxM3B4O3BhZGRpbmc6MTBweDt3aWR0aDoxMDAlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5Om5vbmU7Zm9udC13ZWlnaHQ6NTAwO2JvcmRlci10b3A6MXB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTtmb250LWZhbWlseTppbmhlcml0fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLWlubGluZS10b29sLWlucHV0e2ZvbnQtc2l6ZToxNXB4O2ZvbnQtd2VpZ2h0OjUwMH19LmNlLWlubGluZS10b29sLWlucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0OjotbW96LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0fS5jZS1pbmxpbmUtdG9vbC1pbnB1dDo6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0OjpwbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0fS5jZS1pbmxpbmUtdG9vbC1pbnB1dC0tc2hvd2Vke2Rpc3BsYXk6YmxvY2t9LmNlLWNvbnZlcnNpb24tdG9vbGJhcntwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjRThFOEVCOy13ZWJraXQtYm94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggcmdiYSgxMywyMCwzMywuMTMpO2JveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4ICMwZDE0MjEyMTtib3JkZXItcmFkaXVzOjZweDt6LWluZGV4OjI7b3BhY2l0eTowO3Zpc2liaWxpdHk6aGlkZGVuO3dpbGwtY2hhbmdlOnRyYW5zZm9ybSxvcGFjaXR5Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLC13ZWJraXQtdHJhbnNmb3JtIC4xcyBlYXNlO3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZSwtd2Via2l0LXRyYW5zZm9ybSAuMXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMXMgZWFzZSxvcGFjaXR5IC4xcyBlYXNlO3RyYW5zaXRpb246dHJhbnNmb3JtIC4xcyBlYXNlLG9wYWNpdHkgLjFzIGVhc2UsLXdlYmtpdC10cmFuc2Zvcm0gLjFzIGVhc2U7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KTtsZWZ0Oi0xcHg7d2lkdGg6MTUwcHg7bWFyZ2luLXRvcDo1cHg7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3h9LmNlLWNvbnZlcnNpb24tdG9vbGJhci0tbGVmdC1vcmllbnRlZDpiZWZvcmV7bGVmdDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLWNvbnZlcnNpb24tdG9vbGJhci0tcmlnaHQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6YXV0bztyaWdodDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLWNvbnZlcnNpb24tdG9vbGJhci0tc2hvd2Vke29wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGU7LXdlYmtpdC10cmFuc2Zvcm06bm9uZTt0cmFuc2Zvcm06bm9uZX0uY2UtY29udmVyc2lvbi10b29sYmFyIFtoaWRkZW5de2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmNlLWNvbnZlcnNpb24tdG9vbGJhcl9fYnV0dG9uc3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5jZS1jb252ZXJzaW9uLXRvb2xiYXJfX2xhYmVse2NvbG9yOiM3MDc2ODQ7Zm9udC1zaXplOjExcHg7Zm9udC13ZWlnaHQ6NTAwO2xldHRlci1zcGFjaW5nOi4zM3B4O3BhZGRpbmc6MTBweCAxMHB4IDVweDt0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2V9LmNlLWNvbnZlcnNpb24tdG9vbHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3BhZGRpbmc6NXB4IDEwcHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MjBweDtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LmNlLWNvbnZlcnNpb24tdG9vbC0taGlkZGVue2Rpc3BsYXk6bm9uZX0uY2UtY29udmVyc2lvbi10b29sLS1mb2N1c2Vke2JhY2tncm91bmQ6cmdiYSgzNCwxODYsMjU1LC4wOCkhaW1wb3J0YW50fS5jZS1jb252ZXJzaW9uLXRvb2wtLWZvY3VzZWR7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMCAwcHggMXB4IHJnYmEoNywxNjEsMjI3LC4wOCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggIzA3YTFlMzE0fS5jZS1jb252ZXJzaW9uLXRvb2wtLWZvY3VzZWQtYW5pbWF0ZWR7LXdlYmtpdC1hbmltYXRpb24tbmFtZTpidXR0b25DbGlja2VkO2FuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7LXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb246LjI1czthbmltYXRpb24tZHVyYXRpb246LjI1c30uY2UtY29udmVyc2lvbi10b29sOmhvdmVye2JhY2tncm91bmQ6I2VmZjJmNX0uY2UtY29udmVyc2lvbi10b29sX19pY29ue2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7d2lkdGg6MjZweDtoZWlnaHQ6MjZweDstd2Via2l0LWJveC1zaGFkb3c6MCAwIDAgMXB4IHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTtib3gtc2hhZG93OjAgMCAwIDFweCAjYzljOWNjN2E7Ym9yZGVyLXJhZGl1czo1cHg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtiYWNrZ3JvdW5kOiNmZmY7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowO21hcmdpbi1yaWdodDoxMHB4fS5jZS1jb252ZXJzaW9uLXRvb2xfX2ljb24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtY29udmVyc2lvbi10b29sX19pY29ue3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Ym9yZGVyLXJhZGl1czo4cHh9LmNlLWNvbnZlcnNpb24tdG9vbF9faWNvbiBzdmd7d2lkdGg6MjhweDtoZWlnaHQ6MjhweH19LmNlLWNvbnZlcnNpb24tdG9vbC0tbGFzdHttYXJnaW4tcmlnaHQ6MCFpbXBvcnRhbnR9LmNlLWNvbnZlcnNpb24tdG9vbC0tYWN0aXZle2NvbG9yOiMzODhhZTUhaW1wb3J0YW50fS5jZS1jb252ZXJzaW9uLXRvb2wtLWFjdGl2ZXstd2Via2l0LWFuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7YW5pbWF0aW9uOmJvdW5jZUluIC43NXMgMTstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHM7YW5pbWF0aW9uLWZpbGwtbW9kZTpmb3J3YXJkc30uY2Utc2V0dGluZ3NfX2J1dHRvbntkaXNwbGF5Oi13ZWJraXQtaW5saW5lLWJveDtkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5OmlubGluZS1mbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7cGFkZGluZzo2cHggMXB4O2JvcmRlci1yYWRpdXM6M3B4O2N1cnNvcjpwb2ludGVyO2JvcmRlcjowO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3ZlcnRpY2FsLWFsaWduOmJvdHRvbTtjb2xvcjppbmhlcml0O21hcmdpbjowO2xpbmUtaGVpZ2h0OjMycHh9LmNlLXNldHRpbmdzX19idXR0b24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2Utc2V0dGluZ3NfX2J1dHRvbiBzdmd7d2lkdGg6MjhweDtoZWlnaHQ6MjhweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1zZXR0aW5nc19fYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNlLXNldHRpbmdzX19idXR0b24tLWFjdGl2ZXtjb2xvcjojMzg4YWU1fS5jZS1zZXR0aW5nc19fYnV0dG9uLS1mb2N1c2Vke2JhY2tncm91bmQ6cmdiYSgzNCwxODYsMjU1LC4wOCkhaW1wb3J0YW50fS5jZS1zZXR0aW5nc19fYnV0dG9uLS1mb2N1c2Vkey13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDAgMHB4IDFweCByZ2JhKDcsMTYxLDIyNywuMDgpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4ICMwN2ExZTMxNH0uY2Utc2V0dGluZ3NfX2J1dHRvbi0tZm9jdXNlZC1hbmltYXRlZHstd2Via2l0LWFuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7YW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouMjVzO2FuaW1hdGlvbi1kdXJhdGlvbjouMjVzfS5jZS1zZXR0aW5nc19fYnV0dG9uOm5vdCg6bnRoLWNoaWxkKDNuKzMpKXttYXJnaW4tcmlnaHQ6M3B4fS5jZS1zZXR0aW5nc19fYnV0dG9uOm50aC1jaGlsZChuKzQpe21hcmdpbi10b3A6M3B4fS5jZS1zZXR0aW5nc19fYnV0dG9uLS1kaXNhYmxlZHtjdXJzb3I6bm90LWFsbG93ZWQhaW1wb3J0YW50fS5jZS1zZXR0aW5nc19fYnV0dG9uLS1kaXNhYmxlZHtvcGFjaXR5Oi4zfS5jZS1zZXR0aW5nc19fYnV0dG9uLS1zZWxlY3RlZHtjb2xvcjojMzg4YWU1fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS1zZXR0aW5ncyAuY2UtcG9wb3ZlcntyaWdodDowO2xlZnQ6YXV0bztsZWZ0OmluaXRpYWx9fUAtd2Via2l0LWtleWZyYW1lcyBmYWRlLWluezAle29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZmFkZS1pbnswJXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uY2UtYmxvY2t7LXdlYmtpdC1hbmltYXRpb246ZmFkZS1pbiAuM3MgZWFzZTthbmltYXRpb246ZmFkZS1pbiAuM3MgZWFzZTstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6bm9uZTthbmltYXRpb24tZmlsbC1tb2RlOm5vbmU7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmluaXRpYWw7YW5pbWF0aW9uLWZpbGwtbW9kZTppbml0aWFsfS5jZS1ibG9jazpmaXJzdC1vZi10eXBle21hcmdpbi10b3A6MH0uY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudHtiYWNrZ3JvdW5kOiNlMWYyZmZ9LmNlLWJsb2NrLS1zZWxlY3RlZCAuY2UtYmxvY2tfX2NvbnRlbnQgW2NvbnRlbnRlZGl0YWJsZV17LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5jZS1ibG9jay0tc2VsZWN0ZWQgLmNlLWJsb2NrX19jb250ZW50IGltZywuY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudCAuY2Utc3R1YntvcGFjaXR5Oi41NX0uY2UtYmxvY2stLXN0cmV0Y2hlZCAuY2UtYmxvY2tfX2NvbnRlbnR7bWF4LXdpZHRoOm5vbmV9LmNlLWJsb2NrX19jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO21heC13aWR0aDo2NTBweDttYXJnaW46MCBhdXRvOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4xNXMgZWFzZTt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjE1cyBlYXNlfS5jZS1ibG9jay0tZHJvcC10YXJnZXQgLmNlLWJsb2NrX19jb250ZW50OmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDotMjBweDttYXJnaW4tdG9wOi0xcHg7aGVpZ2h0OjhweDt3aWR0aDo4cHg7Ym9yZGVyOnNvbGlkICMzODhBRTU7Ym9yZGVyLXdpZHRoOjFweCAxcHggMCAwOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpyaWdodDt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0Oy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9LmNlLWJsb2NrLS1kcm9wLXRhcmdldCAuY2UtYmxvY2tfX2NvbnRlbnQ6YWZ0ZXJ7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMDAlO2hlaWdodDoxcHg7d2lkdGg6MTAwJTtjb2xvcjojMzg4YWU1O2JhY2tncm91bmQ6cmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCg5MGRlZywjMzg4QUU1LCMzODhBRTUgMXB4LCNmZmYgMXB4LCNmZmYgNnB4KX0uY2UtYmxvY2sgYXtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX0uY2UtYmxvY2sgYntmb250LXdlaWdodDo3MDB9LmNlLWJsb2NrIGl7Zm9udC1zdHlsZTppdGFsaWN9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cgLmNlLWJsb2NrLS1mb2N1c2Vke21hcmdpbi1yaWdodDotNTBweDtwYWRkaW5nLXJpZ2h0OjUwcHh9fUAtd2Via2l0LWtleWZyYW1lcyBib3VuY2VJbnswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOSwuOSwuOSk7dHJhbnNmb3JtOnNjYWxlM2QoLjksLjksLjkpfTIwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDMsMS4wMywxLjAzKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAzLDEuMDMsMS4wMyl9NjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUBrZXlmcmFtZXMgYm91bmNlSW57MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoLjksLjksLjkpO3RyYW5zZm9ybTpzY2FsZTNkKC45LC45LC45KX0yMCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAzLDEuMDMsMS4wMyk7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMywxLjAzLDEuMDMpfTYwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1ALXdlYmtpdC1rZXlmcmFtZXMgc2VsZWN0aW9uQm91bmNlezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX01MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAxLDEuMDEsMS4wMSk7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMSwxLjAxLDEuMDEpfTcwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1Aa2V5ZnJhbWVzIHNlbGVjdGlvbkJvdW5jZXswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9NTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMSwxLjAxLDEuMDEpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDEsMS4wMSwxLjAxKX03MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19QC13ZWJraXQta2V5ZnJhbWVzIGJ1dHRvbkNsaWNrZWR7MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpO3RyYW5zZm9ybTpzY2FsZTNkKC45NSwuOTUsLjk1KX02MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMik7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMiwxLjAyLDEuMDIpfTgwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1Aa2V5ZnJhbWVzIGJ1dHRvbkNsaWNrZWR7MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpO3RyYW5zZm9ybTpzY2FsZTNkKC45NSwuOTUsLjk1KX02MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMik7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMiwxLjAyLDEuMDIpfTgwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX0uY2R4LWJsb2Nre3BhZGRpbmc6LjRlbSAwfS5jZHgtYmxvY2s6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7bGluZS1oZWlnaHQ6bm9ybWFsIWltcG9ydGFudH0uY2R4LWlucHV0e2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAycHggMCByZ2JhKDM1LDQ0LDcyLC4wNik7Ym94LXNoYWRvdzppbnNldCAwIDFweCAycHggIzIzMmM0ODBmO2JvcmRlci1yYWRpdXM6M3B4O3BhZGRpbmc6MTBweCAxMnB4O291dGxpbmU6bm9uZTt3aWR0aDoxMDAlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH0uY2R4LWlucHV0W2RhdGEtcGxhY2Vob2xkZXJdOmJlZm9yZXtwb3NpdGlvbjpzdGF0aWMhaW1wb3J0YW50fS5jZHgtaW5wdXRbZGF0YS1wbGFjZWhvbGRlcl06YmVmb3Jle2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjA7d2hpdGUtc3BhY2U6bm93cmFwO3BvaW50ZXItZXZlbnRzOm5vbmV9LmNkeC1zZXR0aW5ncy1idXR0b257ZGlzcGxheTotd2Via2l0LWlubGluZS1ib3g7ZGlzcGxheTotbXMtaW5saW5lLWZsZXhib3g7ZGlzcGxheTppbmxpbmUtZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3BhZGRpbmc6NnB4IDFweDtib3JkZXItcmFkaXVzOjNweDtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MDtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDt2ZXJ0aWNhbC1hbGlnbjpib3R0b207Y29sb3I6aW5oZXJpdDttYXJnaW46MDttaW4td2lkdGg6MjZweDttaW4taGVpZ2h0OjI2cHh9LmNkeC1zZXR0aW5ncy1idXR0b24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2R4LXNldHRpbmdzLWJ1dHRvbiBzdmd7d2lkdGg6MjhweDtoZWlnaHQ6MjhweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZHgtc2V0dGluZ3MtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNkeC1zZXR0aW5ncy1idXR0b24tLWZvY3VzZWR7YmFja2dyb3VuZDpyZ2JhKDM0LDE4NiwyNTUsLjA4KSFpbXBvcnRhbnR9LmNkeC1zZXR0aW5ncy1idXR0b24tLWZvY3VzZWR7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMCAwcHggMXB4IHJnYmEoNywxNjEsMjI3LC4wOCk7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggIzA3YTFlMzE0fS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1mb2N1c2VkLWFuaW1hdGVkey13ZWJraXQtYW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDthbmltYXRpb24tbmFtZTpidXR0b25DbGlja2VkOy13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOi4yNXM7YW5pbWF0aW9uLWR1cmF0aW9uOi4yNXN9LmNkeC1zZXR0aW5ncy1idXR0b24tLWFjdGl2ZXtjb2xvcjojMzg4YWU1fS5jZHgtc2V0dGluZ3MtYnV0dG9uIHN2Z3t3aWR0aDphdXRvO2hlaWdodDphdXRvfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNkeC1zZXR0aW5ncy1idXR0b257d2lkdGg6MzZweDtoZWlnaHQ6MzZweDtib3JkZXItcmFkaXVzOjhweH19LmNkeC1sb2FkZXJ7cG9zaXRpb246cmVsYXRpdmU7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCl9LmNkeC1sb2FkZXI6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6NTAlO3dpZHRoOjE4cHg7aGVpZ2h0OjE4cHg7bWFyZ2luOi0xMXB4IDAgMCAtMTFweDtib3JkZXI6MnB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTtib3JkZXItbGVmdC1jb2xvcjojMzg4YWU1O2JvcmRlci1yYWRpdXM6NTAlOy13ZWJraXQtYW5pbWF0aW9uOmNkeFJvdGF0aW9uIDEuMnMgaW5maW5pdGUgbGluZWFyO2FuaW1hdGlvbjpjZHhSb3RhdGlvbiAxLjJzIGluZmluaXRlIGxpbmVhcn1ALXdlYmtpdC1rZXlmcmFtZXMgY2R4Um90YXRpb257MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIGNkeFJvdGF0aW9uezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19LmNkeC1idXR0b257cGFkZGluZzoxM3B4O2JvcmRlci1yYWRpdXM6M3B4O2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpO2ZvbnQtc2l6ZToxNC45cHg7YmFja2dyb3VuZDojZmZmOy13ZWJraXQtYm94LXNoYWRvdzowIDJweCAycHggMCByZ2JhKDE4LDMwLDU3LC4wNCk7Ym94LXNoYWRvdzowIDJweCAycHggIzEyMWUzOTBhO2NvbG9yOiM3MDc2ODQ7dGV4dC1hbGlnbjpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZHgtYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6I0ZCRkNGRTstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggM3B4IDAgcmdiYSgxOCwzMCw1NywuMDgpO2JveC1zaGFkb3c6MCAxcHggM3B4ICMxMjFlMzkxNH19LmNkeC1idXR0b24gc3Zne2hlaWdodDoyMHB4O21hcmdpbi1yaWdodDouMmVtO21hcmdpbi10b3A6LTJweH0uY2Utc3R1YntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6MTAwJTtwYWRkaW5nOjMuNWVtIDA7bWFyZ2luOjE3cHggMDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kOiNmY2Y3Zjc7Y29sb3I6I2I0NjI2Mn0uY2Utc3R1Yl9faW5mb3ttYXJnaW4tbGVmdDoyMHB4fS5jZS1zdHViX190aXRsZXttYXJnaW4tYm90dG9tOjNweDtmb250LXdlaWdodDo2MDA7Zm9udC1zaXplOjE4cHg7dGV4dC10cmFuc2Zvcm06Y2FwaXRhbGl6ZX0uY2Utc3R1Yl9fc3VidGl0bGV7Zm9udC1zaXplOjE2cHh9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bHtkaXJlY3Rpb246cnRsfS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNkeC1saXN0e3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6NDBweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19wbHVze3JpZ2h0Oi0yNnB4O2xlZnQ6YXV0b30uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0OmF1dG87bGVmdDotMjZweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX2FjdGlvbnN7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6YXV0bztwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjEwcHh9fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXNldHRpbmdze2xlZnQ6NXB4O3JpZ2h0OmF1dG99LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2Utc2V0dGluZ3M6YmVmb3Jle3JpZ2h0OmF1dG87bGVmdDoyNXB4fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXNldHRpbmdzX19idXR0b246bm90KDpudGgtY2hpbGQoM24rMykpe21hcmdpbi1sZWZ0OjNweDttYXJnaW4tcmlnaHQ6MH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1jb252ZXJzaW9uLXRvb2xfX2ljb257bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLWxlZnQ6MTBweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd257Ym9yZGVyLXJpZ2h0OjBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpO21hcmdpbjowIC02cHggMCA2cHh9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duIC5pY29uLS10b2dnbGVyLWRvd257bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19wbHVze2xlZnQ6MHB4O3JpZ2h0OjVweH19QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY29kZXgtZWRpdG9yLS1uYXJyb3cuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX2FjdGlvbnN7bGVmdDotNXB4fX0uY2R4LXNlYXJjaC1maWVsZHstLWljb24tbWFyZ2luLXJpZ2h0OiAxMHB4O2JhY2tncm91bmQ6cmdiYSgyMzIsMjMyLDIzNSwuNDkpO2JvcmRlcjoxcHggc29saWQgcmdiYSgyMjYsMjI2LDIyOSwuMik7Ym9yZGVyLXJhZGl1czo2cHg7cGFkZGluZzoycHg7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczphdXRvIGF1dG8gMWZyO2dyaWQtdGVtcGxhdGUtcm93czphdXRvfS5jZHgtc2VhcmNoLWZpZWxkX19pY29ue3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbi1yaWdodDp2YXIoLS1pY29uLW1hcmdpbi1yaWdodCl9LmNkeC1zZWFyY2gtZmllbGRfX2ljb24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7Y29sb3I6IzcwNzY4NH0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXR7Zm9udC1zaXplOjE0cHg7b3V0bGluZTpub25lO2ZvbnQtd2VpZ2h0OjUwMDtmb250LWZhbWlseTppbmhlcml0O2JvcmRlcjowO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7bWFyZ2luOjA7cGFkZGluZzowO2xpbmUtaGVpZ2h0OjIycHg7bWluLXdpZHRoOmNhbGMoMTAwJSAtIDI2cHggLSB2YXIoLS1pY29uLW1hcmdpbi1yaWdodCkpfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjUwMH0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo1MDB9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjUwMH0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXQ6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjUwMH0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXQ6OnBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZS1wb3BvdmVyey0tYm9yZGVyLXJhZGl1czogNnB4Oy0td2lkdGg6IDIwMHB4Oy0tbWF4LWhlaWdodDogMjcwcHg7LS1wYWRkaW5nOiA2cHg7LS1vZmZzZXQtZnJvbS10YXJnZXQ6IDhweDstLWNvbG9yLWJvcmRlcjogI2U4ZThlYjstLWNvbG9yLXNoYWRvdzogcmdiYSgxMywyMCwzMywuMTMpOy0tY29sb3ItYmFja2dyb3VuZDogd2hpdGU7LS1jb2xvci10ZXh0LXByaW1hcnk6IGJsYWNrOy0tY29sb3ItdGV4dC1zZWNvbmRhcnk6ICM3MDc2ODQ7LS1jb2xvci1ib3JkZXItaWNvbjogcmdiYSgyMDEsIDIwMSwgMjA0LCAuNDgpOy0tY29sb3ItYm9yZGVyLWljb24tZGlzYWJsZWQ6ICNFRkYwRjE7LS1jb2xvci10ZXh0LWljb24tYWN0aXZlOiAjMzg4QUU1Oy0tY29sb3ItYmFja2dyb3VuZC1pY29uLWFjdGl2ZTogcmdiYSg1NiwgMTM4LCAyMjksIC4xKTstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1mb2N1czogcmdiYSgzNCwgMTg2LCAyNTUsIC4wOCk7LS1jb2xvci1zaGFkb3ctaXRlbS1mb2N1czogcmdiYSg3LCAxNjEsIDIyNywgLjA4KTstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1ob3ZlcjogI2VmZjJmNTstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtOiAjRTI0QTRBOy0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWNvbmZpcm0taG92ZXI6ICNDRTQzNDM7bWluLXdpZHRoOnZhcigtLXdpZHRoKTt3aWR0aDp2YXIoLS13aWR0aCk7bWF4LWhlaWdodDp2YXIoLS1tYXgtaGVpZ2h0KTtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCB2YXIoLS1jb2xvci1zaGFkb3cpO2JveC1zaGFkb3c6MCAzcHggMTVweCAtM3B4IHZhcigtLWNvbG9yLXNoYWRvdyk7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDpjYWxjKDEwMCUgKyB2YXIoLS1vZmZzZXQtZnJvbS10YXJnZXQpKTtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQpO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47ei1pbmRleDo0O29wYWNpdHk6MDttYXgtaGVpZ2h0OjA7cG9pbnRlci1ldmVudHM6bm9uZTtwYWRkaW5nOjA7Ym9yZGVyOm5vbmV9LmNlLXBvcG92ZXItLW9wZW5lZHtvcGFjaXR5OjE7cGFkZGluZzp2YXIoLS1wYWRkaW5nKTttYXgtaGVpZ2h0OnZhcigtLW1heC1oZWlnaHQpO3BvaW50ZXItZXZlbnRzOmF1dG87LXdlYmtpdC1hbmltYXRpb246cGFuZWxTaG93aW5nIC4xcyBlYXNlO2FuaW1hdGlvbjpwYW5lbFNob3dpbmcgLjFzIGVhc2U7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3JkZXIpfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItLW9wZW5lZHstd2Via2l0LWFuaW1hdGlvbjpwYW5lbFNob3dpbmdNb2JpbGUgLjI1cyBlYXNlO2FuaW1hdGlvbjpwYW5lbFNob3dpbmdNb2JpbGUgLjI1cyBlYXNlfX0uY2UtcG9wb3Zlcl9faXRlbXN7b3ZlcmZsb3cteTphdXRvOy1tcy1zY3JvbGwtY2hhaW5pbmc6bm9uZTtvdmVyc2Nyb2xsLWJlaGF2aW9yOmNvbnRhaW59QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlcl9fb3ZlcmxheXtwb3NpdGlvbjpmaXhlZDt0b3A6MDtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDtiYWNrZ3JvdW5kOiMxRDIwMkI7ei1pbmRleDozO29wYWNpdHk6LjU7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjEycyBlYXNlLWluO3RyYW5zaXRpb246b3BhY2l0eSAuMTJzIGVhc2UtaW47d2lsbC1jaGFuZ2U6b3BhY2l0eTt2aXNpYmlsaXR5OnZpc2libGV9fS5jZS1wb3BvdmVyX19vdmVybGF5LS1oaWRkZW57ZGlzcGxheTpub25lfS5jZS1wb3BvdmVyLS1vcGVuLXRvcHt0b3A6Y2FsYygtMSAqICh2YXIoLS1vZmZzZXQtZnJvbS10YXJnZXQpICsgdmFyKC0tcG9wb3Zlci1oZWlnaHQpKSl9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3ZlcnstLW9mZnNldDogNXB4O3Bvc2l0aW9uOmZpeGVkO21heC13aWR0aDpub25lO21pbi13aWR0aDpjYWxjKDEwMCUgLSB2YXIoLS1vZmZzZXQpICogMik7bGVmdDp2YXIoLS1vZmZzZXQpO3JpZ2h0OnZhcigtLW9mZnNldCk7Ym90dG9tOmNhbGModmFyKC0tb2Zmc2V0KSArIGVudihzYWZlLWFyZWEtaW5zZXQtYm90dG9tKSk7dG9wOmF1dG87Ym9yZGVyLXJhZGl1czoxMHB4fS5jZS1wb3BvdmVyIC5jZS1wb3BvdmVyX19zZWFyY2h7ZGlzcGxheTpub25lfX0uY2UtcG9wb3Zlcl9fc2VhcmNoLC5jZS1wb3BvdmVyX19jdXN0b20tY29udGVudDpub3QoOmVtcHR5KXttYXJnaW4tYm90dG9tOjVweH0uY2UtcG9wb3Zlcl9fbm90aGluZy1mb3VuZC1tZXNzYWdle2NvbG9yOiM3MDc2ODQ7ZGlzcGxheTpub25lO2N1cnNvcjpkZWZhdWx0O3BhZGRpbmc6M3B4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NTAwO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uY2UtcG9wb3Zlcl9fbm90aGluZy1mb3VuZC1tZXNzYWdlLS1kaXNwbGF5ZWR7ZGlzcGxheTpibG9ja30uY2UtcG9wb3Zlcl9fY3VzdG9tLWNvbnRlbnQ6bm90KDplbXB0eSl7cGFkZGluZzo0cHh9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY2UtcG9wb3Zlcl9fY3VzdG9tLWNvbnRlbnQ6bm90KDplbXB0eSl7cGFkZGluZzowfX0uY2UtcG9wb3Zlcl9fY3VzdG9tLWNvbnRlbnQtLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLXBvcG92ZXItaXRlbXstLWJvcmRlci1yYWRpdXM6IDZweDstLWljb24tc2l6ZTogMjBweDstLWljb24tc2l6ZS1tb2JpbGU6IDI4cHg7Ym9yZGVyLXJhZGl1czp2YXIoLS1ib3JkZXItcmFkaXVzKTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3BhZGRpbmc6M3B4O2NvbG9yOnZhcigtLWNvbG9yLXRleHQtcHJpbWFyeSk7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItaXRlbXtwYWRkaW5nOjRweH19LmNlLXBvcG92ZXItaXRlbTpub3QoOmxhc3Qtb2YtdHlwZSl7bWFyZ2luLWJvdHRvbToxcHh9LmNlLXBvcG92ZXItaXRlbV9faWNvbntib3JkZXItcmFkaXVzOjVweDt3aWR0aDoyNnB4O2hlaWdodDoyNnB4Oy13ZWJraXQtYm94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tY29sb3ItYm9yZGVyLWljb24pO2JveC1zaGFkb3c6MCAwIDAgMXB4IHZhcigtLWNvbG9yLWJvcmRlci1pY29uKTtiYWNrZ3JvdW5kOiNmZmY7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbi1yaWdodDoxMHB4fS5jZS1wb3BvdmVyLWl0ZW1fX2ljb24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVtX19pY29ue3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Ym9yZGVyLXJhZGl1czo4cHh9LmNlLXBvcG92ZXItaXRlbV9faWNvbiBzdmd7d2lkdGg6dmFyKC0taWNvbi1zaXplLW1vYmlsZSk7aGVpZ2h0OnZhcigtLWljb24tc2l6ZS1tb2JpbGUpfX0uY2UtcG9wb3Zlci1pdGVtX190aXRsZXtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoyMHB4O2ZvbnQtd2VpZ2h0OjUwMDtvdmVyZmxvdzpoaWRkZW47d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVtX190aXRsZXtmb250LXNpemU6MTZweH19LmNlLXBvcG92ZXItaXRlbV9fc2Vjb25kYXJ5LXRpdGxle2NvbG9yOnZhcigtLWNvbG9yLXRleHQtc2Vjb25kYXJ5KTtmb250LXNpemU6MTJweDttYXJnaW4tbGVmdDphdXRvO3doaXRlLXNwYWNlOm5vd3JhcDtsZXR0ZXItc3BhY2luZzotLjFlbTtwYWRkaW5nLXJpZ2h0OjVweDttYXJnaW4tYm90dG9tOi0ycHg7b3BhY2l0eTouNn1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLWl0ZW1fX3NlY29uZGFyeS10aXRsZXtkaXNwbGF5Om5vbmV9fS5jZS1wb3BvdmVyLWl0ZW0tLWFjdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaWNvbi1hY3RpdmUpO2NvbG9yOnZhcigtLWNvbG9yLXRleHQtaWNvbi1hY3RpdmUpfS5jZS1wb3BvdmVyLWl0ZW0tLWFjdGl2ZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uey13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZX0uY2UtcG9wb3Zlci1pdGVtLS1kaXNhYmxlZHtjb2xvcjp2YXIoLS1jb2xvci10ZXh0LXNlY29uZGFyeSk7Y3Vyc29yOmRlZmF1bHQ7cG9pbnRlci1ldmVudHM6bm9uZX0uY2UtcG9wb3Zlci1pdGVtLS1kaXNhYmxlZCAuY2UtcG9wb3Zlci1pdGVtX19pY29uey13ZWJraXQtYm94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tY29sb3ItYm9yZGVyLWljb24tZGlzYWJsZWQpO2JveC1zaGFkb3c6MCAwIDAgMXB4IHZhcigtLWNvbG9yLWJvcmRlci1pY29uLWRpc2FibGVkKX0uY2UtcG9wb3Zlci1pdGVtLS1mb2N1c2VkOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1mb2N1cyl7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tZm9jdXMpIWltcG9ydGFudH0uY2UtcG9wb3Zlci1pdGVtLS1mb2N1c2VkOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1mb2N1cyl7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMCAwcHggMXB4IHZhcigtLWNvbG9yLXNoYWRvdy1pdGVtLWZvY3VzKTtib3gtc2hhZG93Omluc2V0IDAgMCAwIDFweCB2YXIoLS1jb2xvci1zaGFkb3ctaXRlbS1mb2N1cyl9LmNlLXBvcG92ZXItaXRlbS0taGlkZGVue2Rpc3BsYXk6bm9uZX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXBvcG92ZXItaXRlbTpob3ZlcntjdXJzb3I6cG9pbnRlcn0uY2UtcG9wb3Zlci1pdGVtOmhvdmVyOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1ob3Zlcil7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0taG92ZXIpfS5jZS1wb3BvdmVyLWl0ZW06aG92ZXIgLmNlLXBvcG92ZXItaXRlbV9faWNvbnstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9fS5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbntiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtKX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb24gLmNlLXBvcG92ZXItaXRlbV9faWNvbntjb2xvcjp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybSl9LmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uIC5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxle2NvbG9yOiNmZmZ9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbjpub3QoLmNlLXBvcG92ZXItaXRlbS0tbm8taG92ZXIpOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWNvbmZpcm0taG92ZXIpfX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb246bm90KC5jZS1wb3BvdmVyLWl0ZW0tLW5vLWZvY3VzKS5jZS1wb3BvdmVyLWl0ZW0tLWZvY3VzZWR7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybS1ob3ZlcikhaW1wb3J0YW50fS5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbiAuY2UtcG9wb3Zlci1pdGVtX19pY29uLC5jZS1wb3BvdmVyLWl0ZW0tLWFjdGl2ZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uLC5jZS1wb3BvdmVyLWl0ZW0tLWZvY3VzZWQgLmNlLXBvcG92ZXItaXRlbV9faWNvbnstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9QC13ZWJraXQta2V5ZnJhbWVzIHBhbmVsU2hvd2luZ3swJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCkgc2NhbGUoLjkpfTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDJweCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX19QGtleWZyYW1lcyBwYW5lbFNob3dpbmd7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCkgc2NhbGUoLjkpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpIHNjYWxlKC45KX03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMnB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9fUAtd2Via2l0LWtleWZyYW1lcyBwYW5lbFNob3dpbmdNb2JpbGV7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTRweCkgc2NhbGUoLjk4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxNHB4KSBzY2FsZSguOTgpfTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX1Aa2V5ZnJhbWVzIHBhbmVsU2hvd2luZ01vYmlsZXswJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxNHB4KSBzY2FsZSguOTgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDE0cHgpIHNjYWxlKC45OCl9NzAle29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC00cHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC00cHgpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9fS53b2JibGV7LXdlYmtpdC1hbmltYXRpb24tbmFtZTp3b2JibGU7YW5pbWF0aW9uLW5hbWU6d29iYmxlOy13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOi40czthbmltYXRpb24tZHVyYXRpb246LjRzfUAtd2Via2l0LWtleWZyYW1lcyB3b2JibGV7MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfTE1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtOSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCl9MzAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCl9NDUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKX02MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKX03NSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTElLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX19QGtleWZyYW1lcyB3b2JibGV7MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfTE1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtOSUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCl9MzAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDklLDAsMCl9NDUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC00JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKX02MCV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoNCUsMCwwKX03NSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTElLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX19XG5gO1xuY2xhc3MgaGkgZXh0ZW5kcyBTIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5pc01vYmlsZSA9ICExLCB0aGlzLmNvbnRlbnRSZWN0Q2FjaGUgPSB2b2lkIDAsIHRoaXMucmVzaXplRGVib3VuY2VyID0gUHQoKCkgPT4ge1xuICAgICAgdGhpcy53aW5kb3dSZXNpemUoKTtcbiAgICB9LCAyMDApO1xuICB9XG4gIC8qKlxuICAgKiBFZGl0b3IuanMgVUkgQ1NTIGNsYXNzIG5hbWVzXG4gICAqXG4gICAqIEByZXR1cm5zIHt7ZWRpdG9yV3JhcHBlcjogc3RyaW5nLCBlZGl0b3Jab25lOiBzdHJpbmd9fVxuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9yV3JhcHBlcjogXCJjb2RleC1lZGl0b3JcIixcbiAgICAgIGVkaXRvcldyYXBwZXJOYXJyb3c6IFwiY29kZXgtZWRpdG9yLS1uYXJyb3dcIixcbiAgICAgIGVkaXRvclpvbmU6IFwiY29kZXgtZWRpdG9yX19yZWRhY3RvclwiLFxuICAgICAgZWRpdG9yWm9uZUhpZGRlbjogXCJjb2RleC1lZGl0b3JfX3JlZGFjdG9yLS1oaWRkZW5cIixcbiAgICAgIGVkaXRvckxvYWRlcjogXCJjb2RleC1lZGl0b3JfX2xvYWRlclwiLFxuICAgICAgZWRpdG9yRW1wdHk6IFwiY29kZXgtZWRpdG9yLS1lbXB0eVwiLFxuICAgICAgZWRpdG9yUnRsRml4OiBcImNvZGV4LWVkaXRvci0tcnRsXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gV2lkdGggb2YgY2VudGVyIGNvbHVtbiBvZiBFZGl0b3JcbiAgICpcbiAgICogQHJldHVybnMge0RPTVJlY3R9XG4gICAqL1xuICBnZXQgY29udGVudFJlY3QoKSB7XG4gICAgaWYgKHRoaXMuY29udGVudFJlY3RDYWNoZSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRSZWN0Q2FjaGU7XG4gICAgY29uc3QgZSA9IHRoaXMubm9kZXMud3JhcHBlci5xdWVyeVNlbGVjdG9yKGAuJHtGLkNTUy5jb250ZW50fWApO1xuICAgIHJldHVybiBlID8gKHRoaXMuY29udGVudFJlY3RDYWNoZSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRoaXMuY29udGVudFJlY3RDYWNoZSkgOiB7XG4gICAgICB3aWR0aDogNjUwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBsb2FkZXIgdG8gZWRpdG9yIHdoaWxlIGNvbnRlbnQgaXMgbm90IHJlYWR5XG4gICAqL1xuICBhZGRMb2FkZXIoKSB7XG4gICAgdGhpcy5ub2Rlcy5sb2FkZXIgPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MuZWRpdG9yTG9hZGVyKSwgdGhpcy5ub2Rlcy53cmFwcGVyLnByZXBlbmQodGhpcy5ub2Rlcy5sb2FkZXIpLCB0aGlzLm5vZGVzLnJlZGFjdG9yLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuZWRpdG9yWm9uZUhpZGRlbik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgbG9hZGVyIHdoZW4gY29udGVudCBoYXMgbG9hZGVkXG4gICAqL1xuICByZW1vdmVMb2FkZXIoKSB7XG4gICAgdGhpcy5ub2Rlcy5sb2FkZXIucmVtb3ZlKCksIHRoaXMubm9kZXMucmVkYWN0b3IuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5lZGl0b3Jab25lSGlkZGVuKTtcbiAgfVxuICAvKipcbiAgICogTWFraW5nIG1haW4gaW50ZXJmYWNlXG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIHRoaXMuY2hlY2tJc01vYmlsZSgpLCB0aGlzLm1ha2UoKSwgdGhpcy5hZGRMb2FkZXIoKSwgdGhpcy5sb2FkU3R5bGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogSWYgcmVhZE9ubHkgaXMgdHJ1ZTpcbiAgICogIC0gcmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gbWFpbiBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogaWYgcmVhZE9ubHkgaXMgZmFsc2U6XG4gICAqICAtIGVuYWJsZXMgYWxsIGxpc3RlbmVycyB0byBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkgOiB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIEVkaXRvciBpcyBlbXB0eSBhbmQgc2V0IENTUyBjbGFzcyB0byB3cmFwcGVyXG4gICAqL1xuICBjaGVja0VtcHRpbmVzcygpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1MuZWRpdG9yRW1wdHksIGUuaXNFZGl0b3JFbXB0eSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9uZSBvZiBUb29sYmFyIGlzIG9wZW5lZFxuICAgKiBVc2VkIHRvIHByZXZlbnQgZ2xvYmFsIGtleWRvd25zIChmb3IgZXhhbXBsZSwgRW50ZXIpIGNvbmZsaWN0cyB3aXRoIEVudGVyLW9uLXRvb2xiYXJcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc29tZVRvb2xiYXJPcGVuZWQoKSB7XG4gICAgY29uc3QgeyBUb29sYmFyOiBlLCBCbG9ja1NldHRpbmdzOiB0LCBJbmxpbmVUb29sYmFyOiBvLCBDb252ZXJzaW9uVG9vbGJhcjogaSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgcmV0dXJuIHQub3BlbmVkIHx8IG8ub3BlbmVkIHx8IGkub3BlbmVkIHx8IGUudG9vbGJveC5vcGVuZWQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGZvciBzb21lIEZsaXBwZXItYnV0dG9ucyBpcyB1bmRlciBmb2N1c1xuICAgKi9cbiAgZ2V0IHNvbWVGbGlwcGVyQnV0dG9uRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lmhhc0ZvY3VzKCkgPyAhMCA6IE9iamVjdC5lbnRyaWVzKHRoaXMuRWRpdG9yKS5maWx0ZXIoKFtlLCB0XSkgPT4gdC5mbGlwcGVyIGluc3RhbmNlb2YgRykuc29tZSgoW2UsIHRdKSA9PiB0LmZsaXBwZXIuaGFzRm9jdXMoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFuIGVkaXRvcmBzIFVJXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm9kZXMuaG9sZGVyLmlubmVySFRNTCA9IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIGFsbCBFZGl0b3IncyB0b29sYmFyc1xuICAgKi9cbiAgY2xvc2VBbGxUb29sYmFycygpIHtcbiAgICBjb25zdCB7IFRvb2xiYXI6IGUsIEJsb2NrU2V0dGluZ3M6IHQsIElubGluZVRvb2xiYXI6IG8sIENvbnZlcnNpb25Ub29sYmFyOiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmNsb3NlKCksIG8uY2xvc2UoKSwgaS5jbG9zZSgpLCBlLnRvb2xib3guY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgZm9yIG1vYmlsZSBtb2RlIGFuZCBjYWNoZSBhIHJlc3VsdFxuICAgKi9cbiAgY2hlY2tJc01vYmlsZSgpIHtcbiAgICB0aGlzLmlzTW9iaWxlID0gd2luZG93LmlubmVyV2lkdGggPCBzdDtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgRWRpdG9yLmpzIGludGVyZmFjZVxuICAgKi9cbiAgbWFrZSgpIHtcbiAgICB0aGlzLm5vZGVzLmhvbGRlciA9IGQuZ2V0SG9sZGVyKHRoaXMuY29uZmlnLmhvbGRlciksIHRoaXMubm9kZXMud3JhcHBlciA9IGQubWFrZShcImRpdlwiLCBbXG4gICAgICB0aGlzLkNTUy5lZGl0b3JXcmFwcGVyLFxuICAgICAgLi4udGhpcy5pc1J0bCA/IFt0aGlzLkNTUy5lZGl0b3JSdGxGaXhdIDogW11cbiAgICBdKSwgdGhpcy5ub2Rlcy5yZWRhY3RvciA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5lZGl0b3Jab25lKSwgdGhpcy5ub2Rlcy5ob2xkZXIub2Zmc2V0V2lkdGggPCB0aGlzLmNvbnRlbnRSZWN0LndpZHRoICYmIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmVkaXRvcldyYXBwZXJOYXJyb3cpLCB0aGlzLm5vZGVzLnJlZGFjdG9yLnN0eWxlLnBhZGRpbmdCb3R0b20gPSB0aGlzLmNvbmZpZy5taW5IZWlnaHQgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLnJlZGFjdG9yKSwgdGhpcy5ub2Rlcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgfVxuICAvKipcbiAgICogQXBwZW5kcyBDU1NcbiAgICovXG4gIGxvYWRTdHlsZXMoKSB7XG4gICAgY29uc3QgZSA9IFwiZWRpdG9yLWpzLXN0eWxlc1wiO1xuICAgIGlmIChkLmdldChlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZC5tYWtlKFwic3R5bGVcIiwgbnVsbCwge1xuICAgICAgaWQ6IGUsXG4gICAgICB0ZXh0Q29udGVudDogZGkudG9TdHJpbmcoKVxuICAgIH0pO1xuICAgIGQucHJlcGVuZChkb2N1bWVudC5oZWFkLCB0KTtcbiAgfVxuICAvKipcbiAgICogQmluZCBldmVudHMgb24gdGhlIEVkaXRvci5qcyBpbnRlcmZhY2VcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucmVkYWN0b3IsIFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgIHRoaXMucmVkYWN0b3JDbGlja2VkKGUpO1xuICAgIH0sICExKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRUb3VjaGVkKGUpO1xuICAgIH0sICEwKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJ0b3VjaHN0YXJ0XCIsIChlKSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50VG91Y2hlZChlKTtcbiAgICB9LCAhMCksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duKGUpO1xuICAgIH0sICEwKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50Q2xpY2tlZChlKTtcbiAgICB9LCAhMCksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LCAhMCksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5yZXNpemVEZWJvdW5jZXIoKTtcbiAgICB9LCB7XG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pLCB0aGlzLndhdGNoQmxvY2tIb3ZlcmVkRXZlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiByZWRhY3RvciBtb3VzZW1vdmUgdG8gZW1pdCAnYmxvY2staG92ZXJlZCcgZXZlbnRcbiAgICovXG4gIHdhdGNoQmxvY2tIb3ZlcmVkRXZlbnRzKCkge1xuICAgIGxldCBlO1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucmVkYWN0b3IsIFwibW91c2Vtb3ZlXCIsIFRlKCh0KSA9PiB7XG4gICAgICBjb25zdCBvID0gdC50YXJnZXQuY2xvc2VzdChcIi5jZS1ibG9ja1wiKTtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFueUJsb2NrU2VsZWN0ZWQgfHwgbyAmJiBlICE9PSBvICYmIChlID0gbywgdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQobXQsIHtcbiAgICAgICAgYmxvY2s6IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5Q2hpbGROb2RlKG8pXG4gICAgICB9KSk7XG4gICAgfSwgMjApLCB7XG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVbmJpbmQgZXZlbnRzIG9uIHRoZSBFZGl0b3IuanMgaW50ZXJmYWNlXG4gICAqL1xuICBkaXNhYmxlTW9kdWxlQmluZGluZ3MoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMuY2xlYXJBbGwoKTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplIHdpbmRvdyBoYW5kbGVyXG4gICAqL1xuICB3aW5kb3dSZXNpemUoKSB7XG4gICAgdGhpcy5jb250ZW50UmVjdENhY2hlID0gbnVsbCwgdGhpcy5jaGVja0lzTW9iaWxlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbCBrZXlkb3ducyBvbiBkb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGRvY3VtZW50S2V5ZG93bihlKSB7XG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgQi5FTlRFUjpcbiAgICAgICAgdGhpcy5lbnRlclByZXNzZWQoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBCLkJBQ0tTUEFDRTpcbiAgICAgICAgdGhpcy5iYWNrc3BhY2VQcmVzc2VkKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQi5FU0M6XG4gICAgICAgIHRoaXMuZXNjYXBlUHJlc3NlZChlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvdXIoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSWdub3JlIGFsbCBvdGhlciBkb2N1bWVudCdzIGtleWRvd24gZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgZGVmYXVsdEJlaGF2aW91cihlKSB7XG4gICAgY29uc3QgeyBjdXJyZW50QmxvY2s6IHQgfSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlciwgbyA9IGUudGFyZ2V0LmNsb3Nlc3QoYC4ke3RoaXMuQ1NTLmVkaXRvcldyYXBwZXJ9YCksIGkgPSBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXk7XG4gICAgaWYgKHQgIT09IHZvaWQgMCAmJiBvID09PSBudWxsKSB7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja0V2ZW50cy5rZXlkb3duKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvIHx8IHQgJiYgaSB8fCAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmRyb3BQb2ludGVyKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlib2FyZCBldmVudFxuICAgKi9cbiAgYmFja3NwYWNlUHJlc3NlZChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKG8uYW55QmxvY2tTZWxlY3RlZCAmJiAhbS5pc1NlbGVjdGlvbkV4aXN0cykge1xuICAgICAgY29uc3QgbiA9IHQucmVtb3ZlU2VsZWN0ZWRCbG9ja3MoKTtcbiAgICAgIGkuc2V0VG9CbG9jayh0Lmluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgobiwgITApLCBpLnBvc2l0aW9ucy5TVEFSVCksIG8uY2xlYXJTZWxlY3Rpb24oZSksIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVzY2FwZSBwcmVzc2VkXG4gICAqIElmIHNvbWUgb2YgVG9vbGJhciBjb21wb25lbnRzIGFyZSBvcGVuZWQsIHRoZW4gY2xvc2UgaXQgb3RoZXJ3aXNlIGNsb3NlIFRvb2xiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBlc2NhcGUga2V5ZG93biBldmVudFxuICAgKi9cbiAgZXNjYXBlUHJlc3NlZChlKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSksIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuZWQgPyAodGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94LmNsb3NlKCksIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jaykpIDogdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgPyB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCkgOiB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci5vcGVuZWQgPyB0aGlzLkVkaXRvci5Db252ZXJzaW9uVG9vbGJhci5jbG9zZSgpIDogdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5vcGVuZWQgPyB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCkgOiB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVudGVyIHByZXNzZWQgb24gZG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBlbnRlclByZXNzZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSB0LmN1cnJlbnRCbG9ja0luZGV4ID49IDA7XG4gICAgaWYgKG8uYW55QmxvY2tTZWxlY3RlZCAmJiAhbS5pc1NlbGVjdGlvbkV4aXN0cykge1xuICAgICAgby5jbGVhclNlbGVjdGlvbihlKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc29tZVRvb2xiYXJPcGVuZWQgJiYgaSAmJiBlLnRhcmdldC50YWdOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgY29uc3QgbiA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoKTtcbiAgICAgIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sobiksIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5oaWdobGlnaHRDdXJyZW50Tm9kZSgpLCB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKG4pO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogQWxsIGNsaWNrcyBvbiBkb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gQ2xpY2sgZXZlbnRcbiAgICovXG4gIGRvY3VtZW50Q2xpY2tlZChlKSB7XG4gICAgaWYgKCFlLmlzVHJ1c3RlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZS50YXJnZXQ7XG4gICAgdGhpcy5ub2Rlcy5ob2xkZXIuY29udGFpbnModCkgfHwgbS5pc0F0RWRpdG9yIHx8ICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZHJvcFBvaW50ZXIoKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpKTtcbiAgICBjb25zdCBpID0gdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5ub2Rlcy53cmFwcGVyLmNvbnRhaW5zKHQpLCBuID0gdGhpcy5FZGl0b3IuVG9vbGJhci5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIuY29udGFpbnModCksIHIgPSBpIHx8IG47XG4gICAgaWYgKHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkICYmICFyKSB7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCk7XG4gICAgICBjb25zdCBhID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUodCk7XG4gICAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKGEpO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogRmlyc3QgdG91Y2ggb24gZWRpdG9yXG4gICAqIEZpcmVkIGJlZm9yZSBjbGlja1xuICAgKlxuICAgKiBVc2VkIHRvIGNoYW5nZSBjdXJyZW50IGJsb2NrIOKAlCB3ZSBuZWVkIHRvIGRvIGl0IGJlZm9yZSAnc2VsZWN0aW9uQ2hhbmdlJyBldmVudC5cbiAgICogQWxzbzpcbiAgICogLSBNb3ZlIGFuZCBzaG93IHRoZSBUb29sYmFyXG4gICAqIC0gU2V0IGEgQ2FyZXRcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgVG91Y2hFdmVudH0gZXZlbnQgLSB0b3VjaCBvciBtb3VzZSBldmVudFxuICAgKi9cbiAgZG9jdW1lbnRUb3VjaGVkKGUpIHtcbiAgICBsZXQgdCA9IGUudGFyZ2V0O1xuICAgIGlmICh0ID09PSB0aGlzLm5vZGVzLnJlZGFjdG9yKSB7XG4gICAgICBjb25zdCBvID0gZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBlLmNsaWVudFggOiBlLnRvdWNoZXNbMF0uY2xpZW50WCwgaSA9IGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ID8gZS5jbGllbnRZIDogZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChvLCBpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZSh0KSwgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmhpZ2hsaWdodEN1cnJlbnROb2RlKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLkVkaXRvci5SZWN0YW5nbGVTZWxlY3Rpb24uaXNSZWN0QWN0aXZhdGVkKCkgfHwgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9UaGVMYXN0QmxvY2soKTtcbiAgICB9XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBBbGwgY2xpY2tzIG9uIHRoZSByZWRhY3RvciB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBjbGljayBldmVudFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogLSBCeSBjbGlja3Mgb24gdGhlIEVkaXRvcidzIGJvdHRvbSB6b25lOlxuICAgKiAgICAgIC0gaWYgbGFzdCBCbG9jayBpcyBlbXB0eSwgc2V0IGEgQ2FyZXQgdG8gdGhpc1xuICAgKiAgICAgIC0gb3RoZXJ3aXNlLCBhZGQgYSBuZXcgZW1wdHkgQmxvY2sgYW5kIHNldCBhIENhcmV0IHRvIHRoYXRcbiAgICovXG4gIHJlZGFjdG9yQ2xpY2tlZChlKSB7XG4gICAgY29uc3QgeyBCbG9ja1NlbGVjdGlvbjogdCB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKCFtLmlzQ29sbGFwc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sIGkgPSBlLnRhcmdldCwgbiA9IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7XG4gICAgaWYgKGQuaXNBbmNob3IoaSkgJiYgbikge1xuICAgICAgbygpO1xuICAgICAgY29uc3QgdSA9IGkuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSwgaCA9IEh0KHUpO1xuICAgICAganQoaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KC0xKSwgYSA9IGQub2Zmc2V0KHIuaG9sZGVyKS5ib3R0b20sIGwgPSBlLnBhZ2VZO1xuICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZS50YXJnZXQuaXNFcXVhbE5vZGUodGhpcy5ub2Rlcy5yZWRhY3RvcikgJiYgLyoqXG4gICAgKiBJZiB0aGVyZSBpcyBjcm9zcyBibG9jayBzZWxlY3Rpb24gc3RhcnRlZCwgdGFyZ2V0IHdpbGwgYmUgZXF1YWwgdG8gcmVkYWN0b3Igc28gd2UgbmVlZCBhZGRpdGlvbmFsIGNoZWNrXG4gICAgKi9cbiAgICAhdC5hbnlCbG9ja1NlbGVjdGVkICYmIC8qKlxuICAgICogUHJldmVudCBjYXJldCBqdW1waW5nICh0byBsYXN0IGJsb2NrKSB3aGVuIGNsaWNraW5nIGJldHdlZW4gYmxvY2tzXG4gICAgKi9cbiAgICBhIDwgbCkge1xuICAgICAgbygpO1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHUsIENhcmV0OiBoLCBUb29sYmFyOiBmIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgICghdS5sYXN0QmxvY2sudG9vbC5pc0RlZmF1bHQgfHwgIXUubGFzdEJsb2NrLmlzRW1wdHkpICYmIHUuaW5zZXJ0QXRFbmQoKSwgaC5zZXRUb1RoZUxhc3RCbG9jaygpLCBmLm1vdmVBbmRPcGVuKHUubGFzdEJsb2NrKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBzZWxlY3Rpb24gY2hhbmdlcyBvbiBtb2JpbGUgZGV2aWNlc1xuICAgKiBVc2VzIGZvciBzaG93aW5nIHRoZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgc2VsZWN0aW9uQ2hhbmdlZCgpIHtcbiAgICBjb25zdCB7IENyb3NzQmxvY2tTZWxlY3Rpb246IGUsIEJsb2NrU2VsZWN0aW9uOiB0IH0gPSB0aGlzLkVkaXRvciwgbyA9IG0uYW5jaG9yRWxlbWVudDtcbiAgICBpZiAoZS5pc0Nyb3NzQmxvY2tTZWxlY3Rpb25TdGFydGVkICYmIHQuYW55QmxvY2tTZWxlY3RlZCAmJiBtLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpLCAhbykge1xuICAgICAgbS5yYW5nZSB8fCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSBvLmNsb3Nlc3QoYC4ke0YuQ1NTLmNvbnRlbnR9YCkgPT09IG51bGw7XG4gICAgaWYgKGkgJiYgKHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY29udGFpbnNOb2RlKG8pIHx8IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgIShvLmRhdGFzZXQuaW5saW5lVG9vbGJhciA9PT0gXCJ0cnVlXCIpKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrIHx8IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShvKTtcbiAgICBjb25zdCBuID0gaSAhPT0gITA7XG4gICAgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci50cnlUb1Nob3coITAsIG4pO1xuICB9XG59XG5jb25zdCB1aSA9IHtcbiAgLy8gQVBJIE1vZHVsZXNcbiAgQmxvY2tzQVBJOiBadCxcbiAgQ2FyZXRBUEk6IEd0LFxuICBFdmVudHNBUEk6IHF0LFxuICBJMThuQVBJOiBEZSxcbiAgQVBJOiBKdCxcbiAgSW5saW5lVG9vbGJhckFQSTogUXQsXG4gIExpc3RlbmVyc0FQSTogZW8sXG4gIE5vdGlmaWVyQVBJOiBubyxcbiAgUmVhZE9ubHlBUEk6IHNvLFxuICBTYW5pdGl6ZXJBUEk6IHBvLFxuICBTYXZlckFQSTogZm8sXG4gIFNlbGVjdGlvbkFQSTogZ28sXG4gIFN0eWxlc0FQSTogYm8sXG4gIFRvb2xiYXJBUEk6IG1vLFxuICBUb29sdGlwQVBJOiB4byxcbiAgVWlBUEk6IHdvLFxuICAvLyBUb29sYmFyIE1vZHVsZXNcbiAgQmxvY2tTZXR0aW5nczogUm8sXG4gIENvbnZlcnNpb25Ub29sYmFyOiBZLFxuICBUb29sYmFyOiBqbyxcbiAgSW5saW5lVG9vbGJhcjogVW8sXG4gIC8vIE1vZHVsZXNcbiAgQmxvY2tFdmVudHM6ICRvLFxuICBCbG9ja01hbmFnZXI6IEtvLFxuICBCbG9ja1NlbGVjdGlvbjogWG8sXG4gIENhcmV0OiB2ZSxcbiAgQ3Jvc3NCbG9ja1NlbGVjdGlvbjogVm8sXG4gIERyYWdORHJvcDogWm8sXG4gIE1vZGlmaWNhdGlvbnNPYnNlcnZlcjogR28sXG4gIFBhc3RlOiB3dCxcbiAgUmVhZE9ubHk6IHFvLFxuICBSZWN0YW5nbGVTZWxlY3Rpb246IHBlLFxuICBSZW5kZXJlcjogSm8sXG4gIFNhdmVyOiBRbyxcbiAgVG9vbHM6IFN0LFxuICBVSTogaGlcbn07XG5jbGFzcyBwaSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ30gY29uZmlnIC0gdXNlciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5tb2R1bGVJbnN0YW5jZXMgPSB7fSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyID0gbmV3IHdlKCk7XG4gICAgbGV0IHQsIG87XG4gICAgdGhpcy5pc1JlYWR5ID0gbmV3IFByb21pc2UoKGksIG4pID0+IHtcbiAgICAgIHQgPSBpLCBvID0gbjtcbiAgICB9KSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBlLCBhd2FpdCB0aGlzLnZhbGlkYXRlKCksIGF3YWl0IHRoaXMuaW5pdCgpLCBhd2FpdCB0aGlzLnN0YXJ0KCksIEsoXCJJJ20gcmVhZHkhICjvvonil5Xjg67il5Up776JKjrvvaXvvp/inKdcIiwgXCJsb2dcIiwgXCJcIiwgXCJjb2xvcjogI0UyNEE3NVwiKSwgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnJlbmRlcigpLCB0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b2ZvY3VzKSB7XG4gICAgICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGksIENhcmV0OiBuIH0gPSB0aGlzLm1vZHVsZUluc3RhbmNlcztcbiAgICAgICAgICBuLnNldFRvQmxvY2soaS5ibG9ja3NbMF0sIG4ucG9zaXRpb25zLlNUQVJUKSwgaS5oaWdobGlnaHRDdXJyZW50Tm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kdWxlSW5zdGFuY2VzLlVJLnJlbW92ZUxvYWRlcigpLCB0KCk7XG4gICAgICB9LCA1MDApO1xuICAgIH0pLmNhdGNoKChpKSA9PiB7XG4gICAgICBUKGBFZGl0b3IuanMgaXMgbm90IHJlYWR5IGJlY2F1c2Ugb2YgJHtpfWAsIFwiZXJyb3JcIiksIG8oaSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRpbmcgZm9yIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtFZGl0b3JDb25maWd8c3RyaW5nfSBjb25maWcgLSBFZGl0b3IncyBjb25maWcgdG8gc2V0XG4gICAqL1xuICBzZXQgY29uZmlndXJhdGlvbihlKSB7XG4gICAgdmFyIG8sIGk7XG4gICAgaihlKSA/IHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4uZVxuICAgIH0gOiB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGhvbGRlcjogZVxuICAgIH0sIEllKCEhdGhpcy5jb25maWcuaG9sZGVySWQsIFwiY29uZmlnLmhvbGRlcklkXCIsIFwiY29uZmlnLmhvbGRlclwiKSwgdGhpcy5jb25maWcuaG9sZGVySWQgJiYgIXRoaXMuY29uZmlnLmhvbGRlciAmJiAodGhpcy5jb25maWcuaG9sZGVyID0gdGhpcy5jb25maWcuaG9sZGVySWQsIHRoaXMuY29uZmlnLmhvbGRlcklkID0gbnVsbCksIHRoaXMuY29uZmlnLmhvbGRlciA9PSBudWxsICYmICh0aGlzLmNvbmZpZy5ob2xkZXIgPSBcImVkaXRvcmpzXCIpLCB0aGlzLmNvbmZpZy5sb2dMZXZlbCB8fCAodGhpcy5jb25maWcubG9nTGV2ZWwgPSBldC5WRVJCT1NFKSwgQXQodGhpcy5jb25maWcubG9nTGV2ZWwpLCBJZSghIXRoaXMuY29uZmlnLmluaXRpYWxCbG9jaywgXCJjb25maWcuaW5pdGlhbEJsb2NrXCIsIFwiY29uZmlnLmRlZmF1bHRCbG9ja1wiKSwgdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrID0gdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrIHx8IHRoaXMuY29uZmlnLmluaXRpYWxCbG9jayB8fCBcInBhcmFncmFwaFwiLCB0aGlzLmNvbmZpZy5taW5IZWlnaHQgPSB0aGlzLmNvbmZpZy5taW5IZWlnaHQgIT09IHZvaWQgMCA/IHRoaXMuY29uZmlnLm1pbkhlaWdodCA6IDMwMDtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgdHlwZTogdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyID0gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgITEsIHRoaXMuY29uZmlnLnNhbml0aXplciA9IHRoaXMuY29uZmlnLnNhbml0aXplciB8fCB7XG4gICAgICBwOiAhMCxcbiAgICAgIGI6ICEwLFxuICAgICAgYTogITBcbiAgICB9LCB0aGlzLmNvbmZpZy5oaWRlVG9vbGJhciA9IHRoaXMuY29uZmlnLmhpZGVUb29sYmFyID8gdGhpcy5jb25maWcuaGlkZVRvb2xiYXIgOiAhMSwgdGhpcy5jb25maWcudG9vbHMgPSB0aGlzLmNvbmZpZy50b29scyB8fCB7fSwgdGhpcy5jb25maWcuaTE4biA9IHRoaXMuY29uZmlnLmkxOG4gfHwge30sIHRoaXMuY29uZmlnLmRhdGEgPSB0aGlzLmNvbmZpZy5kYXRhIHx8IHsgYmxvY2tzOiBbXSB9LCB0aGlzLmNvbmZpZy5vblJlYWR5ID0gdGhpcy5jb25maWcub25SZWFkeSB8fCAoKCkgPT4ge1xuICAgIH0pLCB0aGlzLmNvbmZpZy5vbkNoYW5nZSA9IHRoaXMuY29uZmlnLm9uQ2hhbmdlIHx8ICgoKSA9PiB7XG4gICAgfSksIHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgPSB0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyICE9PSB2b2lkIDAgPyB0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyIDogITAsIChWKHRoaXMuY29uZmlnLmRhdGEpIHx8ICF0aGlzLmNvbmZpZy5kYXRhLmJsb2NrcyB8fCB0aGlzLmNvbmZpZy5kYXRhLmJsb2Nrcy5sZW5ndGggPT09IDApICYmICh0aGlzLmNvbmZpZy5kYXRhID0geyBibG9ja3M6IFt0XSB9KSwgdGhpcy5jb25maWcucmVhZE9ubHkgPSB0aGlzLmNvbmZpZy5yZWFkT25seSB8fCAhMSwgKG8gPSB0aGlzLmNvbmZpZy5pMThuKSAhPSBudWxsICYmIG8ubWVzc2FnZXMgJiYgJC5zZXREaWN0aW9uYXJ5KHRoaXMuY29uZmlnLmkxOG4ubWVzc2FnZXMpLCB0aGlzLmNvbmZpZy5pMThuLmRpcmVjdGlvbiA9ICgoaSA9IHRoaXMuY29uZmlnLmkxOG4pID09IG51bGwgPyB2b2lkIDAgOiBpLmRpcmVjdGlvbikgfHwgXCJsdHJcIjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcml2YXRlIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm5zIHtFZGl0b3JDb25maWd9XG4gICAqL1xuICBnZXQgY29uZmlndXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWc7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgcmVxdWlyZWQgZmllbGRzIGluIEVkaXRvcidzIGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlKCkge1xuICAgIGNvbnN0IHsgaG9sZGVySWQ6IGUsIGhvbGRlcjogdCB9ID0gdGhpcy5jb25maWc7XG4gICAgaWYgKGUgJiYgdClcbiAgICAgIHRocm93IEVycm9yKFwiwqtob2xkZXJJZMK7IGFuZCDCq2hvbGRlcsK7IHBhcmFtIGNhbid0IGFzc2lnbiBhdCB0aGUgc2FtZSB0aW1lLlwiKTtcbiAgICBpZiAoSih0KSAmJiAhZC5nZXQodCkpXG4gICAgICB0aHJvdyBFcnJvcihgZWxlbWVudCB3aXRoIElEIMKrJHt0fcK7IGlzIG1pc3NpbmcuIFBhc3MgY29ycmVjdCBob2xkZXIncyBJRC5gKTtcbiAgICBpZiAodCAmJiBqKHQpICYmICFkLmlzRWxlbWVudCh0KSlcbiAgICAgIHRocm93IEVycm9yKFwiwqtob2xkZXLCuyB2YWx1ZSBtdXN0IGJlIGFuIEVsZW1lbnQgbm9kZVwiKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgbW9kdWxlczpcbiAgICogIC0gbWFrZSBhbmQgc2F2ZSBpbnN0YW5jZXNcbiAgICogIC0gY29uZmlndXJlXG4gICAqL1xuICBpbml0KCkge1xuICAgIHRoaXMuY29uc3RydWN0TW9kdWxlcygpLCB0aGlzLmNvbmZpZ3VyZU1vZHVsZXMoKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgRWRpdG9yIVxuICAgKlxuICAgKiBHZXQgbGlzdCBvZiBtb2R1bGVzIHRoYXQgbmVlZHMgdG8gYmUgcHJlcGFyZWQgYW5kIHJldHVybiBhIHNlcXVlbmNlIChQcm9taXNlKVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGF3YWl0IFtcbiAgICAgIFwiVG9vbHNcIixcbiAgICAgIFwiVUlcIixcbiAgICAgIFwiQmxvY2tNYW5hZ2VyXCIsXG4gICAgICBcIlBhc3RlXCIsXG4gICAgICBcIkJsb2NrU2VsZWN0aW9uXCIsXG4gICAgICBcIlJlY3RhbmdsZVNlbGVjdGlvblwiLFxuICAgICAgXCJDcm9zc0Jsb2NrU2VsZWN0aW9uXCIsXG4gICAgICBcIlJlYWRPbmx5XCJcbiAgICBdLnJlZHVjZShcbiAgICAgICh0LCBvKSA9PiB0LnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMubW9kdWxlSW5zdGFuY2VzW29dLnByZXBhcmUoKTtcbiAgICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICAgIGlmIChpIGluc3RhbmNlb2YgYXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaS5tZXNzYWdlKTtcbiAgICAgICAgICBUKGBNb2R1bGUgJHtvfSB3YXMgc2tpcHBlZCBiZWNhdXNlIG9mICVvYCwgXCJ3YXJuXCIsIGkpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIGluaXRpYWwgZGF0YVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZUluc3RhbmNlcy5SZW5kZXJlci5yZW5kZXIodGhpcy5jb25maWcuZGF0YS5ibG9ja3MpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlIG1vZHVsZXMgaW5zdGFuY2VzIGFuZCBzYXZlIGl0IHRvIHRoZSBAcHJvcGVydHkgdGhpcy5tb2R1bGVJbnN0YW5jZXNcbiAgICovXG4gIGNvbnN0cnVjdE1vZHVsZXMoKSB7XG4gICAgT2JqZWN0LmVudHJpZXModWkpLmZvckVhY2goKFtlLCB0XSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5tb2R1bGVJbnN0YW5jZXNbZV0gPSBuZXcgdCh7XG4gICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdGhpcy5ldmVudHNEaXNwYXRjaGVyXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBUKFwiW2NvbnN0cnVjdE1vZHVsZXNdXCIsIGBNb2R1bGUgJHtlfSBza2lwcGVkIGJlY2F1c2VgLCBcImVycm9yXCIsIG8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGVzIGluc3RhbmNlcyBjb25maWd1cmF0aW9uOlxuICAgKiAgLSBwYXNzIG90aGVyIG1vZHVsZXMgdG8gdGhlICdzdGF0ZScgcHJvcGVydHlcbiAgICogIC0gLi4uXG4gICAqL1xuICBjb25maWd1cmVNb2R1bGVzKCkge1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLm1vZHVsZUluc3RhbmNlcylcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1vZHVsZUluc3RhbmNlcywgZSkgJiYgKHRoaXMubW9kdWxlSW5zdGFuY2VzW2VdLnN0YXRlID0gdGhpcy5nZXRNb2R1bGVzRGlmZihlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBtb2R1bGVzIHdpdGhvdXQgcGFzc2VkIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBtb2R1bGUgZm9yIHdpdGNoIG1vZHVsZXMgZGlmZmVyZW5jZSBzaG91bGQgYmUgY2FsY3VsYXRlZFxuICAgKi9cbiAgZ2V0TW9kdWxlc0RpZmYoZSkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG8gaW4gdGhpcy5tb2R1bGVJbnN0YW5jZXMpXG4gICAgICBvICE9PSBlICYmICh0W29dID0gdGhpcy5tb2R1bGVJbnN0YW5jZXNbb10pO1xuICAgIHJldHVybiB0O1xuICB9XG59XG4vKipcbiAqIEVkaXRvci5qc1xuICpcbiAqIEBsaWNlbnNlIEFwYWNoZS0yLjBcbiAqIEBzZWUgRWRpdG9yLmpzIDxodHRwczovL2VkaXRvcmpzLmlvPlxuICogQGF1dGhvciBDb2RlWCBUZWFtIDxodHRwczovL2NvZGV4LnNvPlxuICovXG5jbGFzcyBmaSB7XG4gIC8qKiBFZGl0b3IgdmVyc2lvbiAqL1xuICBzdGF0aWMgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIFwiMi4yNy4yXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWRpdG9yQ29uZmlnfHN0cmluZ3x1bmRlZmluZWR9IFtjb25maWd1cmF0aW9uXSAtIHVzZXIgY29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGxldCB0ID0gKCkgPT4ge1xuICAgIH07XG4gICAgaihlKSAmJiBEKGUub25SZWFkeSkgJiYgKHQgPSBlLm9uUmVhZHkpO1xuICAgIGNvbnN0IG8gPSBuZXcgcGkoZSk7XG4gICAgdGhpcy5pc1JlYWR5ID0gby5pc1JlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5leHBvcnRBUEkobyksIHQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRXhwb3J0IGV4dGVybmFsIEFQSSBtZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSB7Q29yZX0gZWRpdG9yIOKAlCBFZGl0b3IncyBpbnN0YW5jZVxuICAgKi9cbiAgZXhwb3J0QVBJKGUpIHtcbiAgICBjb25zdCB0ID0gW1wiY29uZmlndXJhdGlvblwiXSwgbyA9ICgpID0+IHtcbiAgICAgIE9iamVjdC52YWx1ZXMoZS5tb2R1bGVJbnN0YW5jZXMpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgRChuLmRlc3Ryb3kpICYmIG4uZGVzdHJveSgpLCBuLmxpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgICAgIH0pLCBlID0gbnVsbDtcbiAgICAgIGZvciAoY29uc3QgbiBpbiB0aGlzKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgbikgJiYgZGVsZXRlIHRoaXNbbl07XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbnVsbCk7XG4gICAgfTtcbiAgICB0LmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRoaXNbbl0gPSBlW25dO1xuICAgIH0pLCB0aGlzLmRlc3Ryb3kgPSBvLCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgZS5tb2R1bGVJbnN0YW5jZXMuQVBJLm1ldGhvZHMpLCBkZWxldGUgdGhpcy5leHBvcnRBUEksIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIGJsb2Nrczoge1xuICAgICAgICBjbGVhcjogXCJjbGVhclwiLFxuICAgICAgICByZW5kZXI6IFwicmVuZGVyXCJcbiAgICAgIH0sXG4gICAgICBjYXJldDoge1xuICAgICAgICBmb2N1czogXCJmb2N1c1wiXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG9uOiBcIm9uXCIsXG4gICAgICAgIG9mZjogXCJvZmZcIixcbiAgICAgICAgZW1pdDogXCJlbWl0XCJcbiAgICAgIH0sXG4gICAgICBzYXZlcjoge1xuICAgICAgICBzYXZlOiBcInNhdmVcIlxuICAgICAgfVxuICAgIH0pLmZvckVhY2goKFtuLCByXSkgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMocikuZm9yRWFjaCgoW2EsIGxdKSA9PiB7XG4gICAgICAgIHRoaXNbbF0gPSBlLm1vZHVsZUluc3RhbmNlcy5BUEkubWV0aG9kc1tuXVthXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5leHBvcnQge1xuICBmaSBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@editorjs/editorjs/dist/editorjs.mjs\n"));

/***/ })

}]);
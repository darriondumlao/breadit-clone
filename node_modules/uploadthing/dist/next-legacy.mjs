var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "uploadthing",
      version: "4.1.3",
      license: "MIT",
      exports: {
        "./package.json": "./package.json",
        "./client": {
          import: "./dist/client.mjs",
          types: "./dist/client.d.ts"
        },
        "./server": {
          import: "./dist/server.mjs",
          types: "./dist/server.d.ts",
          default: "./dist/server.mjs"
        },
        "./next": {
          import: "./dist/next.mjs",
          types: "./dist/next.d.ts"
        },
        "./next-legacy": {
          import: "./dist/next-legacy.mjs",
          types: "./dist/next-legacy.d.ts"
        }
      },
      files: [
        "dist"
      ],
      typesVersions: {
        "*": {
          "*": [
            "dist/*"
          ]
        }
      },
      scripts: {
        lint: 'eslint "**/*.{ts,tsx}" --max-warnings 0',
        build: "tsup",
        clean: "git clean -xdf dist node_modules",
        dev: "tsup --watch",
        test: "vitest run",
        "test:watch": "vitest",
        typecheck: "tsc --noEmit"
      },
      dependencies: {
        "@uploadthing/mime-types": "^0.2.0",
        "@uploadthing/shared": "^5.0.0"
      },
      devDependencies: {
        "@uploadthing/eslint-config": "0.1.0",
        "@uploadthing/tsconfig": "0.1.0",
        "@uploadthing/tsup-config": "0.1.0",
        eslint: "^8.42.0",
        next: "13.4.4",
        tsup: "6.7.0",
        "type-fest": "^3.11.1",
        typescript: "5.1.3",
        vitest: "^0.30.1"
      },
      publishConfig: {
        access: "public"
      }
    };
  }
});

// src/upload-builder.ts
function internalCreateBuilder(initDef = {}) {
  const _def = {
    // Default router config
    routerConfig: {
      image: {
        maxFileSize: "4MB"
      }
    },
    middleware: () => ({}),
    // Overload with properties passed in
    ...initDef
  };
  return {
    middleware(userMiddleware) {
      return internalCreateBuilder({
        ..._def,
        middleware: userMiddleware
      });
    },
    onUploadComplete(userUploadComplete) {
      return {
        _def,
        resolver: userUploadComplete
      };
    }
  };
}
function createBuilder() {
  return (input) => {
    return internalCreateBuilder({ routerConfig: input });
  };
}

// src/constants.ts
var packageJson = require_package();
if (!packageJson.version)
  throw new Error("no version found in package.json");
var UPLOADTHING_VERSION = packageJson.version;

// src/internal/handler.ts
import {
  generateUploadThingURL,
  getTypeFromFileName,
  getUploadthingUrl,
  fillInputRouteConfig as parseAndExpandInputConfig,
  pollForFileData
} from "@uploadthing/shared";
var fileCountLimitHit = (files, routeConfig) => {
  const counts = {};
  files.forEach((file) => {
    const type = getTypeFromFileName(
      file,
      Object.keys(routeConfig)
    );
    if (!counts[type]) {
      counts[type] = 1;
    } else {
      counts[type] += 1;
    }
  });
  return Object.keys(counts).some((key) => {
    var _a;
    const count = counts[key];
    if (count === 0)
      return false;
    const limit = (_a = routeConfig[key]) == null ? void 0 : _a.maxFileCount;
    if (!limit) {
      console.error(routeConfig, key);
      throw new Error("invalid config during file count");
    }
    return count > limit;
  });
};
if (process.env.NODE_ENV === "development") {
  console.log("[UT] UploadThing dev server is now running!");
}
var isValidResponse = (response) => {
  if (!response.ok)
    return false;
  if (response.status >= 400)
    return false;
  if (!response.headers.has("x-uploadthing-version"))
    return false;
  return true;
};
var conditionalDevServer = async (fileKey) => {
  if (process.env.NODE_ENV !== "development")
    return;
  const fileData = await pollForFileData(
    fileKey,
    async (json) => {
      const file = json.fileData;
      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
      if (!callbackUrl.startsWith("http"))
        callbackUrl = "http://" + callbackUrl;
      console.log("[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
      const response = await fetch(callbackUrl, {
        method: "POST",
        body: JSON.stringify({
          status: "uploaded",
          metadata: JSON.parse(file.metadata ?? "{}"),
          file: {
            url: `https://uploadthing.com/f/${encodeURIComponent(
              fileKey ?? ""
            )}`,
            key: fileKey ?? "",
            name: file.fileName
          }
        }),
        headers: {
          "uploadthing-hook": "callback"
        }
      });
      if (isValidResponse(response)) {
        console.log("[UT] Successfully simulated callback for file", fileKey);
      } else {
        console.error(
          "[UT] Failed to simulate callback for file. Is your webhook configured correctly?",
          fileKey
        );
      }
      return file;
    }
  );
  if (fileData !== null)
    return fileData;
  console.error(`[UT] Failed to simulate callback for file ${fileKey}`);
  throw new Error("File took too long to upload");
};
var buildRequestHandler = (opts) => {
  return async (input) => {
    const { router, config } = opts;
    const preferredOrEnvSecret = (config == null ? void 0 : config.uploadthingSecret) ?? process.env.UPLOADTHING_SECRET;
    const { uploadthingHook, slug, req, res, actionType } = input;
    if (!slug)
      throw new Error("we need a slug");
    if (!preferredOrEnvSecret) {
      throw new Error(
        `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`
      );
    }
    const uploadable = router[slug];
    if (!uploadable) {
      return { status: 404 };
    }
    const reqBody = await req.json();
    if (uploadthingHook && uploadthingHook === "callback") {
      await uploadable.resolver({
        file: reqBody.file,
        metadata: reqBody.metadata
      });
      return { status: 200 };
    }
    if (!actionType || actionType !== "upload") {
      return { status: 404 };
    }
    try {
      const { files } = reqBody;
      const metadata = await uploadable._def.middleware(req, res);
      if (!Array.isArray(files) || !files.every((f) => typeof f === "string"))
        throw new Error("Need file array");
      const parsedConfig = parseAndExpandInputConfig(
        uploadable._def.routerConfig
      );
      const limitHit = fileCountLimitHit(files, parsedConfig);
      if (limitHit)
        throw new Error("Too many files");
      const uploadthingApiResponse = await fetch(
        generateUploadThingURL("/api/prepareUpload"),
        {
          method: "POST",
          body: JSON.stringify({
            files,
            routeConfig: parsedConfig,
            metadata,
            callbackUrl: (config == null ? void 0 : config.callbackUrl) ?? getUploadthingUrl(),
            callbackSlug: slug
          }),
          headers: {
            "Content-Type": "application/json",
            "x-uploadthing-api-key": preferredOrEnvSecret,
            "x-uploadthing-version": UPLOADTHING_VERSION
          }
        }
      );
      if (!uploadthingApiResponse.ok) {
        console.error("[UT] unable to get presigned urls");
        try {
          const error = await uploadthingApiResponse.json();
          console.error(error);
        } catch (e) {
          console.error("[UT] unable to parse response");
        }
        throw new Error("ending upload");
      }
      const parsedResponse = await uploadthingApiResponse.json();
      if (process.env.NODE_ENV === "development") {
        for (const file of parsedResponse) {
          void conditionalDevServer(file.key);
        }
      }
      return { body: parsedResponse, status: 200 };
    } catch (e) {
      console.error("[UT] middleware failed to run");
      console.error(e);
      return { status: 400, message: e.toString() };
    }
  };
};
var buildPermissionsInfoHandler = (opts) => {
  return () => {
    const r = opts.router;
    const permissions = Object.keys(r).map((k) => {
      const route = r[k];
      const config = parseAndExpandInputConfig(route._def.routerConfig);
      return {
        slug: k,
        config
      };
    });
    return permissions;
  };
};

// src/next/core/page.ts
var createNextPageApiHandler = (opts) => {
  const requestHandler = buildRequestHandler(opts);
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  return async (req, res) => {
    if (req.method === "GET") {
      const perms = getBuildPerms();
      res.status(200).json(perms);
      return;
    }
    const params = req.query;
    const uploadthingHook = req.headers["uploadthing-hook"];
    const slug = params["slug"];
    const actionType = params["actionType"];
    if (slug && typeof slug !== "string")
      return res.status(400).send("`slug` must not be an array");
    if (actionType && typeof actionType !== "string")
      return res.status(400).send("`actionType` must not be an array");
    if (uploadthingHook && typeof uploadthingHook !== "string")
      return res.status(400).send("`uploadthingHook` must not be an array");
    if (typeof req.body !== "string")
      return res.status(400).send("Request body must be a JSON string");
    const standardRequest = {
      ...req,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      json: () => Promise.resolve(JSON.parse(req.body)),
      headers: {
        get: (key) => req.headers[key]
      }
    };
    const response = await requestHandler({
      uploadthingHook,
      slug,
      actionType,
      req: standardRequest,
      res
    });
    res.status(response.status);
    res.setHeader("x-uploadthing-version", UPLOADTHING_VERSION);
    if (response.status === 200) {
      return res.json(response.body);
    }
    return res.send(response.message ?? "Unable to upload file.");
  };
};

// next-legacy.ts
var createUploadthing = () => createBuilder();
export {
  createNextPageApiHandler,
  createUploadthing
};
//# sourceMappingURL=next-legacy.mjs.map